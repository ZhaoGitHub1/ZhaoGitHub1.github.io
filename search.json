[{"title":"IDEA使用总结","url":"/2019/06/01/tool-idea/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](tool-idea/idea.jpg )\n\n> 资源列表\n>\n> 1. 官方网站：<http://www.jetbrains.com/idea/>\n> 2. 官网教学视频：<http://www.jetbrains.com/idea/documentation/>\n\n## 简介\n\nIDEA 全称 IntelliJ IDEA，是java编程语言开发的集成环境。IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Python等少数语言。\n\n## 安装与破解\n\n下载地址：<http://www.jetbrains.com/idea/download>\n\n![](tool-idea/idea_download.jpg)\n\nidea官方提供了windows、macOS、linux三种系统可供选择，每种操作系统都提供了Ultimate，Community两种版本，前者为收费版，包含全部功能，后者为社区版，包含部分功能。下载安装过程与大多数软件大同小异，此处不再赘述。值得一提的是，收费版需要购买注册码，要$499每年，属实不便宜，故此处记录下网友们的破解方法，如果有能力还是提倡支持正版。\n\n### 破解\n\n第一步，下载`JetbrainsIdesCrack-4.2-release`，百度云下载地址：https://pan.baidu.com/s/1PrTR_CQSMa82UiyDXxLk1Q 提取码: 65up\n\n第二步，将下载的jar扔到IDEA的bin目录下，如图![](tool-idea/crack1.jpg)\n\n第三步，如果电脑是64位的就编辑`idea64.exe.vmoptions`文件，32位编辑`idea.exe.vmoptions`这个文件，在最后面添加：`-javaagent:G:\\IntelliJ IDEA 2019.1\\bin\\JetbrainsIdesCrack-4.2-release.jar`，bin前面替换成idea的安装目录，后面替换成下载到的jar名称。\n\n第四步，启动idea填写注册码。有两种方法填写注册码，一种是通过lanyu`s大神提供的在线生成注册码的工具生成注册码，地址是：http://idea.lanyus.com/， 点击下方“获取注册码”，即可获取注册码，优点是简单方便，缺点是要修改host文件及有效期只有一年。\n\n## 插件推荐\n\n### Lombok\n\nLombok是一款通过注解在Java编译期生成代码的工具，需要安装idea插件及添加lombok的maven依赖。如下\n\n```pom\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n```\n\n#### 常用注解\n\n- `@AllArgsConstructor`：生产全参构造函数\n- `@NoArgsConstructor`：生成无参构造函数\n- `@RequiredArgsConstructor`：生成参数是final字段和带有@NonNull等约束的字段的构造函数\n- `@Builder`：bulider模式构造对象\n- `@Data`：是`@Getter` `@Setter` `@RequiredArgsConstructor` `@ToString` `@EqualsAndHashCode`的组合注解\n- `@EqualsAndHashCode`：自动重写equals和hashCode方法\n- `@Getter`：生成属性getter方法\n- `@Setter`：生成属性setter方法\n- `@ToString`：自动重写toString方法\n- `@Slf4j`、`@Log4j`、`@Log4j2`：提供日志支持\n\n### Translation\n\n支持三种谷歌翻译、有道翻译和百度翻译三种，个人推荐谷歌翻译但需要科学上网或者配置代理\n\n![](tool-idea/idea_translate.jpg)\n\nidea配置http代理\n\n![](tool-idea/idea_proxy.jpg)\n\n若是无法科学上网或者没有代理可以配置，则推荐有道翻译，但是需要到有道开放平台申请应用ID及应用密钥，点击红色框下面的蓝色字或者[这里](http://ai.youdao.com/)申请。\n\n![](tool-idea/idea_translate2.jpg)\n\n可以使用快捷键：`Ctrl+Shift+Y`呼出如下翻译界面，如下图一。可以使用快捷键：`Ctrl+Shift+O`呼出如下翻译界面，如下图二。当然也支持段落翻译，如下图三。![图一](tool-idea/idea_translate3.jpg)![图二](tool-idea/idea_translate4.jpg)![图三](tool-idea/idea_translate5.jpg)\n\n### JRebel for IntelliJ\n\n#### 破解教程\n\n下载lanyu's大神做的[反代工具](http://blog.lanyus.com/archives/317.html)，下载地址：<https://github.com/ilanyu/ReverseProxy/releases>，我是windows系统，所以下载了[ReverseProxy_windows_amd64.exe](https://github.com/ilanyu/ReverseProxy/releases/download/v1.4/ReverseProxy_windows_amd64.exe)这个版本，下载之后直接双击执行，然后允许通过防火墙，然后开始激活JRebel，选择Team URL，填写http://127.0.0.1:8888/UUID和有效邮箱格式，如下图一，下面I agree点一下，等几秒钟，就ok了，如下图二，此时exe窗口出现了变化如下图三，激活成功界面如下图四\n\n![图一](tool-idea/jrebel.jpg)![图二](tool-idea/jrebel1.jpg)![图三](tool-idea/jrebel3.jpg)![图四](tool-idea/jrebel4.jpg)\n\n点击Work offline就可以开启离线模式了。此时启动项目就会有相关日志打印出来，如下图五\n\n![图五](tool-idea/jrebel5.jpg)\n\n### GsonFormat\n\n一个json格式化插件，简单实用，`Alt+Insert`呼出Generate界面，选择GsonFormat则可格式化json数据\n\n![](tool-idea/gson1.jpg)![](tool-idea/gson.jpg)\n\n### GenerateAllSetter\n\n在`User user`的user上使用快捷键`Alt+Enter`可以呼出如下界面图一，可以选择第一个生成User所有属性值为空的setter方法，选择第二个可以生成所有属性值为默认值的setter方法。生成之后如下图二\n\n![图一](tool-idea/generateAllSetter.jpg)![图一](tool-idea/generateAllSetter1.jpg)\n\n### Maven Helper\n\n打开pom文件，下面切换tab到`Dependency Analyzer`可以查看冲突的依赖，所有依赖列表和所有依赖树等，还可以重新导入，不过这个跟右侧的maven管理功能重叠了，不常用，常用的是用来分析maven依赖关系及冲突的jar包，方便管理maven依赖。\n\n![](tool-idea/maven.jpg)\n\n## 常用设置\n\n### 主题设置\n\n![](tool-idea/setting-theme.jpg)\n\n### 更新提示关闭设置\n\n![](tool-idea/setting-update.jpg)\n\n### 快捷键设置\n\nidea为从eclipse转过来的用户专门设置了一套与idea基本一致的快捷键集，大大降低了转开发工具的难度，而且支持部分快捷键更改，很灵活。\n\n![](tool-idea/setting-keymap.jpg)\n\n![](tool-idea/setting-keymap1.jpg)\n\n### 自动导包设置\n\n因人而异，有些人喜欢自动导包可控性强且可以熟悉代码都用了那些依赖包，有人怕麻烦喜欢自动导包，看喜好吧。\n\n![](tool-idea/setting-import.jpg)\n\n### 代码折叠设置\n\n![](tool-idea/setting-code-folding.jpg)\n\n### 字体设置\n\n![](tool-idea/setting-font.jpg)\n\n### 配色方案设置\n\n三种界面及代码配色方案，君可按个人喜好选择。\n\n![](tool-idea/setting-color-scheme.jpg)\n\n`Default`方案，整个界面为白色底色，与eclipse配色相近，刚从eclipse转到idea的小伙伴会更适应。\n\n![](tool-idea/setting-color-scheme1.jpg)\n\n`Darcula`配色方案，整体底色为黑色，高端大气，个人比较喜欢这个配色。\n\n![](tool-idea/setting-color-scheme2.jpg)\n\n`High Contrast`配色方案，整体配色与`Darcula`相近，不同的是这款配色方案代码加了高亮显示，让人更沉浸在coding中。\n\n![](tool-idea/setting-color-scheme3.jpg)\n\n当然也可以三种方案自由搭配，如图整体配色方案为`Darcula`时也可以单独设置java代码块配色方案为`Default`，并可在下方预览设置效果。\n\n![](tool-idea/setting-color-scheme4.jpg)\n\n### 代码风格设置\n\n下面是java代码中Tab和缩进设置，我们使用Tab键为4个空格缩进，该设置团队应统一。\n\n![](tool-idea/setting-code-style.jpg)\n\nJava代码块中空格位置设置，建议采用默认设置，如需修改某一项，可在右侧预览。\n\n![](tool-idea/setting-code-style1.jpg)\n\n### 文件编码格式设置\n\n文件编码格式设置，可为每个model设置不同的编码格式\n\n![](tool-idea/setting-file-encoding.jpg)\n\n### 插件安装\n\n![](tool-idea/setting-plugins.jpg)\n\n当然如果网络被墙或者被限制时，也可以选择设置代理或者从硬盘选择文件进行安装，这时就比较灵活了。\n\n![](tool-idea/setting-plugins1.jpg)\n\n### 版本控制设置\n\n关联github账户，这样做的好处是很多文件的操作会自动进行版本管控，而且往github推拉文件都比较方便。\n\n![](tool-idea/setting-github.jpg)\n\n例如，当使用idea从git克隆仓库时，会自动检测登录账号下的仓库，方便快捷，当然`Git Bash`拉取也很方便。\n\n![](tool-idea/setting-github1.jpg)![](tool-idea/setting-github2.jpg)\n\n![](tool-idea/setting-github3.jpg)\n\n![](tool-idea/setting-github4.jpg)\n\n### Maven设置\n\n![](tool-idea/setting-maven1.jpg)\n\n![](tool-idea/setting-maven2.jpg)\n\n\n\n## 使用技巧-深度用户必备\n\n墙裂推荐可以前进后退的鼠标（带侧键），真正的物超所值，真正的提高效率，不管是浏览网页，还是翻源码阅读，都可以方便的通过侧键快速前进或后退，相当好用！下面进入主题。。。\n\n### 编码技巧\n\n作为一名java程序员，写的CRUD不胜其数，这其中很多都是重复而无意义的劳动，而凡是重复的都可以简化或避免，而IDEA号称java最完美的开发工具，一定程度上为我们简化了很多开发步骤，下面我举例说明我是如何简化crud编程的，作为抛砖引玉，若有更好的方法一定请不吝赐教。\n\n#### CRUD提速技巧\n\n现在一般的项目都是前后端分离，后端负责编写api接口，而后端业务架构一般都分为controller、service、dao层，下面我们使用springboot框架举例写一个用户信息的crud。\n\n简单写我提升效率的思路，利用IDEA报错提示和快捷修复功能，快速创建依赖类和方法，从controller写，依次创建依赖的service和dao及内部方法。创建对象时，利用new 对象().var，快速创建并从候选的命名内选择，利用插件根据表结构定义，快速生成entity类，利用GenerateAllSetter插件，快速生成setter方法，利用BeanUtils.class工具类，快速实现对象间拷贝属性。\n\n// todo贴图\n\n#### 快速生成Junit单元测试技巧。\n\n`Alt+Insert`呼出Generate界面，选择`Test...`，呼出右侧界面，其中①处可以选择单元测试所使用的框架或者二类库，②可以指定该类对应的单元测试类名称，③可以指定该单元测试类继承的父类，一般都是统一继承一个父类，父类里面写单元测试的注解、资源初始化、mock登录、资源释放等操作，④处指定生成的单元测试类包全路径，⑤处可以选择是否生成setUp和tearDown方法，一般③处继承父类就不需要勾选了，⑥处指定生成哪些方法的单元测试方法。\n\n![](tool-idea/test1.jpg)![](tool-idea/test2.jpg)\n\n### 重构技巧\n\n#### 重命名\n\n重构快捷键神器：`Shift+F6`，不管是类名，方法名，变量名统统都可以解决，还可以根据设置检测依赖这个命名的变量，提示您是否同步作出修改。如图。\n\n**重命名类**，原类名为`UserService`，默认为全选状态，直接输入新类名即可替换，下面①处可以搜索所有使用了`UserService`这个词的评论和字符，并且提示出来，②处会按文本搜索这个词出现的位置，并提示，③处会重命名测试类中该单词的使用，④处会重命名依赖这个单词的命名，⑤处会重命名以这个单词命名的变量\n\n![](tool-idea/idea_rename1.png)\n\n**重命名方法和变量**，就不贴图了，该方法会自动重命名依赖这个方法的名字，若为变量，则会自动查询与这个变量引用相同的变量名称。\n\n#### 提取代码段\n\n选中带抽取的代码块，按快捷键`Ctrl + Alt + M`会自动提取代码段生成一个方法，默认为private，可以修改，此外返回值类型、方法名入参等都可修改，如下图一，点击`Refactor`后就会生成如下图二的`private`函数了。\n\n![](tool-idea/idea_refactory1.png)\n\n![](tool-idea/idea_refactory2.png)\n\n### 阅读源码技巧\n\n#### 查看类UML图\n\n快捷键：`Ctrl+Alt+U`：弹层打开、`Ctrl+Alt+Shift+U`：新窗口打开\n\n如下图则为`ArrayList.class`按`Ctrl+Alt+Shift+U`之后自动生成的UML类图，按`space`可添加任意类到UML图中，有意思的是还提供了放大镜的功能，按住`Alt`即可。\n\n![](tool-idea/idea_uml1.png)\n\n下图为jdk 1.8下重用的集合工具类UML图\n\n![](tool-idea/collectors.png)\n\n### debug技巧\n\n// todo汇总debug技巧\n\n## 快捷键汇总\n\n这个网络上比较多，这里就不总结了，贴几个链接。\n\n<https://www.open-open.com/lib/view/open1396578860887.html>\n\n<https://www.jianshu.com/p/ce91cea16c60>\n\n## 其他功能\n\n### 终端\n\n### 数据库工具\n\n### Docker","tags":["工具"],"categories":["工具"]},{"title":"工具推荐","url":"/2019/05/12/tool-recommend/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](tool-recommend/1.jpg )\n\n\t工欲善其事，必先利器，本人常用及觉得好用工具推荐汇总，排名不分先后。\n\n## 在线工具及网站\n\n### [GitHub](https://github.com/)\n\n```markdown\nGitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。\n```\n\n### [码云Gitee](https://gitee.com/)\n\n\t码云(*gitee*.com)是 OSCHINA.NET 推出的代码托管平台,支持 Git 和 SVN,提供免费的私有仓库托管。国内版GitHub.\n\n### [Stack Overflow](https://stackoverflow.com/)\n\n\tStack Overflow是一个与程序相关的IT技术问答网站。\n\n### [ProcessOn](https://www.processon.com/)\n\n\tProcessOn是一个在线作图工具的聚合平台，它可以在线画流程图、思维导图、UI原型图、UML、网络拓扑图、组织结构图等等， 您无需担心下载和更新的问题，不管Mac还是Windows，一个浏览器就可以随时随地的发挥创意，规划工作\n\n> 帮助文档：https://www.processon.com/support\n\n## 非在线工具\n\n### [Typora](https://www.typora.io/)\n\n\tTypora will give you a seamless experience as both a reader and a writer. It removes the preview window, mode switcher, syntax symbols of markdown source code, and all other unnecessary distractions. Replace them with a real live preview feature to help you concentrate the content itself.\n\n### [百度网盘](https://pan.baidu.com/)\n\n\t百度网盘是百度推出的一项云存储服务，首次注册即有机会获得2T的空间，已覆盖主流PC和手机操作系统，包含Web版、Windows版、Mac版、Android版、iPhone版和Windows Phone版。\n\n### Google浏览器\n\n\tGoogle Chrome是一款由Google公司开发的网页浏览器，该浏览器基于其他开源软件撰写，包括WebKit，目标是提升稳定性、速度和安全性，并创造出简单且有效率的使用者界面。\n\n#### chrome插件\n\n##### [Octotree](https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=zh-CN)\n\n##### [Proxy SwitchyOmega](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN)\n\n##### [Session Buddy](https://chrome.google.com/webstore/detail/session-buddy/edacconmaakjimmfgnblocblbcdcpbko?hl=zh-CN)\n\n##### [Tampermonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN)\n\n##### [Grammarly for Chrome](https://chrome.google.com/webstore/detail/grammarly-for-chrome/kbfnbcaeplbcioakkpcpgfkobkghlhen?hl=zh-CN)\n\n##### [Adblock Plus - free ad blocker](https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb?hl=zh-CN)\n\n##### [掘金](https://chrome.google.com/webstore/detail/%E6%8E%98%E9%87%91/lecdifefmmfjnjjinhaennhdlmcaeeeb?hl=zh-CN)\n\n### [360压缩](http://yasuo.360.cn/)\n\n\t360压缩是新一代的压缩软件，永久免费。360压缩相比传统压缩软件更快更轻巧，支持解压主流的rar、zip、7z、iso等多达40种压缩文件。360压缩内置云安全引擎，可以检测木马，更安全。大幅简化了传统软件的繁琐操作，还改进了超过20项的使用细节，拥有全新的界面。360压缩的主要特点是快速轻巧、兼容性好、更安全、更漂亮，而且是永久免费的。\n\n### [IDEA](https://www.jetbrains.com/idea/)\n\n\tIDEA 全称 IntelliJ IDEA，是java编程语言开发的集成环境。IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Python等少数语言。\n\n#### IDEA插件\n\n##### **Lombok**\n\n高效开发必备，自动生成getter/setter、toString、hash、equals等等方法\n\n##### **Translate**\n\n快捷键：Ctrl+Shift+O，Ctrl+Shift+Y\n\n### [SecureCRT](https://www.vandyke.com/products/securecrt/)\n\n\tSecureCRT是一款支持SSH（SSH1和SSH2）的终端仿真程序，简单地说是Windows下登录UNIX或Linux服务器主机的软件。\n\t\n\tSecureCRT支持SSH，同时支持Telnet和rlogin协议。SecureCRT是一款用于连接运行包括Windows、UNIX和VMS的理想工具。通过使用内含的VCP命令行程序可以进行加密文件的传输。有流行CRTTelnet客户机的所有特点,包括:自动注册、对不同主机保持不同的特性、打印功能、颜色设置、可变屏幕尺寸、用户定义的键位图和优良的VT100,VT102,VT220和ANSI竞争.能从命令行中运行或从浏览器中运行.其它特点包括文本手稿、易于使用的工具条、用户的键位图编辑器、可定制的ANSI颜色等.SecureCRT的SSH协议支持DES,3DES和RC4密码和密码与RSA鉴别。\n\n### [Git](https://git-scm.com/)\n\n\tGit是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\n\n### [Maven](http://maven.apache.org/)\n\n\tMaven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。\n\t\n\tMaven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。\n\n### [Jekins](https://jenkins.io/)\n\n### [Docker](https://www.docker.com/)\n\n### [Postman](https://www.getpostman.com/)\n\n### [Navicat Premium](https://www.navicat.com.cn/)\n\n\tNavicat premium是一款数据库管理工具,是一个可多重连线资料库的管理工具，它可以让你以单一程式同时连线到 MySQL、SQLite、Oracle 及 PostgreSQL 资料库，让管理不同类型的资料库更加的方便。\n\n### [Notepad++](https://notepad-plus-plus.org/)\n\n\tNotepad++是 Windows操作系统下的一套文本编辑器(软件版权许可证: GPL)，有完整的中文化接口及支持多国语言编写的功能(UTF8技术)。\n\t\n\tNotepad++功能比 Windows中的 Notepad(记事本)强大，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。Notepad++ 不仅有语法高亮度显示，也有语法折叠功能，并且支持宏以及扩充基本功能的外挂模组。\nNotepad++是免费软件，可以免费使用，自带中文，支持众多计算机程序语言: \n\n### [JMeter](https://jmeter.apache.org/)\n\n\tApache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。\n\n","tags":["工具"],"categories":["工具"]},{"title":"spring-data-jpa使用总结","url":"/2019/04/06/spring-data-jpa-summary/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](spring-data-jpa-summary/jpa.jpg)\n\n> 参考资源列表\n>\n> 1. 官方文档：https://docs.spring.io/spring-data/jpa/docs/2.1.5.RELEASE/reference/html/\n> 2. 《Spring Data JPA入门到精通》\n\n## 前言\n\n`JPA`是`Java Persistence API`的简称，是`Spring`在`Hibernate`的基础上进行的二次封装框架，为了更好更方便的融入`Spring`大家庭，同时也提供了一些`Hibernate`没有的特性，与其他ORM框架一起构成`SpringData`，统一封装了ORM层，使开发人员使用起来更加方便快捷。\n\n> 备注：本文所有代码都是基于SpringBoot 2.1.5版本\n\n## JPA的使用\n\n### 基本单表操作的使用\n\n对于操作单表来说，jpa提供了非常方便使用的封装，我们只需要按规范编写Repository接口同时继承`JpaRepository`就可以享用jpa基本功能了。代码如下：\n\nUser实体:\n\n```java\npackage com.yizhu.entity;\n\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.ToString;\n\nimport javax.persistence.*;\nimport java.io.Serializable;\nimport java.util.List;\nimport java.util.Set;\n\n@Entity\n@Table(name = \"t_user\")\n@Data\n@Builder\npublic class User implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n\n    private String password;\n\n    private Integer age;\n\n    private Integer sex;\n}\n\n```\n\nrepository接口：\n\n```java\npackage com.yizhu.repository;\n\nimport com.yizhu.entity.User;\n\npublic interface UserRepository extends JpaRepository<User, Long>{\n}\n```\n\n下面看看jpa为我们提供了哪些默认操作单表数据的方法\n\n```java\npackage org.springframework.data.jpa.repository;\n@NoRepositoryBean\npublic interface JpaRepository<T, ID> extends PagingAndSortingRepository<T, ID>, QueryByExampleExecutor<T> {\n    List<T> findAll(); // 查询全表数据\n\n    List<T> findAll(Sort var1); // 查询全表数据，支持排序\n\n    List<T> findAllById(Iterable<ID> var1); // 根据id字段查询所有匹配数据\n\n    <S extends T> List<S> saveAll(Iterable<S> var1); // 批量保存或更新数据\n\n    void flush(); // 刷新本地缓存到数据库\n\n    <S extends T> S saveAndFlush(S var1); // 保存或更新单挑数据及刷新本地缓存到数据库\n\n    void deleteInBatch(Iterable<T> var1); // 批量删除数据\n\n    void deleteAllInBatch(); // 批量删除全表数据\n\n    T getOne(ID var1); // 根据id查询一条匹配数据\n\n    <S extends T> List<S> findAll(Example<S> ar1); // Example方式的查询指定实体\n\n    <S extends T> List<S> findAll(Example<S> var1, Sort var2);\t// Example方式的查询指定实体并排序\n}\n```\n\n```java\npackage org.springframework.data.repository;\n@NoRepositoryBean\npublic interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {\n    Iterable<T> findAll(Sort var1);\t // 根据排序查询全表，返回类型是任意集合\n\n    Page<T> findAll(Pageable var1);\t// 根据分页参数分页查询\n}\n```\n\n```java\npackage org.springframework.data.repository;\n@NoRepositoryBean\npublic interface CrudRepository<T, ID> extends Repository<T, ID> {\n    <S extends T> S save(S var1);\t// 保存或更新单条数据\n\n    <S extends T> Iterable<S> saveAll(Iterable<S> var1);  // 批量保存或更新\n\n    Optional<T> findById(ID var1);\t// 根据id查询数据，返回类型是Optional\n\n    boolean existsById(ID var1);\t// 根据id判断数据是否存在\n\n    Iterable<T> findAll(); // 查询全表数据，返回类型为集合\n\n    Iterable<T> findAllById(Iterable<ID> var1);\t// 根据id集合查询数据\n\n    long count();\t// 统计全表数据量\n\n    void deleteById(ID var1); // 根据id删除数据\n\n    void delete(T var1);\t// 删除单条数据\n\n    void deleteAll(Iterable<? extends T> var1);\t\t// 删除指定集合数据\n\n    void deleteAll();\t// 删除全表数据\n}\n```\n\n```java\npackage org.springframework.data.repository.query;\npublic interface QueryByExampleExecutor<T> {\n    <S extends T> Optional<S> findOne(Example<S> var1); // 根据Example查询一条\n\n    <S extends T> Iterable<S> findAll(Example<S> var1);\t// 根据Example查询所有数据\n\n    <S extends T> Iterable<S> findAll(Example<S> var1, Sort var2);\t// 根据Example查询所有数据，并排序\n\n    <S extends T> Page<S> findAll(Example<S> var1, Pageable var2);\t// 根据Example分页查询\n\n    <S extends T> long count(Example<S> var1);\t// 根据Example统计\n\n    <S extends T> boolean exists(Example<S> var1);\t// 根据Example判断数据是否存在\n}\n```\n\n除此之外，jpa提供了一套新的生成sql的机制，非常方便好用，jpa根据Repository接口的方法中的关键字、实体字段及出入参，自动生成sql，这种方式启动容器的时候就可以检查语法是否正确，简单使用例子如下：\n\n```java\npackage com.yizhu.repository;\n\nimport com.yizhu .entity.User;\nimport org.springframework.data.jpa.repository.EntityGraph;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\n\nimport java.util.List;\n\npublic interface UserRepository extends JpaRepository<User, Long>{\n\n    /**\n     * 根据年龄查询用户信息\n     * @param age\n     * @return\n     */\n    List<User> findAllByAge(Integer age);\n\n    /**\n     * 根据用户性别和所属组织名称查询用户信息\n     * @param userSex\n     * @param orgName\n     * @return\n     */\n    List<User> findBySexAndOrg(@Param(\"sex\") Integer sex, @Param(\"name\") String name);\n\n    /**\n     * 根据用户名模糊查询\n     * @return\n     */\n    List<User> findAllByNameLike(@Param(\"name\") String name);\n}\n```\n\n除了`find` 、`By`、`And`之外，还有一些关键词，全部定义在`PartTree`、`Part`类，组装起来可以生成各种各样的sql，下面截取部分代码，感兴趣的同学可以打开源码去阅读\n\n```java\npackage org.springframework.data.repository.query.parser;\npublic class PartTree implements Streamable<PartTree.OrPart> {\n    private static final String KEYWORD_TEMPLATE = \"(%s)(?=(\\\\p{Lu}|\\\\P{InBASIC_LATIN}))\";\n    private static final String QUERY_PATTERN = \"find|read|get|query|stream\";\n    private static final String COUNT_PATTERN = \"count\";\n    private static final String EXISTS_PATTERN = \"exists\";\n    private static final String DELETE_PATTERN = \"delete|remove\";\n    private static final Pattern PREFIX_TEMPLATE = Pattern.compile(\"^(find|read|get|query|stream|count|exists|delete|remove)((\\\\p{Lu}.*?))??By\");\n    private final PartTree.Subject subject;\n    private final PartTree.Predicate predicate;\n    ...\n    private static String[] split(String text, String keyword) {\n        Pattern pattern = Pattern.compile(String.format(\"(%s)(?=(\\\\p{Lu}|\\\\P{InBASIC_LATIN}))\", keyword));\n        return pattern.split(text);\n    }\n\n    private static class Predicate implements Streamable<PartTree.OrPart> {\n        private static final Pattern ALL_IGNORE_CASE = Pattern.compile(\"AllIgnor(ing|e)Case\");\n        private static final String ORDER_BY = \"OrderBy\";\n        private final List<PartTree.OrPart> nodes;\n        private final OrderBySource orderBySource;\n        private boolean alwaysIgnoreCase;\n\n        public Predicate(String predicate, Class<?> domainClass) {\n            String[] parts = PartTree.split(this.detectAndSetAllIgnoreCase(predicate), \"OrderBy\");\n            if (parts.length > 2) {\n                throw new IllegalArgumentException(\"OrderBy must not be used more than once in a method name!\");\n            } else {\n                this.nodes = (List)Arrays.stream(PartTree.split(parts[0], \"Or\")).filter(StringUtils::hasText).map((part) -> {\n                    return new PartTree.OrPart(part, domainClass, this.alwaysIgnoreCase);\n                }).collect(Collectors.toList());\n                this.orderBySource = parts.length == 2 ? new OrderBySource(parts[1], Optional.of(domainClass)) : OrderBySource.EMPTY;\n            }\n        }\n        ...\n    }\n\n    private static class Subject {\n        private static final String DISTINCT = \"Distinct\";\n        private static final Pattern COUNT_BY_TEMPLATE = Pattern.compile(\"^count(\\\\p{Lu}.*?)??By\");\n        private static final Pattern EXISTS_BY_TEMPLATE = Pattern.compile(\"^(exists)(\\\\p{Lu}.*?)??By\");\n        private static final Pattern DELETE_BY_TEMPLATE = Pattern.compile(\"^(delete|remove)(\\\\p{Lu}.*?)??By\");\n        private static final String LIMITING_QUERY_PATTERN = \"(First|Top)(\\\\d*)?\";\n        private static final Pattern LIMITED_QUERY_TEMPLATE = Pattern.compile(\"^(find|read|get|query|stream)(Distinct)?(First|Top)(\\\\d*)?(\\\\p{Lu}.*?)??By\");\n        private final boolean distinct;\n        private final boolean count;\n        private final boolean exists;\n        private final boolean delete;\n        private final Optional<Integer> maxResults;\n\n        public Subject(Optional<String> subject) {\n            this.distinct = (Boolean)subject.map((it) -> {\n                return it.contains(\"Distinct\");\n            }).orElse(false);\n            this.count = this.matches(subject, COUNT_BY_TEMPLATE);\n            this.exists = this.matches(subject, EXISTS_BY_TEMPLATE);\n            this.delete = this.matches(subject, DELETE_BY_TEMPLATE);\n            this.maxResults = this.returnMaxResultsIfFirstKSubjectOrNull(subject);\n        }\n\n        private Optional<Integer> returnMaxResultsIfFirstKSubjectOrNull(Optional<String> subject) {\n            return subject.map((it) -> {\n                Matcher grp = LIMITED_QUERY_TEMPLATE.matcher(it);\n                return !grp.find() ? null : StringUtils.hasText(grp.group(4)) ? Integer.valueOf(grp.group(4)) : 1;\n            });\n        }\n\t\t...\n\n        private boolean matches(Optional<String> subject, Pattern pattern) {\n            return (Boolean)subject.map((it) -> {\n                return pattern.matcher(it).find();\n            }).orElse(false);\n        }\n    }\n}\n```\n\n```java\npackage org.springframework.data.repository.query.parser;\npublic class Part {\n    private static final Pattern IGNORE_CASE = Pattern.compile(\"Ignor(ing|e)Case\");\n    private final PropertyPath propertyPath;\n    private final Part.Type type;\n    private Part.IgnoreCaseType ignoreCase;\n\t...\n    public static enum Type {\n        BETWEEN(2, new String[]{\"IsBetween\", \"Between\"}),\n        IS_NOT_NULL(0, new String[]{\"IsNotNull\", \"NotNull\"}),\n        IS_NULL(0, new String[]{\"IsNull\", \"Null\"}),\n        LESS_THAN(new String[]{\"IsLessThan\", \"LessThan\"}),\n        LESS_THAN_EQUAL(new String[]{\"IsLessThanEqual\", \"LessThanEqual\"}),\n        GREATER_THAN(new String[]{\"IsGreaterThan\", \"GreaterThan\"}),\n        GREATER_THAN_EQUAL(new String[]{\"IsGreaterThanEqual\", \"GreaterThanEqual\"}),\n        BEFORE(new String[]{\"IsBefore\", \"Before\"}),\n        AFTER(new String[]{\"IsAfter\", \"After\"}),\n        NOT_LIKE(new String[]{\"IsNotLike\", \"NotLike\"}),\n        LIKE(new String[]{\"IsLike\", \"Like\"}),\n        STARTING_WITH(new String[]{\"IsStartingWith\", \"StartingWith\", \"StartsWith\"}),\n        ENDING_WITH(new String[]{\"IsEndingWith\", \"EndingWith\", \"EndsWith\"}),\n        IS_NOT_EMPTY(0, new String[]{\"IsNotEmpty\", \"NotEmpty\"}),\n        IS_EMPTY(0, new String[]{\"IsEmpty\", \"Empty\"}),\n        NOT_CONTAINING(new String[]{\"IsNotContaining\", \"NotContaining\", \"NotContains\"}),\n        CONTAINING(new String[]{\"IsContaining\", \"Containing\", \"Contains\"}),\n        NOT_IN(new String[]{\"IsNotIn\", \"NotIn\"}),\n        IN(new String[]{\"IsIn\", \"In\"}),\n        NEAR(new String[]{\"IsNear\", \"Near\"}),\n        WITHIN(new String[]{\"IsWithin\", \"Within\"}),\n        REGEX(new String[]{\"MatchesRegex\", \"Matches\", \"Regex\"}),\n        EXISTS(0, new String[]{\"Exists\"}),\n        TRUE(0, new String[]{\"IsTrue\", \"True\"}),\n        FALSE(0, new String[]{\"IsFalse\", \"False\"}),\n        NEGATING_SIMPLE_PROPERTY(new String[]{\"IsNot\", \"Not\"}),\n        SIMPLE_PROPERTY(new String[]{\"Is\", \"Equals\"});\n\n        private static final List<Part.Type> ALL = Arrays.asList(IS_NOT_NULL, IS_NULL, BETWEEN, LESS_THAN, LESS_THAN_EQUAL, GREATER_THAN, GREATER_THAN_EQUAL, BEFORE, AFTER, NOT_LIKE, LIKE, STARTING_WITH, ENDING_WITH, IS_NOT_EMPTY, IS_EMPTY, NOT_CONTAINING, CONTAINING, NOT_IN, IN, NEAR, WITHIN, REGEX, EXISTS, TRUE, FALSE, NEGATING_SIMPLE_PROPERTY, SIMPLE_PROPERTY);\n        public static final Collection<String> ALL_KEYWORDS;\n        private final List<String> keywords;\n        private final int numberOfArguments;\n\t\t...\n        static {\n            List<String> allKeywords = new ArrayList();\n            Iterator var1 = ALL.iterator();\n\n            while(var1.hasNext()) {\n                Part.Type type = (Part.Type)var1.next();\n                allKeywords.addAll(type.keywords);\n            }\n\n            ALL_KEYWORDS = Collections.unmodifiableList(allKeywords);\n        }\n    }\n}\n```\n\n可以看到单表操作的大部分需求jpa都为我们提供了现成的实现，但也支持我们使用`@Query`注解自定义查询sql，方便有sql基础的同学使用，sql可控性强。\n\n```java\npackage com.yizhu.repository;\n\nimport com.yizhu .entity.User;\nimport org.springframework.data.jpa.repository.EntityGraph;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\n\nimport java.util.List;\n\npublic interface UserRepository extends JpaRepository<User, Long>{\n\n    /**\n     * 查询所有用户信息\n     * @return\n     */\n    @Query(value = \"from User u\")\n    List<User> findAll();\n\n    /**\n     * 根据年龄查询用户信息\n     * @param age\n     * @return\n     */\n    @Query(value = \"select * from t_user u where u.user_age = ?1\", nativeQuery = true)\n    List<User> findAllByAge(Integer age);\n\n    /**\n     * 根据用户性别和所属组织名称查询用户信息\n     * @param userSex\n     * @param orgName\n     * @return\n     */\n    @Query(value = \"select u from User u left join u.org o where u.userSex = :userSex and o.orgName = :orgName\")\n    List<User> findUsersBySexAndOrg(@Param(\"userSex\") Integer userSex, @Param(\"orgName\") String orgName);\n\n}\n```\n\n### 多表关联\n\n`@OneToOne`、`@OneToMany`、`@ManyToOne`、`@ManyToMany`\n\n```java\n@Entity\n@Table(name = \"t_user\")\n@NamedEntityGraph(name = \"User.findUsers\", attributeNodes = {@NamedAttributeNode(\"jobs\"), @NamedAttributeNode(\"roles\")})\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    @ApiModelProperty(hidden = true)\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @ApiModelProperty(value = \"用户名\")\n    @Column(name = \"user_name\")\n    private String name;\n\n    @ApiModelProperty(value = \"用户密码\")\n    @Column(name = \"user_password\")\n    private String password;\n\n    @ApiModelProperty(value = \"用户年龄\")\n    @Column(name = \"user_age\")\n    private Integer age;\n\n    @ApiModelProperty(value = \"用户性别\")\n    @Column(name = \"user_sex\")\n    private Integer sex;\n\n    @ApiModelProperty(value = \"所属组织id\")\n    @Column(name = \"org_id\")\n    private Long orgId;\n\n    @ApiModelProperty(value = \"用户信息\")\n    @OneToOne\n    @JoinColumn(name = \"id\", updatable = false, insertable = false)\n    private UserInfo userInfo;\n\n    @ApiModelProperty(value = \"用户所属组织\")\n    @ManyToOne\n    @JoinColumn(name = \"org_id\", updatable = false, insertable = false)\n    private Organization org;\n\n    @ApiModelProperty(value = \"用户角色\")\n    @OneToMany\n    @JoinColumn(name = \"user_id\", referencedColumnName = \"id\", insertable = false, updatable = false)\n    @NotFound(action = NotFoundAction.IGNORE)\n    private Set<Role> roles;\n\n    @ApiModelProperty(value = \"用户工作\")\n    @ManyToMany\n    @JoinTable(\n            name = \"t_user_job\",\n            joinColumns = @JoinColumn(name = \"user_id\", referencedColumnName = \"id\"),\n            inverseJoinColumns = @JoinColumn(name = \"job_id\", referencedColumnName = \"id\")\n    )\n    @NotFound(action = NotFoundAction.IGNORE)\n    private Set<Job> jobs;\n```\n\n> `private Set<Role> roles;`和`private Set<Job> jobs;`不能用同时使用`List`集合代替，会报错`org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags: [com.yizhu.entity.User.jobs, com.yizhu.entity.User.roles]`\n\n### 动态查询\n\n```java\npackage com.yizhu.repository;\n\nimport com.yizhu.dto.UserQueryDto;\nimport com.yizhu.entity.Organization;\nimport com.yizhu.entity.User;\nimport org.springframework.data.jpa.domain.Specification;\n\nimport javax.persistence.criteria.Join;\nimport javax.persistence.criteria.JoinType;\nimport javax.persistence.criteria.Predicate;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\npublic class UserSpecs {\n\n    public static Specification<User> listQuerySpec(UserQueryDto userQueryDto){\n        return (root, query, builder) -> {\n            List<Predicate> predicates = new ArrayList<>();\n\n            Optional.ofNullable(userQueryDto.getId()).ifPresent(i -> predicates.add(builder.equal(root.get(\"id\"), i)));\n            Optional.ofNullable(userQueryDto.getName()).ifPresent(n -> predicates.add(builder.equal(root.get(\"name\"), n)));\n            Optional.ofNullable(userQueryDto.getAge()).ifPresent(a -> predicates.add(builder.equal(root.get(\"age\"), a)));\n            Optional.ofNullable(userQueryDto.getOrgId()).ifPresent(oi -> predicates.add(builder.equal(root.get(\"orgId\"), oi)));\n            Optional.ofNullable(userQueryDto.getOrgName()).ifPresent(on -> {\n                Join<User, Organization> userJoin = root.join(root.getModel().getSingularAttribute(\"org\", Organization.class), JoinType.LEFT);\n                predicates.add(builder.equal(userJoin.get(\"orgName\"), on));\n            });\n\n            return builder.and(predicates.toArray(new Predicate[predicates.size()]));\n        };\n    }\n}\n```\n\n```java\npackage com.yizhu.service;\n\nimport com.yizhu.dto.UserQueryDto;\nimport com.yizhu.entity.User;\nimport com.yizhu.repository.UserRepository;\nimport com.yizhu.repository.UserSpecs;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service\npublic class UserService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    public List<User> findUsersDynamic(UserQueryDto userQueryDto){\n        return userRepository.findAll(UserSpecs.listQuerySpec(userQueryDto));\n    }\n}\n```\n\n\n\n### 审计功能使用\n\n在启动类添加`@EnableJpaAuditing`注解表示开启jpa审计功能\n\n```java\npackage com.yizhu;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.data.jpa.repository.config.EnableJpaAuditing;\n\n@EnableJpaAuditing\n@SpringBootApplication\npublic class DemoApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DemoApplication.class, args);\n\t}\n}\n```\n\n在需要使用审计功能的实体类添加`@EntityListeners(AuditingEntityListener.class)`注解\n\n```java\npackage com.yizhu.entity;\n\nimport lombok.Builder;\nimport lombok.Data;\nimport org.springframework.data.jpa.domain.support.AuditingEntityListener;\n\nimport javax.persistence.*;\nimport java.io.Serializable;\nimport java.util.Date;\n\n@Entity\n@Table(name = \"t_role\")\n@Data\n@Builder\n@EntityListeners(AuditingEntityListener.class)\npublic class Role implements Serializable {\n    private static final long serialVersionUID=1L;\n\n    @ApiModelProperty(hidden = true)\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n\n    private String roleName;\n\n    @CreatedDate\n    private Date createTime;\n    \n\t@CreatedBy\n    private Long createId;\n    \n    @LastModifiedDate\n    private Date updateTime;\n    \n\t@LastModifiedBy\n    private Long updateId;\n}\n```\n\n实现AuditorAware接口，告诉容器当前登录人id\n\n```java\npackage com.yizhu.configuration;\n\nimport org.springframework.data.domain.AuditorAware;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport java.util.Optional;\n\npublic class UserAuditorAwareImpl implements AuditorAware<Long> {\n    @Override\n    public Optional<Long> getCurrentAuditor() {\n        // 从session中获取登录人id\n        ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        Long userId = (Long)servletRequestAttributes.getRequest().getSession().getAttribute(\"userId\");\n        return Optional.of(userId);\n    }\n}\n```\n\nok，然后jpa就会根据`ID`和`Version`判断当前操作是更新还是新增数据，新增时会注入当前登录人id到标有`@CreateBy`注解的字段上，当前时间注入到标有`@CreateTime`注解字段上；更新时则注入到`@LastModifiedBy`和`@LastModifiedDate`对应的字段上。想详细了解的可查看`org.springframework.data.jpa.domain.support.AuditingEntityListener`源码。\n\n## 常见的坑\n\n- N+1问题，当使用`@ManyToMany`、`@ManyToOne`、`@OneToMany`、`@OneToOne`关联\n  关系的时候，FetchType怎么配置LAZY或者EAGER。SQL真正执行的时\n  候是由一条主表查询和N条子表查询组成的。这种查询效率一般比较\n  低下，比如子对象有N个就会执行N+1条SQL。使用JPA 2.1推出来的@EntityGraph、@NamedEntityGraph可以解决该问题。如下。\n\n```java\n@ApiModel\n@Entity\n@Table(name = \"t_user\")\n@NamedEntityGraph(name = \"User.findUsers\", attributeNodes = {@NamedAttributeNode(\"jobs\"), @NamedAttributeNode(\"roles\")})\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    @ApiModelProperty(hidden = true)\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    // 省略其他属性\n}\n```\n\n```java\npackage com.yizhu.repository;\n\nimport com.yizhu.entity.User;\nimport org.springframework.data.jpa.repository.EntityGraph;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport java.util.List;\n\npublic interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {\n\n    /**\n     * 根据id查询用户信息\n     * @param id\n     * @return\n     */\n    @EntityGraph(value = \"User.findUsers\", type = EntityGraph.EntityGraphType.FETCH)\n    User findAllById(Long id);\n\n    /**\n     * 根据name查询用户信息\n     * @param name\n     * @return\n     */\n    @EntityGraph(value = \"User.findUsers\", type = EntityGraph.EntityGraphType.FETCH)\n    @Query(value = \"select * from t_user where user_name = :name\", nativeQuery = true)\n    List<User> findAllByUserName(@Param(\"name\") String name);\n}\n```\n\n\n\n- 所有的注解要么全配置在字段上，要么全配置在get方法上，不能混用，混用就会启动不起来，但是语法配置没有问题。\n- 所有的关联都是支持单向关联和双向关联的，视具体业务场景而定。JSON序列化的时候使用双向注解会产生死循环，需要人为手动转化一次，或者使用@JsonIgnore。\n- 在所有的关联查询中，表一般是不需要建立外键索引的。@mappedBy的使用需要注意。\n- 级联删除比较危险，建议考虑清楚，或者完全掌握。\n- 不同的关联关系的配置，@JoinClumn里面的name、referencedColumnName代表的意思是不一样的，很容易弄混，可以根据打印出来的SQL做调整。\n- 当配置这些关联关系的时候建议大家直接在表上面，把外键建好，然后通过后面我们介绍的开发工具直接生成，这样可以减少自己调试的时间。\n\n## JPA常用注解\n\n摘自《Spring Data JPA从入门到精通》\n\n![1554619508054](spring-data-jpa-summary\\1554619508054.png)\n\n![1554619555135](spring-data-jpa-summary\\1554619555135.png)\n\n![1554619583326](spring-data-jpa-summary\\1554619583326.png)\n\n![1554619600777](spring-data-jpa-summary\\1554619600777.png)\n\n![1554619615592](spring-data-jpa-summary\\1554619615592.png)\n\n![1554619631450](spring-data-jpa-summary\\1554619631450.png)\n\n![1554620031094](spring-data-jpa-summary\\1554620031094.png)\n\n![1554620213902](spring-data-jpa-summary\\1554620213902.png)\n\n![1554620262086](spring-data-jpa-summary\\1554620262086.png)","tags":["orm"],"categories":["总结"]},{"title":"Kafka学习和总结","url":"/2019/03/17/kafka-learn-and-summary/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](kafka-learn-and-summary/p2.jpg)\n\n> 资源列表：\n>\n> 1. 官方网站：http://kafka.apache.org/\n\n## kafka简介\n\nkafka是一款开源的、轻量级的、分布式、可分区和具有复制备份的、基于Zookeeper协调管理的分布式流平台的功能抢到的消息系统\n\n## 组成及概念\n\n1. **主题（topic）**：Kafka将一组消息抽象归纳为一个主题\n2. **消息（message/record）**：消息是Kafka的基本单位，有一个固定长度的消息头和一个可变长度的消息体构成\n3. **分区和副本（partition）**：Kafka将一组消息抽象归纳为一个主题，每个主题又被分成一个或多个分区，每个分区有一些列有序、不可变的消息组成，是一个有序队列。分区也是保证消息被顺序消费以及对消息进行负载均衡的基础。但Kafka只能保证一个分区之内消息的有序性，并不能保证跨分区消息的有序性。每条消息被追加到相应的分区中，是顺序写磁盘，因此效率非常高，这是Kafka高吞吐量的一个保证\n4. **leader副本和follower副本**：由于Kafka副本的存在，就需要保证一个分区的多个副本之间数据一致性，kafka会选择该分区的一个副本作为leader副本，其他副本作为follower副本，只有leader副本才负责处理客户端的读/写请求，follower副本从leader副本同步数据\n5. **偏移量（offset）**：任何发布到分区的消息会被直接追加到日志文件的尾部，而每条消息在日志文件中的位置都会对应一个按序递增的偏移量。\n6. **日志段（logSegment）**：一个日志被划分为多个日志段，日志段是kafka日志对象的最小单位\n7. **代理（borker）**：每一个kafka实例都是一个代理，每个代理都有唯一的标识id，可以通过broker.id配置\n8. **生产者（producer）**：生产者负责将消息发送给代理\n9. **消费者和消费组（comsumer）**：消费者以拉取的方式拉取数据，是消费的客户端。同一个主题的一条消息只能被同一个消费组的某一个消费者消费，但不同消费组的消费者可以同时消费该消息。实现消息广播只需指定各消费者属于不同消费组，消息单播则只需让消费者属于同一个消费组\n10. **ISR（In-sync Replica）**：用于保存同步的副本列表，该列表保存的是与leader副本保持消息同步的所有副本对应的节点的id，如果一个follower副本宕机或落后太多，则该follower副本节点将从ISR列表移除\n\n![](kafka-learn-and-summary/kafka.png)\n\n## 特性\n\n1. **消息持久化**：kafka将数据持久化到磁盘上，这样只要磁盘空间足够大，就可以一直追加。这就是的kafka在重启后已存储的消息可恢复使用。\n2. **高吞吐量**：充分利用磁盘的顺序读写，同时kafka在数据写入及数据同步采用了零拷贝技术，内核中操作，避免了内核缓冲区与用户缓冲区之间数据的拷贝\n3. **扩展性**：kafka依赖zk对集群进行协调管理，是的kafka容易水平扩展\n4. **多客户端支持**：支持Java、Scala、C、C++、Python、Go、Erlang、Ruby、Node.js等语言API，支持多种连接器的接入，与大数据框架Flume、Hadoop、HBase、Hive、Spark、Storm很好集成\n5. **Stream类库**：java语言实现的流处理jar\n6. **安全机制**：身份认证、通信数据加密、权限认证、授权服务\n7. **数据备份**：主从副本备份，一定程度防止丢失，提高可用性\n8. **轻量级**：无状态的\n9. **消息压缩**：支持GZip、Snappy、LZ4压缩\n\n## 应用场景\n\n消息系统、应用监控、流处理、持久性日志\n\n## 简单实践\n\n### 知名案例\n\n## 与其他mq对比\n\n\n\n","tags":["kafka"],"categories":["总结"]},{"title":"推荐书单整理","url":"/2019/03/10/list-books/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![books](list-books/books.jpg)\n\n在21世纪这个碎片化阅读的时代，阅读每时每刻都在进行，系统的书籍阅读越来越不受重视，但是系统完整的阅读一本专业书籍对于构建一个完整的知识体系而言更有帮助，而且能出版并有一定销量的书籍都是有一定参考价值的，这是碎片阅读不能比拟的，所以就有了整理一份书单的想法，收录各路大牛推荐的技术及世界名著，发现好的书籍我会不断更新，欢迎监督及推荐书籍。\n\n> 备注：排名不分先后\n>\n> 参考：https://github.com/jobbole/awesome-programming-books\n\n## 技术书\n\n### 计算机系统与网络\n\n- 《[图灵的秘密:他的生平、思想及论文解读](https://www.amazon.cn/gp/product/B00AAQXKXS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00AAQXKXS&linkCode=as2&tag=vastwork-23)》\n- 《[计算机系统概论](https://www.amazon.cn/gp/product/B0011F9OQE/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0011F9OQE&linkCode=as2&tag=vastwork-23)》\n- 《[深入理解Linux内核](https://www.amazon.cn/gp/product/B0011F5RYM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0011F5RYM&linkCode=as2&tag=vastwork-23)》\n- 《[深入Linux内核架构](https://www.amazon.cn/gp/product/B003QN7J7U/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B003QN7J7U&linkCode=as2&tag=vastwork-23)》\n- 《[TCP/IP详解 卷1：协议](https://www.amazon.cn/gp/product/B00116OTVS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00116OTVS&linkCode=as2&tag=vastwork-23)》\n- 《[Linux系统编程（第2版）](https://www.amazon.cn/gp/product/B00JUM2ML4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00JUM2ML4&linkCode=as2&tag=vastwork-23)》\n- 《[Linux内核设计与实现（第3版）](https://www.amazon.cn/gp/product/B004X3Z3D4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004X3Z3D4&linkCode=as2&tag=vastwork-23)》\n- 《[深入理解计算机系统（原书第3版）](https://amazon.cn/gp/product/B01N03IQK4/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=vastwork-23&creative=3200&linkCode=as2&creativeASIN=B01N03IQK4&linkId=b87deba0291c05df8d8ea0d64fefb0f0)》\n- 《[计算机程序的构造和解释（原书第2版）](https://www.amazon.cn/gp/product/B0011AP7RY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0011AP7RY&linkCode=as2&tag=vastwork-23)》\n- 《[编码：隐匿在计算机软硬件背后的语言](https://www.amazon.cn/gp/product/B009RSXIB4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009RSXIB4&linkCode=as2&tag=vastwork-23)》\n- 《[性能之颠：洞悉系统、企业与云计算](https://www.amazon.cn/gp/product/B0140I5WPK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0140I5WPK&linkCode=as2&tag=vastwork-23)》\n- 《[UNIX网络编程 卷1：套接字联网API（第3版）](https://www.amazon.cn/gp/product/B011S72JB6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B011S72JB6&linkCode=as2&tag=vastwork-23)》\n- 《[UNIX网络编程 卷2：进程间通信](https://www.amazon.cn/gp/product/B012R5A29O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B012R5A29O&linkCode=as2&tag=vastwork-23)》\n- 《[Windows核心编程(第5版)](https://www.amazon.cn/gp/product/B001GS7918/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B001GS7918&linkCode=as2&tag=vastwork-23)》\n- 《[WireShark网络分析就这么简单](https://www.amazon.cn/gp/product/B00PB5QQ84/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00PB5QQ84&linkCode=as2&tag=vastwork-23)》\n- 《[WireShark网络分析的艺术](https://www.amazon.cn/gp/product/B01AS1OS8A/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01AS1OS8A&linkCode=as2&tag=vastwork-23)》\n\n编程通用\n\n- 《[设计原本](https://www.amazon.cn/dp/B00CD1EWMG/ref=sr_1_1?ie=UTF8&qid=1514903810&sr=8-1)》\n- 《[编程原本](https://www.amazon.cn/gp/product/B006P7V73G/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B006P7V73G&linkCode=as2&tag=vastwork-23)》\n- 《[代码大全](https://www.amazon.cn/gp/product/B0061XKRXA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0061XKRXA&linkCode=as2&tag=vastwork-23)》\n- 《[UNIX编程艺术](https://www.amazon.cn/gp/product/B008Z1IEQ8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008Z1IEQ8&linkCode=as2&tag=vastwork-23)》\n- 《[代码整洁之道](https://www.amazon.cn/gp/product/B0031M9GHC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0031M9GHC&linkCode=as2&tag=vastwork-23)》\n- 《[编程珠玑（第2版）](https://www.amazon.cn/gp/product/B00SFZH0DC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00SFZH0DC&linkCode=as2&tag=vastwork-23)》\n- 《[编程珠玑（续）](https://www.amazon.cn/gp/product/B0150BMQDM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0150BMQDM&linkCode=as2&tag=vastwork-23)》\n- 《[软件调试的艺术](https://www.amazon.cn/gp/product/B00IOAM6VE/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00IOAM6VE&linkCode=as2&tag=vastwork-23)》\n- 《[修改代码的艺术](https://www.amazon.cn/gp/product/B00KMJ2Q1U/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00KMJ2Q1U&linkCode=as2&tag=vastwork-23)》\n- 《[编程语言实现模式](https://www.amazon.cn/gp/product/B007HYMPBY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B007HYMPBY&linkCode=as2&tag=vastwork-23)》\n- 《[编写可读代码的艺术](https://www.amazon.cn/gp/product/B008B4DTG4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008B4DTG4&linkCode=as2&tag=vastwork-23)》\n- 《解析极限编程：拥抱变化》\n- 《[精通正则表达式（第3版）](https://www.amazon.cn/gp/product/B008UCHA58/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008UCHA58&linkCode=as2&tag=vastwork-23)》\n- 《[编译原理（第2版）](https://www.amazon.cn/gp/product/B001NGO85I/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B001NGO85I&linkCode=as2&tag=vastwork-23)》龙书\n- 《[重构：改善既有代码的设计](https://www.amazon.cn/gp/product/B011LPUB42/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B011LPUB42&linkCode=as2&tag=vastwork-23)》\n- 《[七周七语言：理解多种编程范型](https://www.amazon.cn/gp/product/B00ALPRM3M/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ALPRM3M&linkCode=as2&tag=vastwork-23)》\n- 《[调试九法：软硬件错误的排查之道](https://www.amazon.cn/gp/product/B00CBBLUFK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00CBBLUFK&linkCode=as2&tag=vastwork-23)》\n- 《程序设计语言：实践之路（第3版）》\n- 《[计算的本质：深入剖析程序和计算机](https://www.amazon.cn/gp/product/B00PG0MM3C/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00PG0MM3C&linkCode=as2&tag=vastwork-23)》\n- 《[设计模式 : 可复用面向对象软件的基础](https://www.amazon.cn/gp/product/B001130JN8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B001130JN8&linkCode=as2&tag=vastwork-23)》\n- 《[Head First 设计模式（中文版）](https://amazon.cn/gp/product/B0011FBU34/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=vastwork-23&creative=3200&linkCode=as2&creativeASIN=B0011FBU34&linkId=cd5d20e99ff289529d6dbe2cd223f2b6) 》\n- 《设计模式之禅（第2版）》\n\n### 算法与数据结构\n\n- 《[算法（第4版）](https://www.amazon.cn/gp/product/B009OCFQ0O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OCFQ0O&linkCode=as2&tag=vastwork-23)》\n- 《[算法导论（原书第2版）](https://www.amazon.cn/gp/product/B00AK7BYJY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00AK7BYJY&linkCode=as2&tag=vastwork-23)》\n- 《[Python算法教程](https://www.amazon.cn/gp/product/B019NB0VCI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B019NB0VCI&linkCode=as2&tag=vastwork-23)》\n- 《[算法设计与分析基础（第3版）](https://www.amazon.cn/gp/product/B00S4HCQUI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00S4HCQUI&linkCode=as2&tag=vastwork-23)》\n- 《[学习 JavaScript 数据结构与算法](https://www.amazon.cn/gp/product/B016DWSF8M/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B016DWSF8M&linkCode=as2&tag=vastwork-23)》\n- 《[数据结构与算法分析 : C++描述（第4版）](https://www.amazon.cn/gp/product/B01LDG2DSG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01LDG2DSG&linkCode=as2&tag=vastwork-23)》\n- 《[数据结构与算法分析 : C语言描述（第2版）](https://www.amazon.cn/gp/product/B002WC7NGS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B002WC7NGS&linkCode=as2&tag=vastwork-23)》\n- 《[数据结构与算法分析 : Java语言描述（第2版）](https://www.amazon.cn/gp/product/B01CNP0CG6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01CNP0CG6&linkCode=as2&tag=vastwork-23)》\n\n### 职业修炼与规划\n\n- 《[大教堂与集市](https://www.amazon.cn/gp/product/B00KQDTZ4S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00KQDTZ4S&linkCode=as2&tag=vastwork-23)》\n- 《卓有成效的程序员》\n- 《[程序员的职业素养](https://www.amazon.cn/gp/product/B01LZJ8L9J/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01LZJ8L9J&linkCode=as2&tag=vastwork-23)》\n- 《[程序员修炼之道：从小工到专家](https://www.amazon.cn/gp/product/B004GV08CY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004GV08CY&linkCode=as2&tag=vastwork-23)》\n- 《[软件开发者路线图：从学徒到高手](https://www.amazon.cn/gp/product/B00H6X6LD4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00H6X6LD4&linkCode=as2&tag=vastwork-23)》\n- 《[我编程，我快乐: 程序员职业规划之道](https://www.amazon.cn/gp/product/B00CBBKDGM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00CBBKDGM&linkCode=as2&tag=vastwork-23)》\n- 《[程序员的思维修炼：开发认知潜能的九堂课](https://www.amazon.cn/gp/product/B007VARUIM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B007VARUIM&linkCode=as2&tag=vastwork-23)》\n- 《[高效程序员的45个习惯：敏捷开发修炼之道(修订版)](https://www.amazon.cn/gp/product/B00OA9L3NU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00OA9L3NU&linkCode=as2&tag=vastwork-23)》\n\n### 大师访谈\n\n- 《[编程大师智慧](https://www.amazon.cn/gp/product/B00451BP72/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00451BP72&linkCode=as2&tag=vastwork-23)》\n- 《[编程大师访谈录](https://www.amazon.cn/gp/product/B00ALPRKMA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ALPRKMA&linkCode=as2&tag=vastwork-23)》\n- 《[编程人生 : 15位软件先驱访谈录](https://www.amazon.cn/gp/product/B00QA7GA2Y/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00QA7GA2Y&linkCode=as2&tag=vastwork-23)》\n- 《[奇思妙想 : 15位计算机天才及其重大发现](https://www.amazon.cn/gp/product/B007ED88CI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B007ED88CI&linkCode=as2&tag=vastwork-23)》\n- 《[图灵和ACM图灵奖](https://www.amazon.cn/gp/product/B008G80O9K/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008G80O9K&linkCode=as2&tag=vastwork-23)》\n\n### 架构/性能\n\n- 《[架构即未来](https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B01DXW29IM/ref=sr_1_1?s=books&ie=UTF8&qid=1496288348&sr=1-1)》\n- 《[微服务设计](https://www.amazon.cn/gp/product/B01ER75V6O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01ER75V6O&linkCode=as2&tag=vastwork-23)》\n- 《[大数据日知录](https://www.amazon.cn/gp/product/B00NGW4EAG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00NGW4EAG&linkCode=as2&tag=vastwork-23)》\n- 《[企业应用架构模式](https://www.amazon.cn/gp/product/B003LBSRDM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B003LBSRDM&linkCode=as2&tag=vastwork-23)》\n- 《[Web性能权威指南](https://www.amazon.cn/gp/product/B00JMKWHFU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00JMKWHFU&linkCode=as2&tag=vastwork-23)》\n- 《[SRE：Google运维解密](https://www.amazon.cn/gp/product/B01M0EHQ43/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01M0EHQ43&linkCode=as2&tag=vastwork-23)》\n- 《[发布！软件的设计与部署](https://www.amazon.cn/gp/product/B0153178XM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0153178XM&linkCode=as2&tag=vastwork-23)》\n- 《[高扩展性网站的 50 条原则](https://www.amazon.cn/gp/product/B01HZFHQQI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01HZFHQQI&linkCode=as2&tag=vastwork-23)》\n- 《[大型网站技术架构:核心原理与案例分析](https://www.amazon.cn/gp/product/B00F3Z26G8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00F3Z26G8&linkCode=as2&tag=vastwork-23)》\n- 《[恰如其分的软件架构：风险驱动的设计方法](https://www.amazon.cn/gp/product/B00EP6TGAU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00EP6TGAU&linkCode=as2&tag=vastwork-23)》\n- 《[软件系统架构：使用视点和视角与利益相关者合作（第2版）](https://www.amazon.cn/gp/product/B00CMMUXC4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00CMMUXC4&linkCode=as2&tag=vastwork-23)》\n\n### Linux / Unix\n\n- 《[Linux/Unix 系统编程手册](https://amazon.cn/gp/product/B00HLA8TYG/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=vastwork-23&creative=3200&linkCode=as2&creativeASIN=B00HLA8TYG&linkId=2d246600ae289155a09ec47545d584f6)》（感谢[@geekgao](https://github.com/geekgao) 的推荐）\n- 《[Unix 环境高级编程(第3版)](https://amazon.cn/gp/product/B00KMR129E/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=vastwork-23&creative=3200&linkCode=as2&creativeASIN=B00KMR129E&linkId=9655c290f9d97c4d7e80093839cc5944)》\n- 《Unix/Linux 编程实践教程》\n- 《[鸟哥的 Linux 私房菜（基础学习篇）](https://amazon.cn/gp/product/B003TJNO98/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=vastwork-23&creative=3200&linkCode=as2&creativeASIN=B003TJNO98&linkId=dda37757175b431dedc5e20212021f21)》和《[鸟哥的 Linux 私房菜（服务器架设篇）](https://amazon.cn/gp/product/B008AEI8A2/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=vastwork-23&creative=3200&linkCode=as2&creativeASIN=B008AEI8A2&linkId=35f878fbebb2f66ae8c4fc3e76914ff6)》\n- 《[Linux 命令行与 shell 脚本编程大全（第3版）](https://amazon.cn/gp/product/B0719GT5W1/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=vastwork-23&creative=3200&linkCode=as2&creativeASIN=B0719GT5W1&linkId=aeef8bc8651bd9e5f363527b86d1229a)》\n- 《[只是为了好玩 : Linux 之父林纳斯自传](https://amazon.cn/gp/product/B00MB51SAI/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=vastwork-23&creative=3200&linkCode=as2&creativeASIN=B00MB51SAI&linkId=b22fe2eaac93168eae25d9bab11fe30c)》\n\n### Web前端\n\n- 《[高性能 JavaScript](https://www.amazon.cn/gp/product/B013SGB2AO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B013SGB2AO&linkCode=as2&tag=vastwork-23)》\n- 《[锋利的 jQuery（第2版）](https://www.amazon.cn/gp/product/B0089TDFNS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0089TDFNS&linkCode=as2&tag=vastwork-23)》\n- 《[JavaScript 忍者秘籍](https://www.amazon.cn/gp/product/B016DWSEWO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B016DWSEWO&linkCode=as2&tag=vastwork-23)》\n- 《[编写可维护的 JavaScript](https://www.amazon.cn/gp/product/B00BQ7RMW0/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00BQ7RMW0&linkCode=as2&tag=vastwork-23)》\n- 《[你不知道的 JavaScript（上）](https://www.amazon.cn/gp/product/B00W34DZ8K/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00W34DZ8K&linkCode=as2&tag=vastwork-23)》\n- 《[你不知道的 JavaScript（中）](https://www.amazon.cn/gp/product/B01LMYXGAI/ref=pd_sim_14_1?ie=UTF8&psc=1&refRID=4JRMK10EFJQHDAG8MCZF)》\n- 《[JavaScript 权威指南（第6版）](https://www.amazon.cn/gp/product/B007VISQ1Y/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B007VISQ1Y&linkCode=as2&tag=vastwork-23)》\n- 《[JavaScript 语言精粹（修订版）](https://www.amazon.cn/gp/product/B0097CON2S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0097CON2S&linkCode=as2&tag=vastwork-23)》\n- 《[JavaScript DOM编程艺术 （第2版）](https://www.amazon.cn/gp/product/B004VJM5KE/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004VJM5KE&linkCode=as2&tag=vastwork-23)》\n- 《[JavaScript 高级程序设计（第3版）](https://www.amazon.cn/gp/product/B007OQQVMY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B007OQQVMY&linkCode=as2&tag=vastwork-23)》\n- 《[JavaScript 异步编程：设计快速响应的网络应用](https://www.amazon.cn/gp/product/B00JVLEYY2/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00JVLEYY2&linkCode=as2&tag=vastwork-23)》\n- 《[JavaScript设计模式与开发实践](https://www.amazon.cn/gp/product/B00XJ2AU3S/ref=pd_bxgy_14_img_3?ie=UTF8&psc=1&refRID=4JRMK10EFJQHDAG8MCZF)》\n- 《[JavaScript框架设计（第2版）](https://www.amazon.cn/gp/product/B07574N7Y2/ref=pd_sim_14_7?ie=UTF8&psc=1&refRID=W48SJ7HFN2TXAQ1VAA8K)》\n- 《[Effective JavaScript：编写高质量JavaScript代码的68个有效方法](https://www.amazon.cn/gp/product/B00GMXI1QY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00GMXI1QY&linkCode=as2&tag=vastwork-23)》\n- 《[HTML5 权威指南](https://www.amazon.cn/gp/product/B00H706BIG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00H706BIG&linkCode=as2&tag=vastwork-23)》\n- 《[HTML5 秘籍（第2版）](https://www.amazon.cn/gp/product/B015316VJY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B015316VJY&linkCode=as2&tag=vastwork-23)》\n- 《[HTML5 与 CSS3 基础教程（第八版）](https://www.amazon.cn/gp/product/B00K58535O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00K58535O&linkCode=as2&tag=vastwork-23)》\n- 《[CSS 揭秘](https://www.amazon.cn/gp/product/B01ET3FO86/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01ET3FO86&linkCode=as2&tag=vastwork-23)》\n- 《[CSS 设计指南（第3版）](https://www.amazon.cn/gp/product/B00M2DKZ1W/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00M2DKZ1W&linkCode=as2&tag=vastwork-23)》\n- 《[CSS 权威指南（第3版）](https://www.amazon.cn/gp/product/B0011F5SIC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0011F5SIC&linkCode=as2&tag=vastwork-23)》\n- 《[深入浅出 HTML 与 CSS](https://www.amazon.cn/gp/product/B01LXL42O5/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01LXL42O5&linkCode=as2&tag=vastwork-23)》\n- 《[ES6 标准入门（第三版）](https://www.amazon.cn/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8-%E9%98%AE%E4%B8%80%E5%B3%B0/dp/B0755547ZZ/ref=sr_1_3?s=books&ie=UTF8&qid=1510299626&sr=1-3&keywords=Ecmascript)》\n- 《[深入理解 ES6](https://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6-Nicholas-C-Zakas/dp/B071GW3JDP/ref=sr_1_1?s=books&ie=UTF8&qid=1510299626&sr=1-1&keywords=Ecmascript)》\n\n### Java开发\n\n- 《[Java8 实战](https://www.amazon.cn/gp/product/B01ER75QC8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01ER75QC8&linkCode=as2&tag=vastwork-23)》\n- 《[Java并发编程实战](https://www.amazon.cn/gp/product/B0077K9XHW/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0077K9XHW&linkCode=as2&tag=vastwork-23)》\n- 《[Java性能权威指南](https://www.amazon.cn/gp/product/B01DLB7Z66/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01DLB7Z66&linkCode=as2&tag=vastwork-23)》\n- 《[Java程序员修炼之道](https://www.amazon.cn/gp/product/B00E0D2OX4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00E0D2OX4&linkCode=as2&tag=vastwork-23)》\n- 《[实战Java高并发程序设计](https://www.amazon.cn/gp/product/B017MEN094/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B017MEN094&linkCode=as2&tag=vastwork-23)》\n- 《[Java编程思想 （第4版）](https://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0011F7WU4&linkCode=as2&tag=vastwork-23)》\n- 《[深入理解Java虚拟机（第2版）](https://www.amazon.cn/gp/product/B01HI0BUF8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01HI0BUF8&linkCode=as2&tag=vastwork-23)》\n- 《[Effective java 中文版（第2版）](https://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B001PTGR52&linkCode=as2&tag=vastwork-23)》\n- 《[Java核心技术·卷1：基础知识（原书第9版）](https://www.amazon.cn/gp/product/B01M22BGUQ/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01M22BGUQ&linkCode=as2&tag=vastwork-23)》\n- 《[Java核心技术·卷2：高级特性（原书第9版）](https://www.amazon.cn/gp/product/B00IK7SM6O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00IK7SM6O&linkCode=as2&tag=vastwork-23)》\n- 《Java并发编程的艺术》\n- 《Spring源码深度解析》\n\n### .NET/.NET Core\n\n- 《[C# 6.0 本质论](https://www.amazon.cn/C-6-0%E6%9C%AC%E8%B4%A8%E8%AE%BA-%E9%A9%AC%E5%85%8B%C2%B7%E7%B1%B3%E5%87%AF%E5%88%A9%E6%96%AF/dp/B01N7U95UK/ref=sr_1_1?s=books&ie=UTF8&qid=1510299751&sr=1-1&keywords=C%23+%E6%9C%AC%E8%B4%A8%E8%AE%BA)》\n- 《[果壳中的C#：C#5.0权威指南](https://www.amazon.cn/%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84C-C-5-0%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E9%98%BF%E5%9D%9D%E5%93%88%E7%91%9E/dp/B00G51PUDA/ref=sr_1_1?s=books&ie=UTF8&qid=1510299796&sr=1-1&keywords=%E6%9E%9C%E5%A3%B3%E4%B8%AD%E7%9A%84C%23)》\n- 《你必须知道的.NET（第2版）》\n- 《[深入理解C#（第3版）](https://www.amazon.cn/gp/product/B00J94AG2A/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00J94AG2A&linkCode=as2&tag=vastwork-23)》\n- 《Effective C#: 50 Specific Ways to Improve Your C#, Third Edition》\n- 《More Effective C# (Includes Content Update Program): 50 Specific Ways to Improve Your C#, 2nd edition》\n- 《[Async in C# 5.0: Unleash the Power of Async](https://www.amazon.cn/Async-in-C-5-0-Unleash-the-Power-of-Async-Davies-Alex/dp/1449337163/ref=sr_1_1?s=books&ie=UTF8&qid=1510299899&sr=1-1&keywords=Async+in+C%23+5.0)》\n- 《[C#并发编程经典实例](https://www.amazon.cn/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B-%E5%85%8B%E5%88%A9%E9%87%8C/dp/B00QVLZEQ2/ref=sr_1_1?s=books&ie=UTF8&qid=1510299937&sr=1-1&keywords=C%23%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B)》\n- 《[C#多线程编程实战(原书第2版)](https://www.amazon.cn/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E6%98%93%E6%A0%BC%E6%81%A9%C2%B7%E9%98%BF%E6%A0%BC%E4%BD%9B%E6%B8%A9/dp/B06XHXV5FQ/ref=sr_1_1?s=books&ie=UTF8&qid=1510299974&sr=1-1&keywords=C%23%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98)》\n- 《[CLR via C#（第4版）](https://www.amazon.cn/gp/product/B00P8VZ8T4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00P8VZ8T4&linkCode=as2&tag=vastwork-23)》\n- 《.NET本质论 第1卷:公共语言运行库》\n- 《.NET探秘 : MSIL权威指南》\n- 《Pro .NET Performance》\n- 《Shared Source CLI Essentials》\n- 《.NET 高级调试》\n- 《Microsoft.NET 和 Windows 应用程序调试》\n- 《微软.NET 程序的加密与解密》\n- 《[.NET Development Using the Compiler API](https://www.amazon.cn/NET-Development-Using-the-Compiler-API-Bock-Jason/dp/1484221109/ref=sr_1_1?s=books&ie=UTF8&qid=1510300116&sr=1-1&keywords=.NET+Development+Using+the+Compiler+API)》\n- 《.NET设计规范 : 约定、惯用法与模式》\n- 《[编写高性能的.NET代码](https://www.amazon.cn/gp/product/B074JS9HWX/ref=pd_sim_14_9?ie=UTF8&psc=1&refRID=67XZ7GZVFZ3J57NQTJ8X)》\n- 《[Building Microservices with .NET Core](https://www.amazon.cn/Building-Microservices-with-NET-Core-Develop-skills-in-Reactive-Microservices-database-scaling-Azure-Microservices-and-more-Aroraa-Gaurav-Kumar/dp/B01MQ52RM3/ref=sr_1_10?s=books&ie=UTF8&qid=1510300439&sr=1-10&keywords=.net+core)》\n- 《[Microservices in .NET Core, with Examples in NancyFX](https://www.amazon.cn/Microservices-in-NET-Core-with-Examples-in-NancyFX-Horsdal-Christian/dp/1617293377/ref=sr_1_15?s=books&ie=UTF8&qid=1510300439&sr=1-15&keywords=.net+core)》\n\n### Python\n\n- 《[集体智慧编程](https://www.amazon.cn/gp/product/B00UI93JD8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00UI93JD8&linkCode=as2&tag=vastwork-23)》\n- 《[笨办法学Python](https://www.amazon.cn/gp/product/B00P6OJ0TC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00P6OJ0TC&linkCode=as2&tag=vastwork-23)》\n- 《[Python基础教程](https://www.amazon.cn/gp/product/B00KAFX65Q/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00KAFX65Q&linkCode=as2&tag=vastwork-23)》\n- 《Python源码剖析》\n- 《[Head First Python](https://www.amazon.cn/gp/product/B007NB2B4M/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B007NB2B4M&linkCode=as2&tag=vastwork-23)》\n- 《[与孩子一起学编程](https://www.amazon.cn/gp/product/B00HECW20S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00HECW20S&linkCode=as2&tag=vastwork-23)》\n- 《[Python学习手册（第4版）](https://www.amazon.cn/gp/product/B004TUJ7A6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004TUJ7A6&linkCode=as2&tag=vastwork-23)》\n- 《[Python Cookbook（第3版）](https://www.amazon.cn/gp/product/B00WKR1OKG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00WKR1OKG&linkCode=as2&tag=vastwork-23)》\n- 《[Python参考手册（第4版）](https://www.amazon.cn/gp/product/B01MCUN37Y/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01MCUN37Y&linkCode=as2&tag=vastwork-23)》\n- 《[Python核心编程（第3版）](https://www.amazon.cn/gp/product/B01FQAS0KK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01FQAS0KK&linkCode=as2&tag=vastwork-23)》\n- 《[Python科学计算（第2版）](https://www.amazon.cn/gp/product/B01HCVUJFA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01HCVUJFA&linkCode=as2&tag=vastwork-23)》\n- 《[利用 Python 进行数据分析](https://www.amazon.cn/gp/product/B00GHGZLWS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00GHGZLWS&linkCode=as2&tag=vastwork-23)》\n- 《[Think Python：像计算机科学家一样思考Python（第2版）](https://www.amazon.cn/gp/product/B01ION3W54/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01ION3W54&linkCode=as2&tag=vastwork-23)》\n- 《[Python编程实战:运用设计模式、并发和程序库创建高质量程序](https://www.amazon.cn/gp/product/B00MHDPIJ6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00MHDPIJ6&linkCode=as2&tag=vastwork-23)》\n- 《[Python绝技：运用Python成为顶级黑客](https://www.amazon.cn/gp/product/B019ZRGBVU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B019ZRGBVU&linkCode=as2&tag=vastwork-23)》\n- 《[Flask Web开发:基于Python的Web应用开发实战](https://www.amazon.cn/gp/product/B0153177A6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0153177A6&linkCode=as2&tag=vastwork-23)》\n\n### Android\n\n- 《[Android编程权威指南（第2版）](https://www.amazon.cn/gp/product/B01FSXCBOQ/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01FSXCBOQ&linkCode=as2&tag=vastwork-23)》\n- 《[移动应用UI设计模式（第2版）](https://www.amazon.cn/gp/product/B00SFZGX08/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00SFZGX08&linkCode=as2&tag=vastwork-23)》\n- 《[Android开发艺术探索](https://www.amazon.cn/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E4%BB%BB%E7%8E%89%E5%88%9A/dp/B014HV1X3K/ref=sr_1_1?s=books&ie=UTF8&qid=1478155289&sr=1-1&keywords=android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2)》\n\n### iOS\n\n- 《[iOS编程实战](https://www.amazon.cn/gp/product/B00NKZCM3U/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00NKZCM3U&linkCode=as2&tag=vastwork-23)》\n- 《[iOS编程（第4版）](https://www.amazon.cn/gp/product/B013UG2ULW/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B013UG2ULW&linkCode=as2&tag=vastwork-23)》\n- 《[Objective-C高级编程](https://www.amazon.cn/gp/product/B00DE60G3S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00DE60G3S&linkCode=as2&tag=vastwork-23)》\n- 《[Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法](https://www.amazon.cn/gp/product/B00IDSGY06/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00IDSGY06&linkCode=as2&tag=vastwork-23)》\n\n### PHP\n\n- 《[Head First PHP & MySQL（中文版）](https://www.amazon.cn/gp/product/B004R1QIJU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004R1QIJU&linkCode=as2&tag=vastwork-23)》\n- 《[深入PHP：面向对象、模式与实践（第3版）](https://www.amazon.cn/gp/product/B005D6IRRY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B005D6IRRY&linkCode=as2&tag=vastwork-23)》\n\n### C语言\n\n- 《[C标准库](https://www.amazon.cn/gp/product/B00IZW4DK8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00IZW4DK8&linkCode=as2&tag=vastwork-23)》\n- 《[C和指针](https://www.amazon.cn/gp/product/B00163LU68/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00163LU68&linkCode=as2&tag=vastwork-23)》\n- 《[C专家编程](https://www.amazon.cn/gp/product/B0012NIW9K/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0012NIW9K&linkCode=as2&tag=vastwork-23)》\n- 《[C陷阱与缺陷](https://www.amazon.cn/gp/product/B0012UMPBY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0012UMPBY&linkCode=as2&tag=vastwork-23)》\n- 《[C语言接口与实现](https://www.amazon.cn/gp/product/B01D10NSCM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01D10NSCM&linkCode=as2&tag=vastwork-23)》\n- 《[C程序设计语言（第2版）](https://www.amazon.cn/gp/product/B0011425T8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0011425T8&linkCode=as2&tag=vastwork-23)》\n- 《C语言参考手册（第5版）》\n\n### C++\n\n- 《[C++标准库](https://www.amazon.cn/gp/product/B00YLZIRHI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00YLZIRHI&linkCode=as2&tag=vastwork-23)》\n- 《[C++编程思想](https://www.amazon.cn/gp/product/B005CFUQR0/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B005CFUQR0&linkCode=as2&tag=vastwork-23)》\n- 《C++语言的设计与演化》\n- 《[C++程序设计原理与实践](https://www.amazon.cn/gp/product/B003VPX6YS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B003VPX6YS&linkCode=as2&tag=vastwork-23)》\n- 《[C++ Primer （中文第5版）](https://www.amazon.cn/gp/product/B00ESUIL0O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ESUIL0O&linkCode=as2&tag=vastwork-23)》\n- 《[C++ Primer习题集(第5版)](https://www.amazon.cn/gp/product/B00S6U4C6E/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00S6U4C6E&linkCode=as2&tag=vastwork-23) 》\n- 《[C++程序设计语言(第1-3部分)(原书第4版)](https://www.amazon.cn/gp/product/B01I9BNASA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01I9BNASA&linkCode=as2&tag=vastwork-23) 》\n- 《[Effective C++:改善程序与设计的55个具体做法(第3版)(中文版) ](https://www.amazon.cn/gp/product/B004G72P24/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004G72P24&linkCode=as2&tag=vastwork-23)》\n- 《[More Effective C++:35个改善编程与设计的有效方法(中文版) ](https://www.amazon.cn/gp/product/B004IP8BD6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004IP8BD6&linkCode=as2&tag=vastwork-23)》  \n\n### 机器学习和数据挖掘\n\n- 《[数据之巅](https://www.amazon.cn/gp/product/B00JUE9DXW/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00JUE9DXW&linkCode=as2&tag=vastwork-23)》\n- 《[矩阵分析](https://www.amazon.cn/gp/product/B00NTM5GK0/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00NTM5GK0&linkCode=as2&tag=vastwork-23)》\n- 《[机器学习](https://www.amazon.cn/gp/product/B002WC7NH2/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B002WC7NH2&linkCode=as2&tag=vastwork-23)》\n- 《[统计学习方法](https://www.amazon.cn/gp/product/B007TSFMTA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B007TSFMTA&linkCode=as2&tag=vastwork-23)》\n- 《[机器学习导论](https://www.amazon.cn/gp/product/B01AG3ZV9K/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B01AG3ZV9K&linkCode=as2&tag=vastwork-23)》\n- 《[推荐系统实践](https://www.amazon.cn/gp/product/B008AK5YJO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008AK5YJO&linkCode=as2&tag=vastwork-23)》\n- 《[机器学习实战](https://www.amazon.cn/gp/product/B00D747PTK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00D747PTK&linkCode=as2&tag=vastwork-23)》\n- 《[Web数据挖掘](https://www.amazon.cn/gp/product/B00AY830HS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00AY830HS&linkCode=as2&tag=vastwork-23)》\n- 《[深入浅出统计学](https://www.amazon.cn/gp/product/B006PHIVNA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B006PHIVNA&linkCode=as2&tag=vastwork-23)》\n- 《[模式分类（第2版）](https://www.amazon.cn/gp/product/B00116C3DY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00116C3DY&linkCode=as2&tag=vastwork-23)》\n- 《[概率论与数理统计](https://www.amazon.cn/gp/product/B00264GG56/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00264GG56&linkCode=as2&tag=vastwork-23)》\n- 《[统计学习基础(第2版)(英文)](https://www.amazon.cn/gp/product/B00PRH2BXA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00PRH2BXA&linkCode=as2&tag=vastwork-23) 》\n- 《[数据挖掘：概念与技术（第3版）](https://www.amazon.cn/gp/product/B007NR0T4A/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B007NR0T4A&linkCode=as2&tag=vastwork-23)》\n- 《[数据挖掘：实用机器学习工具与技术（原书第3版）](https://www.amazon.cn/gp/product/B00K5I91WK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00K5I91WK&linkCode=as2&tag=vastwork-23)》\n- 《[大数据：互联网大规模数据挖掘与分布式处理（第2版）](https://www.amazon.cn/gp/product/B011I34CGA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B011I34CGA&linkCode=as2&tag=vastwork-23)》\n\n### 数据库\n\n- 《[数据库系统概念](https://amazon.cn/gp/product/B007KYSEZC/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=vastwork-23&creative=3200&linkCode=as2&creativeASIN=B007KYSEZC&linkId=32d1830aaeeda5b1ccaf242af94e73ad)》\n- 《[数据库系统实现](https://amazon.cn/gp/product/B003NX8D0A/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=vastwork-23&creative=3200&linkCode=as2&creativeASIN=B003NX8D0A&linkId=3d1723a92384a5febb43c2400b31f1fe)》\n- 《[SQL应用重构](https://www.amazon.cn/gp/product/B00H6X6M1A/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00H6X6M1A&linkCode=as2&tag=vastwork-23)》\n- 《[SQL Cookbook](https://www.amazon.cn/gp/product/0596009763/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=0596009763&linkCode=as2&tag=vastwork-23)》\n- 《[高性能MySQL （第3版）](https://www.amazon.cn/gp/product/B00C1W58DE/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00C1W58DE&linkCode=as2&tag=vastwork-23)》\n- 《深入浅出SQL（中文版）》\n- 《[MySQL技术内幕 : InnoDB存储引擎（第2版）](https://www.amazon.cn/gp/product/B00ETOV48K/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ETOV48K&linkCode=as2&tag=vastwork-23)》\n- 《[深入浅出MySQL : 数据库开发、优化与管理维护](https://www.amazon.cn/gp/product/B00KR87J8G/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00KR87J8G&linkCode=as2&tag=vastwork-23)》\n- 《[收获,不止SQL优化:抓住SQL的本质](https://www.amazon.cn/%E6%94%B6%E8%8E%B7-%E4%B8%8D%E6%AD%A2SQL%E4%BC%98%E5%8C%96-%E6%8A%93%E4%BD%8FSQL%E7%9A%84%E6%9C%AC%E8%B4%A8-%E6%A2%81%E6%95%AC%E5%BD%AC/dp/B071S6ZYH8/ref=sr_1_1?s=books&ie=UTF8&qid=1510300270&sr=1-1&keywords=%E4%B8%8D%E6%AD%A2+sql)》\n- 《[SQL Server 性能优化与管理的艺术](https://www.amazon.cn/SQL-Server%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E7%AE%A1%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF-%E9%BB%84%E9%92%8A%E5%90%89/dp/B00NW2FVAM/ref=tmm_pap_swatch_0?_encoding=UTF8&qid=1510300294&sr=1-8)》\n- 《[SQL Server性能调优实战](https://www.amazon.cn/SQL-Server%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98-%E9%99%88%E7%95%85%E4%BA%AE/dp/B0171JJEN6/ref=sr_1_11?s=books&ie=UTF8&qid=1510300294&sr=1-11&keywords=sql+server)》\n- 《[T-SQL性能调优秘笈:基于SQL Server 2012窗口函数](https://www.amazon.cn/T-SQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%A7%98%E7%AC%88-%E5%9F%BA%E4%BA%8ESQL-Server-2012%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-%E6%9C%AC-%E7%94%98/dp/B00M1CH5A8/ref=sr_1_14?s=books&ie=UTF8&qid=1510300294&sr=1-14&keywords=sql+server)》\n\n### 测试\n\n- 《[探索式软件测试](https://www.amazon.cn/gp/product/B003JBIV0S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B003JBIV0S&linkCode=as2&tag=vastwork-23)》\n- 《[有效的单元测试](https://www.amazon.cn/gp/product/B00PVOND2W/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00PVOND2W&linkCode=as2&tag=vastwork-23)》\n- 《[Google软件测试之道](https://www.amazon.cn/gp/product/B00FH36R6G/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00FH36R6G&linkCode=as2&tag=vastwork-23)》\n\n### 项目与团队\n\n- 《[人月神话](https://www.amazon.cn/gp/product/B00VR8ZO28/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00VR8ZO28&linkCode=as2&tag=vastwork-23)》\n- 《[快速软件开发](https://www.amazon.cn/gp/product/B001DBRWL0/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B001DBRWL0&linkCode=as2&tag=vastwork-23)》\n- 《[人件（原书第3版）](https://www.amazon.cn/gp/product/B00MO7R1SG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00MO7R1SG&linkCode=as2&tag=vastwork-23)》\n- 《[门后的秘密：卓越管理的故事](https://www.amazon.cn/gp/product/B00CBBKRQ8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00CBBKRQ8&linkCode=as2&tag=vastwork-23)》\n- 《[极客与团队：软件工程师的团队生存秘笈](https://www.amazon.cn/gp/product/B00BLZMG8W/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00BLZMG8W&linkCode=as2&tag=vastwork-23)》\n- 《[硝烟中的 Scrum 和 XP](https://amazon.cn/gp/product/B00EE5HBAO/ref=as_li_qf_asin_il_tl?ie=UTF8&tag=vastwork-23&creative=3200&linkCode=as2&creativeASIN=B00EE5HBAO&linkId=d904f054b7a79a701065f544a449512b)》\n\n### 求职面试\n\n- 《[程序员面试金典（第5版）](https://www.amazon.cn/gp/product/B00G8VOQOG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00G8VOQOG&linkCode=as2&tag=vastwork-23)》\n- 《[编程之美 : 微软技术面试心得](https://www.amazon.cn/gp/product/B00W5269HO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00W5269HO&linkCode=as2&tag=vastwork-23)》\n- 《[金领简历：敲开苹果、微软、谷歌的大门](https://www.amazon.cn/gp/product/B00ALPRM7S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ALPRM7S&linkCode=as2&tag=vastwork-23)》\n- 《[剑指Offer：名企面试官精讲典型编程题（纪念版）](https://www.amazon.cn/gp/product/B00L5LKMVU/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00L5LKMVU&linkCode=as2&tag=vastwork-23)》\n\n### 编程之外\n\n- 《[暗时间](https://www.amazon.cn/gp/product/B005DSK4W8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B005DSK4W8&linkCode=as2&tag=vastwork-23)》\n- 《[数学之美](https://www.amazon.cn/gp/product/B00P6OJ09C/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00P6OJ09C&linkCode=as2&tag=vastwork-23)》\n- 《[赢得朋友](https://www.amazon.cn/gp/product/B00ANY9KZE/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ANY9KZE&linkCode=as2&tag=vastwork-23)》\n- 《[精益创业](https://www.amazon.cn/gp/product/B008MIFWJG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008MIFWJG&linkCode=as2&tag=vastwork-23)》\n- 《[批判性思维](https://www.amazon.cn/gp/product/B00QPZARMA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00QPZARMA&linkCode=as2&tag=vastwork-23)》\n- 《[世界是数字的](https://www.amazon.cn/gp/product/B00M2DKZNA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00M2DKZNA&linkCode=as2&tag=vastwork-23)》\n- 《[程序员的数学](https://www.amazon.cn/gp/product/B00A4H3JJS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00A4H3JJS&linkCode=as2&tag=vastwork-23)》\n- 《[程序员健康指南](https://www.amazon.cn/gp/product/B00N4LZ6RO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00N4LZ6RO&linkCode=as2&tag=vastwork-23)》\n- 《[禅与摩托车维修艺术](https://www.amazon.cn/gp/product/B005O4PUFC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B005O4PUFC&linkCode=as2&tag=vastwork-23)》\n- 《[关键对话：如何高效能沟通](https://www.amazon.cn/gp/product/B0081M8TZ2/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0081M8TZ2&linkCode=as2&tag=vastwork-23)》\n- 《[写作法宝：非虚构写作指南](https://www.amazon.cn/gp/product/B00EY8JUBO/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00EY8JUBO&linkCode=as2&tag=vastwork-23)》\n- 《[黑客与画家 : 来自计算机时代的高见](https://www.amazon.cn/gp/product/B00G1ZT2C0/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00G1ZT2C0&linkCode=as2&tag=vastwork-23)》\n- 《[软件随想录（卷1）](https://www.amazon.cn/gp/product/B00WDTQU8M/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00WDTQU8M&linkCode=as2&tag=vastwork-23)》《[软件随想录（卷2）](https://www.amazon.cn/gp/product/B00WFT32FY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00WFT32FY&linkCode=as2&tag=vastwork-23)》\n- 《[如何把事情做到最好：改变全球9800万人的人生指导书](https://www.amazon.cn/gp/product/B00ICWNKT6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ICWNKT6&linkCode=as2&tag=vastwork-23)》\n\n## 非技术书籍\n\n### 工具书\n\n- 《关键对话：如何高效沟通》\n\n### 外国名著\n\n- 《冰与火之歌》\n- 世纪三部曲\n  - 《巨人的陨落》\n  - 《永恒的边缘》\n  - 《世界的凛冬》\n- 《追风筝的人》\n- 《人性的弱点》\n- 《灿烂千阳》\n- 《月亮和六便士》\n- 《霍乱时期的爱情》\n- 《查令十字街84号》\n- 《麦田里的守望者》\n\n### 小说\n\n- 《尘埃落定》\n- 《活着》\n- 《暗算》\n\n### 推理\n\n- 《无人生还》\n- 《白夜行》\n- 《解忧杂货店》\n\n### 科幻\n\n- 《三体》\n- 《海伯利安》\n\n### 历史\n\n- 《万历十五年》\n- 《人类简史》\n- 《今日简史》\n- 《未来简史》\n- 《明朝那些事儿》\n\n### 传记\n\n- 《我们仨》\n\n### 文学\n\n- 《围城》\n\n### 经管\n\n- 《原则》\n\n- 《富爸爸穷爸爸》\n\n### 心理\n\n- 《乌合之众：大众心理研究》\n- 《自控力》","tags":["读书"],"categories":["lists"]},{"title":"redis实现分布式文件夹锁","url":"/2019/01/01/redis-file-lock/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](redis-file-lock/p12.jpg)\n\n## 缘起\n\n最近做一个项目，类似某度云盘，另外附加定制功能，本人负责云盘相关功能实现，这个项目跟云盘不同的是，以项目为分配权限的单位，同一个项目及子目录所有有权限的用户可以同时操作所有文件，这样就很容易出现并发操作，而且表结构设计的时候，定下来文件和文件夹都有个path字段，存储的是所在父级文件夹路径，这样检索方便，重命名和移动比较麻烦。\n\n如下，例如甲同学正在移动项目下C文件夹，而此时乙同学也在操作项目下D下的d.txt文件，这样就会出现问题，所以需要分布式锁控制，甲在操作C文件夹的时候，C文件夹所有子文件和包含C文件夹的父文件夹都被锁住，如图将会被锁定的文件夹和子文件有：A、C、c.txt、D、E、d.txt，其中a.txt和B未被锁定，这个是移动的情况，如下表格列出其他情况.\n\n![](redis-file-lock/图1.jpg)\n\n| 操作对象  | 操作         | 新建 | 上传 | 移动文件夹 | 移动文件 | 复制文件夹 | 复制文件 | 重命名文件夹 | 重命名文件 | 删除文件夹 | 删除文件 | 回收站清除 |\n| :-------- | ------------ | :--- | ---- | ---------- | -------- | ---------- | -------- | ------------ | ---------- | ---------- | -------- | ---------- |\n| /A        | 新建         | √    | √    | ×          | √        | ×          | √        | ×            | √          | ×          | √        | /          |\n| /A        | 上传         | √    | √    | ×          | √        | ×          | √        | ×            | √          | ×          | √        | /          |\n| /A->/B    | 移动文件夹   | A×B× | A×B× | A×B×       | A×B×     | A√B√       | A√B√     | A×B×         | A×B√       | A×B×       | A×B√     | /          |\n| a.txt->/B | 移动文件     | B√   | B√   | B×         | B√       | B×         | a√B×     | a×B×         | a×B√       | B×         | a×B√     | /          |\n| /A->/B    | 复制文件夹   | B√   | B√   | B×         | B√       | B√         | B√       | B×           | B√         | B×         | B√       | /          |\n| a.txt->/B | 复制文件     | B√   | B√   | B×         | B√       | B√         | B√       | B×           | B√         | B×         | B√       | /          |\n| /A        | 重命名文件夹 | A×   | A×   | A×         | A×       | A√         | A√       | A×           | A×         | A×         | A×       | /          |\n| a.txt     | 重命名文件   | /    | /    | ×          | ×        | ×          | ×        | √            | ×          | ×          | ×        | /          |\n| /A        | 删除文件夹   | ×    | ×    | ×          | ×        | ×          | ×        | ×            | ×          | ×          | ×        | /          |\n| a.txt     | 删除文件     | ×    | ×    | ×          | ×        | ×          | ×        | ×            | ×          | ×          | ×        | /          |\n| /A，a.txt | 回收站清除   | /    | /    | /          | /        | /          | /        | /            | /          | /          | /        | A×a×       |\n\n> 符号解释：√：可以操作，×：不可以操作，/：互相不影响\n>\n> 整体解释：例如第一行，意思是：对于A这个文件夹，当第一个人进行新建操作的时候，其他人同时进行新建、上传、移动文件、复制文件、重命名文件、删除文件是允许的，移动文件夹、复制文件夹、重命名文件夹、删除文件夹是不允许的，回收站清除和新建操作是互不影响的。\n\n## 思考和调研\n\n分布式锁常见的三种实现方式：数据库、zookeeper/etcd（临时有序节点）、redis（setnx/lua脚本），各有千秋。\n\n### 数据库实现分布式锁\n\n#### 实现\n\n原理简单易实现，创建一张lock表，存储锁定的资源、上锁对象、获取锁的资源、获取锁时间等，获取锁时查询该资源是否存在记录，存在且未过失效时间则获取锁失败，不存在则插入一条数据并且获取锁成功；释放锁则更简单，删除锁数据即可。\n\n#### 缺点\n\n- 释放锁删除数据时，会出现死锁情况\n\n#### 优点\n\n- 实现简单\n\n### zookeeper/etcd实现分布式锁\n\n详见[zookeeper总结]()\n\n### redis实现分布式锁 \n\n详见[Redis总结](https://www.yizhuxiaozhan.site/2018/09/12/redis-summary/#分布式锁的实现)\n\n## 分布式文件夹锁实现过程\n\n基于开文处所列情况，要覆盖所有复杂情况很难，但是实现基本的文件夹锁是必须的，故选择了redis+lua脚本，具体代码如下\n\n### java获取锁工具类\n\n```java\n/**\n * redis工具类\n */\npublic class RedisLockUtils {\n\n    static final Long SUCCESS = 1L;\n    static final String LOCKED_HASH = \"cs:lockedHashKey\";\n    static final String GET_LOCK_LUA_RESOURCE = \"/lua/getFileLock.lua\";\n    static final String RELEASE_LOCK_LUA_RESOURCE = \"/lua/releaseFileLock.lua\";\n    static final Logger LOG = LoggerFactory.getLogger(RedisLockUtils.class);\n    \n    /**\n     * 获取文件夹锁\n     * @param redisTemplate\n     * @param lockProjectId\n     * @param lockKey\n     * @param requestValue\n     * @param expireTime 单位：秒\n     * @return\n     */\n    public static boolean getFileLock(RedisTemplate redisTemplate, Long lockProjectId, String lockKey, String requestValue, Integer expireTime) {\n\n        LOG.info(\"start run lua script，{{}} start request lock\",lockKey);\n        long start = System.currentTimeMillis();\n        DefaultRedisScript<String> luaScript =new DefaultRedisScript<>();\n        luaScript.setLocation(new ClassPathResource(GET_LOCK_LUA_RESOURCE));\n        luaScript.setResultType(String.class);\n\n        Object result = redisTemplate.execute(\n                luaScript,\n                Arrays.asList(lockKey, LOCKED_HASH + lockProjectId),\n                requestValue,\n                String.valueOf(expireTime),\n                String.valueOf(System.currentTimeMillis())\n        );\n        boolean getLockStatus = SUCCESS.equals(result);\n\n        LOG.info(\"{{}} cost time {} ms，request lock result：{}\",lockKey,(System.currentTimeMillis()-start), getLockStatus);\n        return getLockStatus;\n    }\n\n    /**\n     * 释放文件夹锁\n     * @param redisTemplate\n     * @param lockProjectId\n     * @param lockKey\n     * @param requestValue\n     * @return\n     */\n    public static boolean releaseFileLock(RedisTemplate redisTemplate, Long lockProjectId, String lockKey, String requestValue) {\n\n        DefaultRedisScript<String> luaScript =new DefaultRedisScript<>();\n        luaScript.setLocation(new ClassPathResource(RELEASE_LOCK_LUA_RESOURCE));\n        luaScript.setResultType(String.class);\n\n        Object result = redisTemplate.execute(\n                luaScript,\n                Arrays.asList(lockKey, LOCKED_HASH + lockProjectId),\n                requestValue\n        );\n        boolean releaseLockStatus = SUCCESS.equals(result);\n\n        LOG.info(\"{{}}release lock result：{}\", lockKey, releaseLockStatus);\n        return releaseLockStatus;\n    }\n\n}\n```\n\n### lua脚本\n\n#### 获取文件夹锁\n\n##### 入参说明\n\n`requestKey`为请求锁的路径，`requestValue`为请求锁的value，应为请求锁时生成的`UUID`，确保解锁人只能为上锁人，`lockedKeys`为存放所有锁的`哈希表`的key，这里用常量加项目id的方式，确保一个项目的所有锁存在一个`哈希表`里面，`expireTime`为锁的过期时间，`nowTime`为当前时间，由于lua脚本里面获取当前时间消耗性能且获取的是redis服务器上的当前时间，可能不准确。\n\n##### 思路说明\n\n首先，通过`GET key`判断是否有人正在操作这个文件夹，若有人在操作则直接返回0（获取锁失败），否则获取存放该项目锁的哈希表里面的所有key，遍历所有key，通过lua脚本的`string.find`函数对比该key和请求的key是否存在包含或被包含关系，若存在包含关系且未失效，则返回0（获取锁失败），否则则可获取锁，设置key和过期时间及存入哈希表（哈希表内存放请求锁的key和请求时间），最后返回1（获取锁成功）。\n\n例如请求上图中项目下的C文件夹的锁，请求路径为：`项目/A/C`，当另一个人想操作D文件夹，请求路径为：`项目/A/C/D`，此时查询到存储这个项目所有锁定key的`哈希表`，里面包含`项目/A/C`这个key，这两个key通过lua函数`string.find`发现`项目/A/C/D`包含`项目/A/C`，且未到过期时间，则获取锁失败，否则获取锁成功。\n\n```lua\nlocal requestKey=KEYS[1]\nlocal lockedKeys=KEYS[2]\nlocal requestValue=ARGV[1]\nlocal expireTime=ARGV[2]\nlocal nowTime=ARGV[3]\nif redis.call('get',requestKey)\nthen\n    return 0\nend\nlocal lockedHash = redis.call('hkeys',lockedKeys)\nfor i=1, #lockedHash do\n    if string.find(requestKey,lockedHash[i]) or string.find(lockedHash[i],requestKey)\n    then\n        local lockTime = redis.call('hget',lockedKeys,lockedHash[i])\n        if (nowTime-lockTime) >= expireTime * 1000\n        then\n            redis.call('hdel',lockedKeys,lockedHash[i])\n        else\n            return 0\n        end\n    end\nend\nredis.call('set',requestKey,requestValue)\nredis.call('expire',requestKey,expireTime)\nredis.call('hset',lockedKeys,requestKey,nowTime)\nreturn 1\n```\n\n#### 释放文件夹锁\n\n##### 入参说明\n\n`requestKey`为请求锁的路径，`requestValue`为请求锁的value，应为请求锁时生成的`UUID`，确保解锁人只能为上锁人，`lockedKeys`为存放所有锁的`哈希表`的key，这里用常量加项目id的方式，确保一个项目的所有锁存在一个`哈希表`里面。\n\n```lua\nlocal requestKey=KEYS[1]\nlocal lockedKeys=KEYS[2]\nlocal requestValue=ARGV[1]\nif redis.call('get', requestKey) == requestValue\nthen\n    redis.call('hdel', lockedKeys,requestKey)\n    return redis.call('del',requestKey)\nelse\n    return 0\nend\n```\n\n### 优点\n\n1. 灵活，锁定的范围可以随`requestKey`变化而变化\n2. 性能不错，经测试除了第一次lua脚本未缓存耗时较长，第二次之后则在10ms左右可得到请求结果\n\n### 缺点\n\n1. 可靠性依赖redis\n2. 不是可重入锁\n3. 维护成本较高，需熟知redis的5种数据结构及lua脚本\n\n## 总结\n\n通过单元自测和测试环境测试基本可以确保多数情况下的多用户并发操作文件只有一人能进行有效操作，保证了数据的安全性。经过这次实践，对分布式锁有了更深入的了解。","tags":["分布式锁"],"categories":["redis"]},{"title":"读书笔记---《编写可读代码的艺术》","url":"/2018/12/16/read-note-readable-code/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](read-note-readable-code/book.jpg )\n\n## 前言\n\n我们曾经在非常成功的软件公司中和出色的工程师一起工作，然而我们所遇到的代码仍有很大的改进空间。实际上，我们曾见到一些很难看的代码，你可能也见过。但是当我们看到写得很漂亮的代码时，会很受启发。好代码会很明确告诉你它在做什么。使用它会很有趣，并且会鼓励你把自己的代码写得更好。本书旨在帮助你把代码写得更好。\n\n每一章都会深入编程的某个方面来讨论如何使代码更容易理解。本书分成四部分：表面层次上的改进命名、注释以及审美——可以用于代码库每一行的小提示。简化循环和逻辑在程序中定义循环、逻辑和变量，从而使得代码更容易理解。重新组织你的代码在更高层次上组织大的代码块以及在功能层次上解决问题的方法。\n\n## 第1章 代码应当易于理解\n\n- 代码的写法应当使别人理解它所需的时间最小化。\n\n- 减少代码行数是一个好目标，但把理解代码所需的时间最小化是一个更好的目标。\n- 经常想一想其他人是不是会觉得你的代码容易理解\n\n## 第一部分 表面层次的改进\n\n- 选择好的名字\n- 写好的注释\n- 把代码整洁地写成更好的格式\n\n## 第2章 把信息装到名字里\n\n- 把信息装进名字中\n- 选择专业的词\n  - 避免使用tmp、retval、it、foo泛泛的词\n  - 如果不把循环索引命名为（i、j、k），另一个选择可以是（club_i、members_i、user_i）或者，更简化一点（ci、mi、ui）\n- 用具体的名字替代抽象的名字\n- 使用前缀和后缀来给名字附带更多信息\n- 决定名字的长度\n  - 在小的作用域里可以使用短的名字\n- 利用名字的格式来表达含义\n\n## 第3章 不会误解的名字\n\n- `filter`是个二义性单词。我们不清楚它的含义到底是“挑出”还是“减掉”。最好避免使用“filter”这个名字，因为它太容易误解。 \n\n- 推荐用min和max来表示（包含）极限 \n\n- 建议 命名极限最清楚的方式是在要限制的东西前加上max_或者min_。 \n\n- 推荐用first和last来表示包含的范围 \n\n- 推荐用begin和end来表示包含/排除范围 \n\n- 通常来讲，加上像is、has、can或should这样的词，可以把布尔值变得更明确。 \n\n- 很多程序员都习惯了把以get开始的方法当做“轻量级访问器”这样的用法，它只是简单地返回一个内部成员变量。如果违背这个习惯很可能会误导用户。相反，这个方法应当重命名为像computeMean()这样的名字，后者听起来更像是有些代价的操作。\n\n## 第4章 审美\n\n大家都愿意读有美感的代码。通过把代码用一致的、有意义的方式“格式化”，可以把代码变得更容易读，并且可以读得更快。下面是讨论过的一些具体技巧：\n\n- 如果多个代码块做相似的事情，尝试让它们有同样的剪影，使用一致的布局，让读者很快就习惯这种风格\n- 把代码按“列”对齐可以让代码更容易浏览\n- 如果在一段代码中提到A、B和C，那么不要在另一段中说B、C和A。选择一个有意义的顺序，并始终用这样的顺序\n- 用空行来把大块代码分成逻辑上的“段落”。\n\n## 第5章 该写什么样的注释\n\n注释的目的是帮助读者了解作者在写代码时已经知道的那些事情。本章介绍了如何发现所有的并不那么明显的信息块并且把它们写下来。什么地方不需要注释：\n\n- 能从代码本身中迅速地推断的事实\n- 用来粉饰烂代码（例如蹩脚的函数名）的“拐杖式注释”——应该把代码改好。你应该记录下来的想法包括：\n  - 对于为什么代码写成这样而不是那样的内在理由（“指导性批注”）\n  - 代码中的缺陷，使用像TODO:或者XXX:这样的标记\n  - 常量背后的故事，为什么是这个值。\n  - 站在读者的立场上思考：预料到代码中哪些部分会让读者说：“啊？”并且给它们加上注释\n  - 为普通读者意料之外的行为加上注释\n  - 在文件/类的级别上使用“全局观”注释来解释所有的部分是如何一起工作的\n  - 用注释来总结代码块，使读者不致迷失在细节中\n\n## 第6章 写出言简意赅的注释\n\n本章是关于如何把更多的信息装入更小的空间里。下面是一些具体的提示：\n\n- 当像“it”和“this”这样的代词可能指代多个事物时，避免使用它们\n- 尽量精确地描述函数的行为\n- 在注释中用精心挑选的输入/输出例子进行说明\n- 声明代码的高层次意图，而非明显的细节\n- 用嵌入的注释（如Function(/*arg =*/...)）来解释难以理解的函数参数\n- 用含义丰富的词来使注释简洁\n\n## 第二部分 简化循环和逻辑\n\n## 第7章 把控制流变得易读\n\n有几种方法可以让代码的控制流更易读\n\n- 在写一个比较时（while (bytes_expected ＞ bytes_received)），把改变的值写在左边并且把更稳定的值写在右边更好一些（while (bytes_received ＜; bytes_expected)）\n- 你也可以重新排列if/else语句中的语句块。通常来讲，先处理正确的/简单的/有趣的情况。有时这些准则会冲突，但是当不冲突时，这是要遵循的经验法则\n- 某些编程结构，像三目运算符（:?）、do/while循环，以及goto经常会导致代码的可读性变差。最好不要使用它们，因为总是有更整洁的代替方式\n- 嵌套的代码块需要更加集中精力去理解。每层新的嵌套都需要读者把更多的上下文“压入栈”。应该把它们改写成更加“线性”的代码来避免深嵌套。通常来讲提早返回可以减少嵌套并让代码整洁。“保护语句”（在函数顶部处理简单的情况时）尤其有用。\n\n## 第8章 拆分超长表达式\n\n- 把超长表达式拆成更容易理解的小块\n- 引入解释变量\n\n## 第9章 变量与可读性\n\n关于程序中的变量是如何快速累积而变得难以跟踪的。你可以通过减少变量的数量和让它们尽量“轻量级”来让代码更有可读性。具体有：\n\n- 减少变量，即那些妨碍的变量。我们给出了几个例子来演示如何通过立刻处理结果来消除“中间结果”变量\n- 减小每个变量的作用域，越小越好。把变量移到一个有最少代码可以看到它的地方。眼不见，心不烦\n- 只写一次的变量更好。那些只设置一次值的变量（或者const、final、常量）使得代码更容易理解。\n\n## 第三部分 重新组织代码\n\n我们会讲到三种组织代码的方法：\n\n- 抽取出那些与程序主要目的“不相关的子问题”\n- 重新组织代码使它一次只做一件事情\n- 先用自然语言描述代码，然后用这个描述来帮助你找到更整洁的解决方案\n\n## 第10章 抽取不相关的子问题\n\n- 所谓工程学就是关于把大问题拆分成小问题再把这些问题的解决方案放回一起。把这条原则应用于代码会使代码更健壮并且更容易读。\n\n- 积极地发现并抽取出不相关的子逻辑\n  - 纯工具代码 \n    - 通常来讲，如果你在想：“我希望我们的库里有XYZ()函数”，那么就写一个！（如果它还不存在的话）经过一段时间，你会建立起一组不错的工具代码，后者可以应用于多个项目。 \n  - 其他多用途代码 \n    - 当format_pretty()中的代码自成一体后改进它变得更容易。当你在使用一个独立的小函数时，感觉添加功能、改进可读性、处理边界情况等都更容易。 \n  - 创建大量通用代码 \n  - 项目专有的功能 \n  - 简化已有接口 \n  - 按需重塑接口 \n  - 过犹不及 \n    - 引入这么多小函数实际上对可读性是不利的，因为读者要关注更多东西，并且按照执行的路径需要跳来跳去\n\n## 第11章 一次只做一件事\n\n- 应该把代码组织得一次只做一件事情。\n\n## 第12章 把想法变成代码\n\n- 用自然语言描述程序然后用这个描述来帮助你写出更自然的代码。这个技巧出人意料地简单，但很强大。看到你在描述中所用的词和短语还可以帮助你发现哪些子问题可以拆分出来。 但是这个“用自然语言说事情”的过程不仅可以用于写代码。 \n\n## 第13章 少写代码\n\n- 不是所有的程序都需要运行得快，100%准确，并且能处理所有的输入。如果你真的仔细检查你的需求，有时你可以把它削减成一个简单的问题，只需要较少的代码。\n- 我们所描述的是宇宙的自然法则——随着任何坐标系统的增长，把它粘合在一起所需的复杂度增长得更快。 最好的解决办法就是“让你的代码库越小，越轻量级越好”，就算你的项目在增长。那么你就要：\n  - 创建越多越好的“工具”代码来减少重复代码（见第10章）\n  - 减少无用代码或没有用的功能\n  - 让你的项目保持分开的子项目状态\n  - 总的来说，要小心代码的“重量”。让它保持又轻又灵。 \n\n- 熟悉你周边的库 \n  - 很多时候，程序员就是不知道现有的库可以解决他们的问题。或者有时，它们忘了库可以做什么。知道你的库能做什么以便你可以使用它，这一点很重要。 \n\n## 我的总结\n\n在日常开发中，比较注重编码规范及命名等细节，个人认为命名和注释写得好是需要观察、积累和总结的，这也很重要，同时在阅读jdk、spring、mybatis等优秀框架源码也发现好的命名的重要性，下面总结了一些命名及编码方式，周知的驼峰命名、常量大写等就不列举了。只写一些书中没提到的。\n\n### 命名相关\n\n- 动宾格式命名方法\n\n  - prepareContext、prepareEnvironment\n\n- 前缀命名\n\n  - spring中doXXX是真正做事情的方法，如doLoadBeanDefinitions、doRegisterBeanDefinitions\n  - preXXX、postXXX：前置、后置处理方法\n  - loadXXX：loadBeanDefinitions\n\n- 后缀命名\n\n  - XXXListener：一看就知道是监听器\n  - XXXFactory、XXXDelegate、XXXTemplate：使用了工厂模式、委派模式、模板模式等\n\n- 善用词性\n\n  - listeners.starting()、listeners.started(context)等不用说就知道区别，表示不同阶段\n\n- 名词单复数\n\n  - user、users：分别代表一个用户和多个用户\n\n### 代码风格\n\n- 按功能划分代码，一个类不超过千行\n- 常量统一写在头部\n- 多次使用的抽象成工具类\n- 语义化、函数式编程","tags":["编码艺术"],"categories":["读书笔记"]},{"title":"HashMap源码阅读","url":"/2018/10/27/hashmap/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](hashmap/p9.jpg)\n\n# HashMap源码阅读笔记\n\n> 版本说明：jdk 1.8\n\n## 源码分析\n\n- 继承关系\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable\n```\n\n- 默认初始大小：16\n\n```java\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n```\n\n- 最大容量：2的30次幂\n\n```java\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n```\n\n- 默认负载因子：0.75f\n\n```java\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n```\n\n- 当链表的长度大于8时，转为红黑树存储，反过来小于6时，转为链表存储\n\n```java\nstatic final int TREEIFY_THRESHOLD = 8;\nstatic final int UNTREEIFY_THRESHOLD = 6;\n```\n\n- 真正存储数据的node，存储该节点的hash值，key，value和链表的下一节点，并重写了`hashCode()`、`equals()`和`toString()`方法\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n\n    public final K getKey()        { return key; }\n    public final V getValue()      { return value; }\n    public final String toString() { return key + \"=\" + value; }\n\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n\n    public final V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n\n    public final boolean equals(Object o) {\n        if (o == this)\n            return true;\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n            if (Objects.equals(key, e.getKey()) &&\n                Objects.equals(value, e.getValue()))\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n- 计算hash值的方法：key的hashcode()高16位不变，低16位与高16位异或\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n- 返回大于等于 cap 对应的最小2的 n 次幂\n  - cap-1再赋值给n的目的是令找到的目标值大于或等于原值。如果cap本身是2的幂，如8，不对它减1而直接操作，将得到16\n  - 移位操作，会使cap的二进制从最高位的1到末尾全部置为1\n\n```java\nstatic final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n\n- 四个构造方法\n  - 指定初始大小和负载因子\n  - 指定初始大小，负载因子使用默认值0.75f\n  - 空构造方法\n  - 接收一个map的构造方法，负载因子为0.75f，大小由map决定\n- put方法\n  - 先根据hash算法计算hash值\n  - 初始化大小\n  - 计算下标位置（与运算，速度快），判断是否存在元素\n    - 为空，则存储node节点\n    - 不为空\n      - 若hash值和key相同，则替换原值，返回旧值\n      - 若为红黑树，则存储为红黑树node\n      - 否则，遍历链表\n        - 若下一个node为空，存到该节点\n          - 若长度>=8，转换成红黑树存储\n        - 若下一节点不为空，且hash值和key相同，则替换原值，返回旧值\n  - 判断node数量是否达到数组大小*负载因子，达到则扩容2倍\n\n![](hashmap/put.png)\n\n```java\npublic V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n- 扩容，重新分配node位置\n\n  - 当数组未初始化，按照之前在threashold中保存的初始容量分配内存，没有就使用缺省值\n  - 当超过限制时，就扩充两倍，因为我们使用的是2次幂的扩展，所以，元素的位置要么是在原位置，要么是在原位置再移动原数组大小的位置\n\n  > 1. 进行扩容，会重新进行内存分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize\n  > 2. 扩容期间如果并发操作会存在线程安全问题\n\n![](hashmap/resize.png)\n\n```java\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n## 总结\n\n1. Java8中hash计算是通过key的hashCode()的高16位异或低16位实现的，既保证高低bit都能参与到hash的计算中，又不会有太大的开销。\n2. 数组大小n总是2的整数次幂，计算下标时直接( hash & n-1)\n3. 分配内存统一放在resize()中，包括创建后首次put时初始化数组和存放元素个数超过阈值时扩容。\n4. Java8引入红黑树，当链表长度达到8， 执行treeifyBin，当桶数量达到64时，将链表转为红黑树，否则，执行resize()。\n5. 判断Node是否符合，首先判断哈希值要相等，但因为哈希值不是唯一的，所以还要对比key是否相等，最好是同一个对象，能用＝＝对比，否则要用equals()\n\n## 建议\n\n1. String类型的key，不能用==判断或者可能有哈希冲突时，尽量减少长度\n2. 在集合视图迭代的时间与桶的数量加上映射的数量成正比，若迭代性能很重要，不要设置太高的初始容量或过小的负载因子\n3. 如果映射很多，创建HashMap时设置充足的初始容量(预计大小/负载因子 + 1）会比让其自动扩容获得更好的效率，一方面减少了碰撞可能，另一方面减少了resize的损耗\n4. 迭代器是fail-fast的，迭代器创建后如果进行了结构修改（增加或删除一个映射）且不是使用iterator的remove方法，会努力抛出`ConcurrentModificationException`，所以不能依赖该异常保证程序运行正确，而只可用于检测bug\n\n## 面试考察点\n\n1. 数组+单向链表（红黑树）\n2. hash算法\n3. put过程\n4. 扩容过程\n5. 为什么2倍扩容\n6. 线程不安全原因\n7. 有哪些改进的点\n\n>参考链接：\n>\n>https://blog.csdn.net/qazwyc/article/details/76686915","tags":["hashmap"],"categories":["源码分析"]},{"title":"java代码优化建议","url":"/2018/09/28/java-code-optimize/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](java-code-optimize/p7.jpg )\n\n> 总结日常Java开发常见优化策略，持续更新。\n\n### 尽可能使用局部变量\n\n调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中，速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。\n\n### 及时关闭流\n\nJava编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。而释放资源最好的地方就是`finally`代码块。\n\n### 尽量减少对变量的重复计算\n\n明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：\n\n```\nfor (int i = 0; i < list.size(); i++){\n\t...\n}\n```\n\n建议替换为：\n\n```\nfor (int i = 0, length = list.size(); i < length; i++){\n\t...\n}\n```\n\n这样，在list.size()很大的时候，就减少了很多的消耗\n\n### 尽量采用懒加载的策略，即在需要的时候才创建\n\n例如：\n\n```\nString str = \"aaa\";\nif (i == 1){\n　　list.add(str);\n}\n```\n\n建议替换为：\n\n```\nif (i == 1){\n　　String str = \"aaa\";\n　　list.add(str);\n}\n```\n\n### 慎用异常\n\n异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为`fillInStackTrace()`的本地同步方法，`fillInStackTrace()`方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。\n\n### 如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度\n\n比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：\n\n- StringBuilder()　　　　     // 默认分配16个字符的空间\n- StringBuilder(int size)　　// 默认分配size个字符的空间\n- StringBuilder(String str)　// 默认分配16个字符+str.length()个字符空间\n\n可以通过类（这里指的不仅仅是上面的StringBuilder）的构造函数来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中----这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：\n\n- 在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间\n- 把原来的4096个字符拷贝到新的的字符数组中去\n\n这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，**像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0**。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。\n\n### 当复制大量数据时，使用System.arraycopy()命令\n\n### 乘法和除法使用移位操作\n\n例如：\n\n```\nfor (val = 0; val < 100000; val += 5){\n　　a = val * 8;\n　　b = val / 2;\n}\n```\n\n用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： \n\n```\nfor (val = 0; val < 100000; val += 5){\n　　a = val << 3;\n　　b = val >> 1;\n}\n```\n\n移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。\n\n### 循环内不要不断创建对象引用\n\n例如：\n\n```\nfor (int i = 1; i <= count; i++){\n    Object obj = new Object();    \n}\n```\n\n这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：\n\n```\nObject obj = null;\nfor (int i = 0; i <= count; i++){\n    obj = new Object();\n}\n```\n\n这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。\n\n### 基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList\n\n### 尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销\n\n### 尽量避免随意使用静态变量\n\n要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：\n\n```\npublic class A{\n    private static B b = new B();  \n}\n```\n\n此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止\n\n### 及时清除不再需要的会话\n\n为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n> 参考文章：\n>\n> https://www.cnblogs.com/xrq730/p/4865416.html","tags":["优化"],"categories":["总结"]},{"title":"git常用命令","url":"/2018/09/27/git-commands/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](git-commands/words4.jpg)\n\n> 资源列表：\n>\n> [Git Book](https://git-scm.com/book/zh/v2)\n>\n> [深入浅出Git教程（转载）](https://www.cnblogs.com/syp172654682/p/7689328.html)\n>\n> [Git使用详细教程](http://www.admin10000.com/document/5374.html)\n\n## 名词介绍\n\n![](git-commands/git1.png)\n\n>  **`Workspace`**：工作区\n>\n>  **`Index/Stage`**：暂存区，也叫索引 \n>\n>  **`Repository`**：仓库区（或本地仓库），也存储库 \n>\n>  **`Remote`**：远程仓库\n\n理解这些名词，在脑中形成知识体系，便于理解下面具体命令。\n\n## git常用命令\n\n### 创建SSH Key\n\n```shell\n$ ssh-keygen -t rsa -C \"youremail@example.com\"\n```\n\n### 仓库\n\n```shell\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n### 增加/删除文件\n\n```shell\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n### 代码提交\n\n```shell\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n### 分支\n\n```shell\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n\n### 标签\n\n```shell\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n### 查看信息\n\n```shell\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n### 远程同步\n\n```shell\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n### 撤销\n\n```shell\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n## 常用技巧\n\n### help命令\n\n```shell\n$ git --help\n```\n\n![](git-commands/git3.png)\n\n### status命令\n\n当你不知道该干嘛的时候，就可以`git status`一下，他就会提示展示出当前文件状态以及给出建议，这样就不会懵逼了>_>\n\n```shell\n$ git status\n```\n\n![](git-commands/git2.png)","tags":["linux命令"],"categories":["总结"]},{"title":"面试之---工具使用相关","url":"/2018/09/16/interview-tools/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](interview-tools/interview.png)\n\n> 持续维护java面试题系列博文，发现好的面试题会更新进来。总结的并不只是如何回答面试官，而是这道题涉及到的知识点，明白了相关知识点和面试官要问的点，回答起来就不是问题了。\n\n## IDEA\n\n## Git/SVN\n\n### Git Flow\n\n## Maven/Gradle\n\n### Maven的scope\n\n`compile`：默认的scope，运行期有效，需要打入包中。\n\n`provided`：编译期有效，运行期不需要提供，不会打入包中。\n\n`runtime`：编译不需要，在运行期有效，需要导入包中。（接口与实现分离）\n\n`test`：测试需要，不会打入包中。\n\n`system`：非本地仓库引入、存在系统的某个路径下的jar。（一般不使用）\n\n## Jenkins/Hudson\n\n## Docker\n\n## Kubernetes\n\n## Shell\n\n## ELK\n\n","tags":["工具"],"categories":["interview"]},{"title":"面试之---数据库相关","url":"/2018/09/16/interview-db/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](interview-db/interview.png)\n\n> 持续维护java面试题系列博文，发现好的面试题会更新进来。总结的并不只是如何回答面试官，而是这道题涉及到的知识点，明白了相关知识点和面试官要问的点，回答起来就不是问题了。\n\n","tags":["数据库"],"categories":["interview"]},{"title":"面试之---其他细小知识点汇总","url":"/2018/09/16/interview-others/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](interview-others/interview.png)\n\n> 持续维护java面试题系列博文，发现好的面试题会更新进来。总结的并不只是如何回答面试官，而是这道题涉及到的知识点，明白了相关知识点和面试官要问的点，回答起来就不是问题了。\n\n## XML\n\n###  `XML`文档定义有几种形式？它们之间有何本质区别？解析`XML`文档有哪几种方式？\n\n`XML`文档定义分为`DTD`和`Schema`两种形式，二者都是对`XML`语法的约束，其本质区别在于`Schema`本身也是一个`XML`文件，可以被`XML`解析器解析，而且可以为`XML`承载的数据定义类型，约束能力较之`DTD`更强大。对`XML`的解析主要有`DOM`（文档对象模型，`Document Object Model`）、`SAX`（`Simple API for XML`）和`StAX`（Java 6中引入的新的解析XML的方式，`Streaming API for XML`），其中`DOM`处理大型文件时其性能下降的非常厉害，这个问题是由`DOM`树结构占用的内存较多造成的，而且`DOM`解析方式必须在解析文件之前把整个文档装入内存，适合对`XML`的随机访问（典型的用空间换取时间的策略）；`SAX`是事件驱动型的`XML`解析方式，它顺序读取`XML`文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理`XML`文件，适合对`XML`的顺序访问；顾名思义，`StAX`把重点放在流上，实际上`StAX`与其他解析方式的本质区别就在于应用程序能够把`XML`作为一个事件流来处理。将`XML`作为一组事件来处理的想法并不新颖（`SAX`就是这样做的），但不同之处在于`StAX`允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。\n\n## JSP\n\n### 为什么热加载技术没有广泛应用：\n\n类变了，里面的变量保存的信息变了，不可用了，差生大量垃圾，高并发场景不适用\n\n### JSP有哪些内置对象？作用分别是什么？\n\nJSP有9个内置对象：  \n\n- `request`：封装客户端的请求，其中包含来自GET或POST请求的参数；  \n- `response`：封装服务器对客户端的响应；\n- `pageContext`：通过该对象可以获取其他对象；\n- `session`：封装用户会话的对象；\n- `application`：封装服务器运行环境的对象；\n- `out`：输出服务器响应的输出流对象；\n- `config`：Web应用的配置对象；\n- `page`：JSP页面本身（相当于Java程序中的this）； \n- `exception`：封装页面抛出异常的对象。\n\n> **补充：**如果用`Servlet`来生成网页中的动态内容无疑是非常繁琐的工作，另一方面，所有的文本和HTML标签都是硬编码，即使做出微小的修改，都需要进行重新编译。`JSP`解决了`Servlet`的这些问题，它是`Servlet`很好的补充，可以专门用作为用户呈现视图（View），而`Servlet`作为控制器（Controller）专门负责处理用户请求并转发或重定向到某个页面。基于Java的Web开发很多都同时使用了`Servlet`和`JSP`。`JSP`页面其实是一个`Servlet`，能够运行`Servlet`的服务器（`Servlet`容器）通常也是`JSP`容器，可以提供`JSP`页面的运行环境，Tomcat就是一个`Servlet`/`JSP`容器。第一次请求一个`JSP`页面时，`Servlet`/`JSP`容器首先将`JSP`页面转换成一个`JSP`页面的实现类，这是一个实现了`JspPage`接口或其子接口`HttpJspPage`的Java类。`JspPage`接口是`Servlet`的子接口，因此每个`JSP`页面都是一个`Servlet`。转换成功后，容器会编译`Servlet`类，之后容器加载和实例化Java字节码，并执行它通常对`Servlet`所做的生命周期操作。对同一个`JSP`页面的后续请求，容器会查看这个`JSP`页面是否被修改过，如果修改过就会重新转换并重新编译并执行。如果没有则执行内存中已经存在的`Servlet`实例。我们可以看一段`JSP`代码对应的Java程序就知道一切了，而且9个内置对象的神秘面纱也会被揭开。\n\n### JSP和Servlet是什么关系？ \n\nServlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。\n\n### 讲解JSP中的四种作用域。\n\nJSP中的四种作用域包括`page`、`request`、`session`和`application`，具体来说：\n\n- `page`代表与一个页面相关的对象和属性。\n- `request`代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。\n- `session`代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。\n- `application`代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。\n\n### JSP中的静态包含和动态包含有什么区别？\n\n静态包含是通过JSP的`include`指令包含页面，动态包含是通过JSP标准动作`<jsp:forward>`包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的\"`contentType`\"属性应保持一致，因为两个页面会合二为一，只产生一个class文件，因此被包含页面发生的变动再包含它的页面更新前不会得到更新。动态包含是运行时包含，可以向被包含的页面传递参数，包含页面和被包含页面是独立的，会编译出两个class文件，如果被包含的页面不存在，不会产生编译错误，也不影响页面其他部分的执行。代码如下所示：\n\n```JSP\n<%-- 静态包含 --%>\n<%@ include file=\"...\" %>\n\n<%-- 动态包含 --%>\n<jsp:include page=\"...\">\n    <jsp:param name=\"...\" value=\"...\" />\n</jsp:include>\n```\n\n## Servlet\n\n### Servlet接口中有哪些方法？\n\nServlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关： \n\n```java\nvoid init(ServletConfig config) throws ServletException\nvoid service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException\nvoid destory()\njava.lang.String getServletInfo()\nServletConfig getServletConfig() \n```\n\nWeb容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其`init()`方法进行Servlet的初始化；请求到达时调用Servlet的`service()`方法，`service()`方法会根据需要调用与请求对应的`doGet`或`doPost`等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的`destroy()`方法。\n\n### 过滤器有哪些作用和用法？ \n\nJava Web开发中的过滤器（filter）是从Servlet 2.3规范开始增加的功能，并在Servlet 2.4规范中得到增强。对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器中你可以对响应的内容进行转换，然后再将响应发送到客户端。\n\n常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。\n\n和过滤器相关的接口主要有：`Filter`、`FilterConfig`和`FilterChain`。\n\n### 监听器有哪些作用和用法？ \n\nJava Web开发中的监听器（listener）就是`application`、`session`、`request`三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示： \n- `ServletContextListener`：对Servlet上下文的创建和销毁进行监听。 \n- `ServletContextAttributeListener`：监听Servlet上下文属性的添加、删除和替换。 \n- `HttpSessionListener`：对Session的创建和销毁进行监听。\n\n> 补充：session的销毁有两种情况：1). session超时（可以在web.xml中通过<session-config>/<session-timeout>标签配置超时时间）；2). 通过调用session对象的invalidate()方法使session失效。\n\n- `HttpSessionAttributeListener`：对Session对象中属性的添加、删除和替换进行监听。 \n- `ServletRequestListener`：对请求对象的初始化和销毁进行监听。 \n- `ServletRequestAttributeListener`：对请求对象属性的添加、删除和替换进行监听。\n\n### 服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()方法？\n\nHTML的`<form>`元素有一个`method`属性，用来指定提交表单的方式，其值可以是get或post。我们自定义的Servlet一般情况下会重写`doGet()`或`doPost()`两个方法之一或全部，如果是GET请求就调用`doGet()`方法，如果是POST请求就调用`doPost()`方法，那为什么为什么这样呢？我们自定义的Servlet通常继承自`HttpServlet`，`HttpServlet`继承自`GenericServlet`并重写了其中的`service()`方法，这个方法是Servlet接口中定义的。`HttpServlet`重写的`service()`方法会先获取用户请求的方法，然后根据请求方法调用`doGet()`、`doPost()`、doPut()、doDelete()等方法，如果在自定义Servlet中重写了这些方法，那么显然会调用重写过的（自定义的）方法，这显然是对模板方法模式的应用（如果不理解，请参考阎宏博士的《Java与模式》一书的第37章）。当然，自定义Servlet中也可以直接重写service()方法，那么不管是哪种方式的请求，都可以通过自己的代码进行处理，这对于不区分请求方法的场景比较合适。 \n\n### Servlet中如何获取用户提交的查询参数或表单数据？\n\n可以通过请求对象（`HttpServletRequest`）的`getParameter()`方法通过参数名获得参数值。如果有包含多个值的参数（例如复选框），可以通过请求对象的`getParameterValues()`方法获得。当然也可以通过请求对象的`getParameterMap()`获得一个参数名和参数值的映射（Map）。\n\n### Servlet中如何获取用户配置的初始化参数以及服务器上下文参数？\n\n可以通过重写`Servlet`接口的`init(ServletConfig)`方法并通过`ServletConfig`对象的`getInitParameter()`方法来获取`Servlet`的初始化参数。可以通过`ServletConfig`对象的`getServletContext()`方法获取`ServletContext`对象，并通过该对象的`getInitParameter()`方法来获取服务器上下文参数。当然，`ServletContext`对象也在处理用户请求的方法（如`doGet()`方法）中通过请求对象的`getServletContext()`方法来获得。\n\n\n\n## Web\n\n### web.xml文件中可以配置哪些内容？ \n\nweb.xml用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置：\n\n1. 配置Spring上下文加载监听器加载Spring配置文件并创建IoC容器：\n\n    ```XML\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:applicationContext.xml</param-value>\n    </context-param>\n    \n    <listener>\n        <listener-class>\n            org.springframework.web.context.ContextLoaderListener\n        </listener-class>\n    </listener>\n    ```\n\n2. 配置Spring的OpenSessionInView过滤器来解决延迟加载和Hibernate会话关闭的矛盾：\n\n    ```XML\n    <filter>\n        <filter-name>openSessionInView</filter-name>\n        <filter-class>\n            org.springframework.orm.hibernate3.support.OpenSessionInViewFilter\n        </filter-class>\n    </filter>\n    \n    <filter-mapping>\n        <filter-name>openSessionInView</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    ```\n\n3. 配置会话超时时间为10分钟：\n\n    ```xml\n    <session-config>\n        <session-timeout>10</session-timeout>\n    </session-config>\n    ```\n\n4. 配置404和Exception的错误页面：\n\n    ```XML\n    <error-page>\n        <error-code>404</error-code>\n        <location>/error.jsp</location>\n    </error-page>\n    \n    <error-page>\n        <exception-type>java.lang.Exception</exception-type>\n        <location>/error.jsp</location>\n    </error-page>\n    ```\n\n5. 配置安全认证方式：\n\n    ```XML\n    <security-constraint>\n        <web-resource-collection>\n            <web-resource-name>ProtectedArea</web-resource-name>\n            <url-pattern>/admin/*</url-pattern>\n            <http-method>GET</http-method>\n            <http-method>POST</http-method>\n        </web-resource-collection>\n        <auth-constraint>\n            <role-name>admin</role-name>\n        </auth-constraint>\n    </security-constraint>\n    \n    <login-config>\n        <auth-method>BASIC</auth-method>\n    </login-config>\n    \n    <security-role>\n        <role-name>admin</role-name>\n    </security-role>\n    ```\n\n    > **说明：**对`Servlet`（小服务）、`Listener`（监听器）和`Filter`（过滤器）等Web组件的配置，Servlet 3规范提供了基于注解的配置方式，可以分别使用@`WebServlet`、@`WebListener`、@`WebFilter`注解进行配置。 \n    >\n    > ------\n    >\n    > 补充：\n    >\n    > 如果Web提供了有价值的商业信息或者是敏感数据，那么站点的安全性就是必须考虑的问题。安全认证是实现安全性的重要手段，认证就是要解决“Are you who you say you are?”的问题。认证的方式非常多，简单说来可以分为三类： \n    >\n    > - What you know?  — 口令 \n    > - What you have? — 数字证书（U盾、密保卡） \n    > - Who you are? —  指纹识别、虹膜识别 \n    >\n    > 在Tomcat中可以通过建立安全套接字层（Secure Socket Layer, SSL）以及通过基本验证或表单验证来实现对安全性的支持。\n\n\n## Others\n\n### 谈一谈测试驱动开发（TDD）的好处以及你的理解。\n\nTDD是指在编写真正的功能实现代码之前先写测试代码，然后根据需要重构实现代码。在JUnit的作者Kent Beck的大作《测试驱动开发：实战与模式解析》（Test-Driven Development: by Example）一书中有这么一段内容：“消除恐惧和不确定性是编写测试驱动代码的重要原因”。因为编写代码时的恐惧会让你小心试探，让你回避沟通，让你羞于得到反馈，让你变得焦躁不安，而TDD是消除恐惧、让Java开发者更加自信更加乐于沟通的重要手段。TDD会带来的好处可能不会马上呈现，但是你在某个时候一定会发现，这些好处包括： \n\n- 更清晰的代码 — 只写需要的代码 \n- 更好的设计 \n- 更出色的灵活性 — 鼓励程序员面向接口编程 \n- 更快速的反馈 — 不会到系统上线时才知道bug的存在\n\n> **补充：**敏捷软件开发的概念已经有很多年了，而且也部分的改变了软件开发这个行业，TDD也是敏捷开发所倡导的。\n\nTDD可以在多个层级上应用，包括单元测试（测试一个类中的代码）、集成测试（测试类之间的交互）、系统测试（测试运行的系统）和系统集成测试（测试运行的系统包括使用的第三方组件）。TDD的实施步骤是：红（失败测试）- 绿（通过测试） - 重构。关于实施TDD的详细步骤请参考另一篇文章[《测试驱动开发之初窥门径》](http://blog.csdn.net/jackfrued/article/details/44433249)。 \n在使用TDD开发时，经常会遇到需要被测对象需要依赖其他子系统的情况，但是你希望将测试代码跟依赖项隔离，以保证测试代码仅仅针对当前被测对象或方法展开，这时候你需要的是测试替身。测试替身可以分为四类： \n\n- 虚设替身：只传递但是不会使用到的对象，一般用于填充方法的参数列表 \n- 存根替身：总是返回相同的预设响应，其中可能包括一些虚设状态 \n- 伪装替身：可以取代真实版本的可用版本（比真实版本还是会差很多） \n- 模拟替身：可以表示一系列期望值的对象，并且可以提供预设响应 \n\nJava世界中实现模拟替身的第三方工具非常多，包括`EasyMock`、`Mockito`、`jMock`等。\n\n### get和post请求的区别？\n\n- get请求用来从服务器上获得资源，而post是用来向服务器提交数据；  \n- get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用\"?\"连接，而各个变量之间使用\"&\"连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；  \n- get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式；  \n- 使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；  \n- get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是\"%20\"。\n\n### 实现会话跟踪的技术有哪些？\n\n由于`HTTP`协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。 \n\n- URL 重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 \n- 设置表单隐藏域：将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。 \n\n这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改URL或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。 \n\n- `cookie`：cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没有了；另一种是将信息存储在一个临时文件中，并设置存在的时间。当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份。会话中可以为用户保存信息。会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的。如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪。当然，在使用cookie时要注意几点：首先不要在cookie中存放敏感信息；其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中；再者浏览器通常只允许一个站点最多存放20个cookie。当然，和用户会话相关的其他信息（除了会话ID）也可以存在cookie方便进行会话跟踪。 \n- `HttpSession`：在所有会话跟踪技术中，`HttpSession`对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建`HttpSession`，每个用户可以访问他自己的`HttpSession`。可以通过`HttpServletRequest`对象的`getSession`方法获得`HttpSession`，通过`HttpSession`的`setAttribute`方法可以将一个值放在`HttpSession`中，通过调用`HttpSession`对象的`getAttribute`方法，同时传入属性名就可以获取保存在`HttpSession`中的对象。与上面三种方式不同的是，`HttpSession`放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的`Servlet`容器可以在内存将满时将`HttpSession`中的对象移到其他存储设备中，但是这样势必影响性能。添加到`HttpSession`中的值可以是任意Java对象，这个对象最好实现了`Serializable`接口，这样`Servlet`容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。\n\n> **补充：**HTML5中可以使用Web Storage技术通过JavaScript来保存数据，例如可以使用localStorage和sessionStorage来保存用户会话的信息，也能够实现会话跟踪。\n\n### 说一下表达式语言（EL）的隐式对象及其作用。\n\nEL的隐式对象包括：`pageContext`、`initParam`（访问上下文参数）、`param`（访问请求参数）、`paramValues`、`header`（访问请求头）、`headerValues`、`cookie`（访问cookie）、`applicationScope`（访问application作用域）、`sessionScope`（访问session作用域）、`requestScope`（访问request作用域）、`pageScope`（访问page作用域）。\n\n用法如下所示：\n\n```JSP\n${pageContext.request.method}\n${pageContext[\"request\"][\"method\"]}\n${pageContext.request[\"method\"]}\n${pageContext[\"request\"].method}\n${initParam.defaultEncoding}\n${header[\"accept-language\"]}\n${headerValues[\"accept-language\"][0]}\n${cookie.jsessionid.value}\n${sessionScope.loginUser.username}123456789\n```\n\n> **补充：**表达式语言的.和[]运算作用是一致的，唯一的差别在于如果访问的属性名不符合Java标识符命名规则，例如上面的accept-language就不是一个有效的Java标识符，那么这时候就只能用[]运算符而不能使用.运算符获取它的值\n\n### 如何设置请求的编码以及响应内容的类型？\n\n通过请求对象（`ServletRequest`）的`setCharacterEncoding(String)`方法可以设置请求的编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java程序都使用统一的编码，最好的选择当然是`UTF-8`；通过响应对象（`ServletResponse`）的`setContentType(String)`方法可以设置响应内容的类型，当然也可以通过`HttpServletResponsed`对象的`setHeader(String, String)`方法来设置。\n\n> **说明：**现在如果还有公司在面试的时候问JSP的声明标记、表达式标记、小脚本标记这些内容的话，这样的公司也不用去了，其实JSP内置对象、JSP指令这些东西基本上都可以忘却了。\n\n### 解释一下网络应用的模式及其特点。\n\n典型的网络应用模式大致有三类：B/S、C/S、P2P。其中B代表浏览器（Browser）、C代表客户端（Client）、S代表服务器（Server），P2P是对等模式，不区分客户端和服务器。B/S应用模式中可以视为特殊的C/S应用模式，只是将C/S应用模式中的特殊的客户端换成了浏览器，因为几乎所有的系统上都有浏览器，那么只要打开浏览器就可以使用应用，没有安装、配置、升级客户端所带来的各种开销。P2P应用模式中，成千上万台彼此连接的计算机都处于对等的地位，整个网络一般来说不依赖专用的集中服务器。网络中的每一台计算机既能充当网络服务的请求者，又对其它计算机的请求作出响应，提供资源和服务。通常这些资源和服务包括：信息的共享和交换、计算资源（如CPU的共享）、存储共享（如缓存和磁盘空间的使用）等，这种应用模式最大的阻力安全性、版本等问题，目前有很多应用都混合使用了多种应用模型，最常见的网络视频应用，它几乎把三种模式都用上了。\n\n> **补充：**此题要跟\"电子商务模式\"区分开，因为有很多人被问到这个问题的时候马上想到的是B2B（如阿里巴巴）、B2C（如当当、亚马逊、京东）、C2C（如淘宝、拍拍）、C2B（如威客）、O2O（如美团、饿了么）。\n\n\n\n\n\n### 如果让你设计一个XXX，你怎么做？\n\n\n\n### 遇到过什么比较难的问题，怎么解决的？\n\n\n\n### 在哪个技术点研究的比较深入？\n\n\n\n### 目前系统支撑的用户量是多少，假如用户量提升10倍，系统会出现什么样的问题，如何重新设计系统？\n\n\n\n\n\n> 参考链接：\n>\n> https://blog.csdn.net/jackfrued/article/details/44921941","tags":["总结"],"categories":["interview"]},{"title":"面试之---框架相关","url":"/2018/09/16/interview-framework/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](interview-framework/interview.png)\n\n> 持续维护java面试题系列博文，发现好的面试题会更新进来。总结的并不只是如何回答面试官，而是这道题涉及到的知识点，明白了相关知识点和面试官要问的点，回答起来就不是问题了。\n\n## 综合\n\n### 什么是ORM？\n\n对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。\n\n### 持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？\n\n所谓\"持久\"就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。\n\n持久层设计的目标包括： \n\n- 数据存储逻辑的分离，提供抽象化的数据访问接口。 \n- 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。 \n- 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。 \n- 数据抽象，提供更面向对象的数据操作。\n\n持久层框架有： [Hibernate](http://hibernate.org) 、[MyBatis](http://blog.mybatis.org) 、[Spring Data](http://projects.spring.io/spring-data/) 、[TopLink](http://www.oracle.com/technetwork/cn/middleware/toplink/overview/index.html) 、[Guzz](https://code.google.com/p/guzz/) 、[jOOQ](http://www.jooq.org) 、[ActiveJDBC](https://code.google.com/p/activejdbc/)\n\n## Spring\n\n### Spring Framework\n\n#### Spring Framework 中有多少个模块，它们分别是什么？\n\n\n\n#### 什么是IoC和DI？DI是如何实现的？ \n\n`IoC`叫控制反转，是Inversion of Control的缩写，`DI`（Dependency Injection）叫依赖注入，是对`IoC`更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的\"控制反转\"就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。`IoC`体现了好莱坞原则 - \"Don’t call me, we will call you\"。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。`DI`是对`IoC`更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。\n\n举个例子：一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。\n\n依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。\n\n#### Spring中Bean的作用域有哪些？\n\n在Spring的早期版本中，仅有两个作用域：`singleton`和`prototype`，前者表示Bean以单例的方式存在；后者表示每次从容器中调用Bean时，都会返回一个新的实例，`prototype`通常翻译为原型。\n\n> **补充：**设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。\n\nSpring 2.x中针对`WebApplicationContext`新增了3个作用域，分别是：`request`（每次HTTP请求都会创建一个新的Bean）、`session`（同一个`HttpSession`共享同一个Bean，不同的`HttpSession`使用不同的Bean）和`globalSession`（同一个全局Session共享一个Bean）。\n\n> **说明：**单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有`Connection`这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的`ThreadLocal`对非线程安全的对象进行了特殊处理。\n`ThreadLocal`为解决多线程程序的并发问题提供了一种新的思路。`ThreadLocal`，顾名思义是线程的一个本地化对象，当工作于多线程中的对象使用`ThreadLocal`维护变量时，`ThreadLocal`为每个使用该变量的线程分配一个独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不影响其他线程所对应的副本。从线程的角度看，这个变量就像是线程的本地变量。\n\n`ThreadLocal`类非常简单好用，只有四个方法，能用上的也就是下面三个方法： \n\n- `void set(T value)`：设置当前线程的线程局部变量的值。 \n- `T get()`：获得当前线程所对应的线程局部变量的值。 \n- `void remove()`：删除当前线程中线程局部变量的值。\n\n`ThreadLocal`是如何做到为每一个线程维护一份独立的变量副本的呢？在`ThreadLocal`类中有一个Map，键为线程对象，值是其线程对应的变量的副本，自己要模拟实现一个`ThreadLocal`类其实并不困难，代码如下所示：\n\n```java\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MyThreadLocal<T> {\n    private Map<Thread, T> map = Collections.synchronizedMap(new HashMap<Thread, T>());\n\n    public void set(T newValue) {\n        map.put(Thread.currentThread(), newValue);\n    }\n\n    public T get() {\n        return map.get(Thread.currentThread());\n    }\n\n    public void remove() {\n        map.remove(Thread.currentThread());\n    }\n} \n```\n\n#### Spring中自动装配的方式有哪些？ \n\n1. no：不进行自动装配，手动设置Bean的依赖关系。 \n2. byName：根据Bean的名字进行自动装配。 \n3. byType：根据Bean的类型进行自动装配。 \n4. constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。 \n5. autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。\n\n> **说明：**自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。\n\n基于注解的方式：\n\n使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，。在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：\n\n如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；\n\n如果查询的结果不止一个，那么@Autowired会根据名称来查找；\n\n如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。\n\n@Autowired可用于：构造函数、成员变量、Setter方法\n\n> 注：@Autowired和@Resource之间的区别\n\n(1) @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。\n\n(2) @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。\n\n#### 构造器注入的好处\n\n- 保证依赖不可变（final关键字）\n- 保证依赖不为空（省去了我们对其检查）\n- 保证返回客户端（调用）的代码的时候是完全初始化的状态\n- 避免了循环依赖\n- 提升了代码的可复用性\n\n当有一个依赖有多个实现的使用，推荐使用field注入或者setter注入的方式来指定注入的类型\n\n#### Spring中如何使用注解来配置Bean？有哪些相关的注解？ \n\n首先需要在Spring配置文件中增加如下配置：\n\n```xml\n<context:component-scan base-package=\"org.example\"/>\n```\n\n然后可以用`@Component`、`@Controller`、`@Service`、`@Repository`注解来标注需要由Spring IoC容器进行对象托管的类。这几个注解没有本质区别，只不过`@Controller`通常用于控制器，`@Service`通常用于业务逻辑类，`@Repository`通常用于仓储类（例如我们的DAO实现类），普通的类用`@Component`来标注。\n\n#### 选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？\n\n可以从以下几个方面作答：  \n\n- 非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。\n- `IoC`容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神\"不要重复的发明轮子\"。\n- `AOP`（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。\n- MVC：Spring的MVC框架是非常优秀的，从各个方面都可以甩Struts 2几条街，为Web表示层提供了更好的解决方案。\n- 事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。  - 其他：选择Spring框架的原因还远不止于此，Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，你甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。\n\n#### 阐述Spring框架中Bean的生命周期？\n\n1. Spring IoC容器找到关于Bean的定义并实例化该Bean。\n2. Spring IoC容器对Bean进行依赖注入。\n3. 如果Bean实现了`BeanNameAware`接口，则将该Bean的id传给`setBeanName`方法。\n4. 如果Bean实现了`BeanFactoryAware`接口，则将`BeanFactory`对象传给`setBeanFactory`方法。\n5. 如果Bean实现了`BeanPostProcessor`接口，则调用其`postProcessBeforeInitialization()`方法。\n6. 如果Bean实现了`InitializingBean`接口，则调用其`afterPropertySet`方法。\n7. 如果有和Bean关联的`BeanPostProcessors`对象，则这些对象的`postProcessAfterInitialization`方法被调用。\n8. 当销毁Bean实例时，如果Bean实现了`DisposableBean`接口，则调用其`destroy`方法。\n\n#### BeanFactory和FactoryBean的区别？\n\n#### 解释一下什么叫AOP（面向切面编程）？\n\n`AOP`（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。\n\n#### 你是如何理解\"横切关注\"这个概念的？\n\n\"横切关注\"是会影响到整个应用程序的关注功能，它跟正常的业务逻辑是正交的，没有必然的联系，但是几乎所有的业务逻辑都会涉及到这些关注功能。通常，事务、日志、安全性等关注就是应用中的横切关注功能。\n\n#### 你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？\n\n- 连接点（`Joinpoint`）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。 \n\n- 切点（`Pointcut`）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。 \n\n- 增强（`Advice`）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：`BeforeAdvice`、`AfterReturningAdvice`、`ThrowsAdvice`等。很多资料上将增强译为“通知”，这明显是个词不达意的翻译，让很多程序员困惑了许久。\n\n  > **说明：** `Advice`在国内的很多书面资料中都被翻译成\"通知\"，但是很显然这个翻译无法表达其本质，有少量的读物上将这个词翻译为\"增强\"，这个翻译是对`Advice`较为准确的诠释，我们通过`AOP`将横切关注功能加到原有的业务逻辑上，这就是对原有业务逻辑的一种增强，这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强。\n\n- 引介（`Introduction`）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的未该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。 \n\n- 织入（`Weaving`）：织入是将增强添加到目标类具体连接点上的过程，`AOP`有三种织入方式：\n\n  - 编译期织入：需要特殊的Java编译期（例如`AspectJ`的ajc）；\n  - 装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；\n  - 运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。 \n\n- 切面（`Aspect`）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。\n\n  > **补充：**代理模式是GoF提出的23种设计模式中最为经典的模式之一，代理模式是对象的结构模式，它给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。简单的说，代理对象可以完成比原对象更多的职责，当需要为原对象添加横切关注功能时，就可以使用原对象的代理对象。我们在打开Office系列的Word文档时，如果文档中有插图，当文档刚加载时，文档中的插图都只是一个虚框占位符，等用户真正翻到某页要查看该图片时，才会真正加载这张图，这其实就是对代理模式的使用，代替真正图片的虚框就是一个虚拟代理；Hibernate的load方法也是返回一个虚拟代理对象，等用户真正需要访问对象的属性时，才向数据库发出SQL语句获得真实对象。\n\n#### Spring的AOP理解\n\nOOP面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。\n\nAOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。\n\nAOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。\n\n（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。\n\n（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。\n\nSpring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：\n\n- JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象。\n- 如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。\n\n（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。\n\nInvocationHandler 的 invoke(Object  proxy,Method  method,Object[] args)：proxy是最终生成的代理实例;  method 是被代理目标实例的某个具体方法;  args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。\n\n#### Spring事务的实现方式和实现原理\n\nSpring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。\n\n- Spring事务的种类：spring支持编程式事务管理和声明式事务管理两种方式\n  - 编程式事务管理使用TransactionTemplate。\n  - 声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式，使业务代码不受污染，只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。\n- spring的事务传播行为：spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。\n  - `PROPAGATION_REQUIRED`：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。\n  - `PROPAGATION_SUPPORTS`：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。\n  - `PROPAGATION_MANDATORY`：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n  - `PROPAGATION_REQUIRES_NEW`：创建新事务，无论当前存不存在事务，都创建新事务。\n  - `PROPAGATION_NOT_SUPPORTED`：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n  - `PROPAGATION_NEVER`：以非事务方式执行，如果当前存在事务，则抛出异常。\n  - `PROPAGATION_NESTED`：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。\n\n- Spring中的隔离级别：\n  - `ISOLATION_DEFAULT`：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。\n  - `ISOLATION_READ_UNCOMMITTED`：读未提交，允许另外一个事务可以看到这个事务未提交的数据。\n  - `ISOLATION_READ_COMMITTED`：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。\n  - `ISOLATION_REPEATABLE_READ`：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。\n  - `ISOLATION_SERIALIZABLE`：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。\n\n### SpringMVC\n\n#### Spring MVC的工作原理是怎样的？ \n\n1. 客户端的所有请求都交给前端控制器`DispatcherServlet`来处理，它会负责调用系统的其他模块来真正处理用户的请求。\n2. `DispatcherServlet`收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及`HandlerMapping`的配置找到处理该请求的`Handler`（任何一个对象都可以作为请求的Handler）。  \n3. 在这个地方Spring会通过`HandlerAdapter`对该处理器进行封装。\n4. `HandlerAdapter`是一个适配器，它用统一的接口对各种`Handler`中的方法进行调用。\n5. Handler完成对用户请求的处理后，会返回一个`ModelAndView`对象给`DispatcherServlet`，`ModelAndView`顾名思义，包含了数据模型以及相应的视图的信息。`\n6. `ModelAndView`的视图是逻辑视图，`DispatcherServlet`还要借助`ViewResolver`完成从逻辑视图到真实视图对象的解析工作。`\n7. 当得到真正的视图对象后，`DispatcherServlet`会利用视图对象对模型数据进行渲染。\n8. 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。\n\n## Spring Boot\n\n### spring-boot-data-jpa\n\n#### Difference between save and saveAndFlush in Spring data jpa\n\nOn `saveAndFlush`, changes will be flushed to DB immediately in this command. With `save`, this is not necessarily true, and might stay just in memory, until `flush` or `commit` commands are issued.\n\nBut be aware, that even if you flush the changes in transaction and do not commit them, the changes still won't be visible to the outside transactions until the commit in this transaction.\n\nIn your case, you probably use some sort of transactions mechanism, which issues `commit`command for you if everything works out fine.\n\n## Spring Cloud\n\n## Hibernate\n\n### Hibernate中`SessionFactory`是线程安全的吗？`Session`是线程安全的吗（两个线程能够共享同一个Session吗）？\n\n`SessionFactory`对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。`SessionFactory`一般只会在启动的时候构建。对于应用程序，最好将`SessionFactory`通过单例模式进行封装以便于访问。`Session`是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。`Session`是由`SessionFactory`创建的，在任务完成之后它会被关闭。`Session`是持久层服务对外提供的主要接口。`Session`会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用`ThreadLocal`将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中`SessionFactory`的`getCurrentSession()`方法就可以做到。\n\n### Hibernate中Session的load和get方法的区别是什么？\n\n主要有以下三项区别： \n\n- 如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。 \n- get方法直接返回实体类对象，load方法返回实体类对象的代理。 \n- 在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。\n\n> **说明：**对于`load()`方法Hibernate认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过`get()`方法获取的数据可以不存在。\n\n### Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？\n\nHibernate的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态（detached），瞬时态的实例可以通过调用`save()`、`persist()`或者`saveOrUpdate()`方法变成持久态；游离态的实例可以通过调用 `update()`、`saveOrUpdate()`、`lock()`或者`replicate()`变成持久态。`save()`和`persist()`将会引发SQL的`INSERT`语句，而`update()`或`merge()`会引发`UPDATE`语句。`save()`和`update()`的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。`merge()`方法可以完成`save()`和`update()`方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于`persist()`方法，按照官方文档的说明：\n\n- `persist()`方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；\n- `persist()`方法保证当它在一个事务外部被调用的时候并不触发一个`INSERT`语句，当需要封装一个长会话流程的时候，`persist()`方法是很有必要的；\n- `save()`方法不保证第二条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。\n\n至于`lock()`方法和`update()`方法的区别，`update()`方法是把一个已经更改过的脱管状态的对象变成持久状态；`lock()`方法是把一个没有更改过的脱管状态的对象变成持久状态。\n\n### 阐述Session加载实体对象的过程\n\n`Session`加载实体对象的步骤是： \n\n- `Session`在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回； \n- 如果一级缓存没有命中，接下来`Session`会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null； \n- 如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回；\n- 如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null； \n- 根据映射配置和SQL语句得到`ResultSet`，并创建对应的实体对象；\n- 将对象纳入`Session`（一级缓存）的管理；\n- 如果有对应的拦截器，则执行拦截器的onLoad方法；\n- 如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存；\n- 返回数据对象。\n\n### 锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。\n\n有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。 \nHibernate支持悲观锁和乐观锁两种锁机制。\n\n- 悲观锁，顾名思义悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。`悲观锁`必须依赖数据库本身的锁机制才能真正保证数据访问的排他性。\n- 乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加1，然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的当前版本号则更新数据，否则认为是过期数据无法更新。\n\nHibernate中通过`Session`的`get()`和`load()`方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过XML或`@Version`注解进行配置。\n\n> **提示：**使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间换时间的策略。\n\n### 如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？\n\n延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用Session的`load()`方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。\n\n延迟加载与session关闭的矛盾一般可以这样处理： \n\n- 关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现\"no session or session was closed\"通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。 \n- 在session关闭之前先获取需要查询的数据，可以使用工具方法`Hibernate.isInitialized()`判断对象是否被加载，如果没有被加载则可以使用Hibernate.initialize()方法加载对象。 \n- 使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的`OpenSessionInViewFilter`和`OpenSessionInViewInterceptor`就是这种做法。\n\n### 简述Hibernate常见优化策略。\n\n这个问题应当挑自己使用过的优化策略回答，常用的有：  \n\n- 制定合理的缓存策略（二级缓存、查询缓存）。  \n- 采用合理的Session管理机制。 \n- 尽量使用延迟加载特性。\n- 设定合理的批处理参数。\n- 如果可以，选用UUID作为主键生成器。\n- 如果可以，选用基于版本号的乐观锁替代悲观锁。\n- 在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。\n- 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。\n\n### 谈一谈Hibernate的一级缓存、二级缓存和查询缓存。\n\nHibernate的`Session`提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实体、修改持久化实体时，`Session`并不会立即把这种改变提交到数据库，而是缓存在当前的`Session`中，除非显示调用了`Session`的`flush()`方法或通过`close()`方法关闭`Session`。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。  `SessionFactory`级别的二级缓存是全局性的，所有的`Session`可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，`SessionFactory`就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。  一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将`HQL`或`SQL`语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。\n\n### Hibernate中DetachedCriteria类是做什么的？\n\n`DetachedCriteria`和`Criteria`的用法基本上是一致的，但`Criteria`是由`Session`的`createCriteria()`方法创建的，也就意味着离开创建它的`Session`，`Criteria`就无法使用了。`DetachedCriteria`不需要`Session`就可以创建（使用`DetachedCriteria.forClass()`方法创建），所以通常也称其为离线的`Criteria`，在需要进行查询操作的时候再和`Session`绑定（调用其`getExecutableCriteria(Session)`方法），这也就意味着一个`DetachedCriteria`可以在需要的时候和不同的`Session`进行绑定。\n\n### @OneToMany注解的mappedBy属性有什么作用？\n\n`@OneToMany`用来配置一对多关联映射，但通常情况下，一对多关联映射都由多的一方来维护关联关系，例如学生和班级，应该在学生类中添加班级属性来维持学生和班级的关联关系（在数据库中是由学生表中的外键班级编号来维护学生表和班级表的多对一关系），如果要使用双向关联，在班级类中添加一个容器属性来存放学生，并使用`@OneToMany`注解进行映射，此时mappedBy属性就非常重要。如果使用XML进行配置，可以用<set>标签的`inverse=\"true\"`设置来达到同样的效果。\n\n## Mybatis\n\n### MyBatis中使用#和$书写占位符有什么区别？\n\n`#`将传入的数据都当成一个字符串，会对传入的数据自动加上引号；`$`将传入的数据直接显示生成在SQL中。注意：使用`$`占位符可能会导致SQL注射攻击，能用`#`的地方就不要使用`$`，写`order by`子句的时候应该用`$`而不是`#`。\n\n### 解释一下MyBatis中命名空间（namespace）的作用。\n\n在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。\n\n### MyBatis中的动态SQL是什么意思？\n\n对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，例如在58同城上面找房子，我们可能会指定面积、楼层和所在位置来查找房源，也可能会指定面积、价格、户型和所在位置来查找房源，此时就需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句，还好MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有： \n- `if` \n- `choose` / `when` / `otherwise` \n- `trim` \n- `where` \n- `set` \n- `foreach`\n\n下面是映射文件的片段。\n\n```XML\n    <select id=\"foo\" parameterType=\"Blog\" resultType=\"Blog\">\n        select * from t_blog where 1 = 1\n        <if test=\"title != null\">\n            and title = #{title}\n        </if>\n        <if test=\"content != null\">\n            and content = #{content}\n        </if>\n        <if test=\"owner != null\">\n            and owner = #{owner}\n        </if>\n   </select>\n```\n\n当然也可以像下面这些书写。\n\n```XML\n    <select id=\"foo\" parameterType=\"Blog\" resultType=\"Blog\">\n        select * from t_blog where 1 = 1 \n        <choose>\n            <when test=\"title != null\">\n                and title = #{title}\n            </when>\n            <when test=\"content != null\">\n                and content = #{content}\n            </when>\n            <otherwise>\n                and owner = \"owner1\"\n            </otherwise>\n        </choose>\n    </select>\n```\n\n再看看下面这个例子。\n\n```XML\n    <select id=\"bar\" resultType=\"Blog\">\n        select * from t_blog where id in\n        <foreach collection=\"array\" index=\"index\" \n            item=\"item\" open=\"(\" separator=\",\" close=\")\">\n            #{item}\n        </foreach>\n    </select>\n```\n\n### 说一下 mybatis 的一级缓存和二级缓存？\n\n一级缓存: 基于 `PerpetualCache` 的 `HashMap` 本地缓存，其存储作用域为 `Session`，当 `Session` flush 或 close 之后，该 `Session` 中的所有 `Cache` 就将清空，默认打开一级缓存。\n\n二级缓存与一级缓存其机制相同，默认也是采用 `PerpetualCache`，`HashMap` 存储，不同在于其存储作用域为 `Mapper(Namespace)`，并且可自定义存储源，如 `Ehcache`。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现`Serializable`序列化接口(可用来保存对象的状态),可在它的映射文件中配置`<cache/>` ；\n\n对于缓存数据更新机制，当某一个作用域(一级缓存 `Session`/二级缓存`Namespaces`)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。\n\n### mybatis和Hibernate的区别有哪些？\n\n（1）Mybatis和Hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。\n\n（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是Mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 \n\n（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用Hibernate开发可以节省很多代码，提高效率。 \n\n### Mybatis 有哪些执行器（Executor）？\n\nMybatis有三种基本的执行器（Executor）：\n\n`SimpleExecutor`：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。\n`ReuseExecutor`：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。\n`BatchExecutor`：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。\n\n## Dubbo\n\n## Zookeeper\n\n## MongoDB\n\n## Redis\n\n## ElasticSearch\n\n## Kafka\n\n## RibbitMQ\n\n## RocketMQ\n\n## ActiveMQ\n\n\n\n>参考链接：\n>\n>https://blog.csdn.net/jackfrued/article/details/44921941\n\n","tags":["框架"],"categories":["interview"]},{"title":"面试之---算法相关","url":"/2018/09/16/interview-algorithm/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](interview-algorithm/interview.jpg)\n\n> 持续维护java面试题系列博文，发现好的面试题会更新进来。总结的并不只是如何回答面试官，而是这道题涉及到的知识点，明白了相关知识点和面试官要问的点，回答起来就不是问题了。\n\n## 排序算法\n\n### 用Java写一个冒泡排序。\n\n冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码：\n\n```java\nimport java.util.Comparator;\n\n/**\n * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换)\n */\npublic interface Sorter {\n\n   /**\n    * 排序\n    * @param list 待排序的数组\n    */\n   public <T extends Comparable<T>> void sort(T[] list);\n\n   /**\n    * 排序\n    * @param list 待排序的数组\n    * @param comp 比较两个对象的比较器\n    */\n   public <T> void sort(T[] list, Comparator<T> comp);\n}\n```\n\n```java\nimport java.util.Comparator;\n\n/**\n * 冒泡排序\n */\npublic class BubbleSorter implements Sorter {\n\n    @Override\n    public <T extends Comparable<T>> void sort(T[] list) {\n        boolean swapped = true;\n        for (int i = 1, len = list.length; i < len && swapped; ++i) {\n            swapped = false;\n            for (int j = 0; j < len - i; ++j) {\n                if (list[j].compareTo(list[j + 1]) > 0) {\n                    T temp = list[j];\n                    list[j] = list[j + 1];\n                    list[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n        }\n    }\n\n    @Override\n    public <T> void sort(T[] list, Comparator<T> comp) {\n        boolean swapped = true;\n        for (int i = 1, len = list.length; i < len && swapped; ++i) {\n            swapped = false;\n            for (int j = 0; j < len - i; ++j) {\n                if (comp.compare(list[j], list[j + 1]) > 0) {\n                    T temp = list[j];\n                    list[j] = list[j + 1];\n                    list[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n## 查找算法\n\n### 用Java写一个折半查找。\n\n折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是O(logN)。\n\n```java\nimport java.util.Comparator;\n\npublic class MyUtil {\n\n   public static <T extends Comparable<T>> int binarySearch(T[] x, T key) {\n      return binarySearch(x, 0, x.length- 1, key);\n   }\n\n   // 使用循环实现的二分查找\n   public static <T> int binarySearch(T[] x, T key, Comparator<T> comp) {\n      int low = 0;\n      int high = x.length - 1;\n      while (low <= high) {\n          int mid = (low + high) >>> 1;\n          int cmp = comp.compare(x[mid], key);\n          if (cmp < 0) {\n            low= mid + 1;\n          }\n          else if (cmp > 0) {\n            high= mid - 1;\n          }\n          else {\n            return mid;\n          }\n      }\n      return -1;\n   }\n\n   // 使用递归实现的二分查找\n   private static<T extends Comparable<T>> int binarySearch(T[] x, int low, int high, T key) {\n      if(low <= high) {\n        int mid = low + ((high -low) >> 1);\n        if(key.compareTo(x[mid])== 0) {\n           return mid;\n        }\n        else if(key.compareTo(x[mid])< 0) {\n           return binarySearch(x,low, mid - 1, key);\n        }\n        else {\n           return binarySearch(x,mid + 1, high, key);\n        }\n      }\n      return -1;\n   }\n}\n```\n\n> 说明：上面的代码中给出了折半查找的两个版本，一个用递归实现，一个用循环实现。需要注意的是计算中间位置时不应该使用(high+ low) / 2的方式，因为加法运算可能导致整数越界，这里应该使用以下三种方式之一：low + (high – low) / 2或low + (high – low) >> 1或(low + high) >>> 1（>>>是逻辑右移，是不带符号位的右移）\n\n\n\n\n\n\n\n\n\n> 参考链接：\n>\n> https://blog.csdn.net/jackfrued/article/details/44921941","tags":["算法"],"categories":["interview"]},{"title":"面试之---安全与性能优化相关","url":"/2018/09/16/interview-optimize/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](interview-optimize/interview.png)\n\n> 持续维护java面试题系列博文，发现好的面试题会更新进来。总结的并不只是如何回答面试官，而是这道题涉及到的知识点，明白了相关知识点和面试官要问的点，回答起来就不是问题了。\n\n# 性能优化\n\n### 大型网站在架构上应当考虑哪些问题？\n\n- 分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI/RM）和Internet的TCP/IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：\n  1. 分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；\n  2. 层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。\n- 分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。\n- 分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及MapReduce分布式计算框架来处理。\n- 集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。\n- 缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的CDN、反向代理、热点数据都是对缓存技术的使用。\n- 异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。能推迟处理的都要推迟处理\"是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。\n- 冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。\n\n### 你用过的网站前端优化的技术有哪些？\n\n1. 浏览器访问优化： \n   - 减少HTTP请求数量：合并CSS、合并JavaScript、合并图片（CSS Sprite）\n   - 使用浏览器缓存：通过设置HTTP响应头中的Cache-Control和Expires属性，将CSS、JavaScript、图片等在浏览器中缓存，当这些静态资源需要更新时，可以更新HTML文件中的引用来让浏览器重新请求新的资源  - 启用压缩  - CSS前置，JavaScript后置\n   - 减少Cookie传输 \n2. CDN加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN通常部署在网络运营商的机房，不仅可以提升响应速度，还可以减少应用服务器的压力。当然，CDN缓存的通常都是静态资源。\n3. 反向代理：反向代理相当于应用服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。\n\n### 你使用过的应用服务器优化技术有哪些？\n\n1. 分布式缓存：缓存的本质就是内存中的哈希表，如果设计一个优质的哈希函数，那么理论上哈希表读写的渐近时间复杂度为O(1)。缓存主要用来存放那些读写比很高、变化很少的数据，这样应用程序读取数据时先到缓存中读取，如果没有或者数据已经失效再去访问数据库或文件系统，并根据拟定的规则将数据写入缓存。对网站数据的访问也符合二八定律（Pareto分布，幂律分布），即80%的访问都集中在20%的数据上，如果能够将这20%的数据缓存起来，那么系统的性能将得到显著的改善。当然，使用缓存需要解决以下几个问题：\n\n   - 频繁修改的数据；\n   - 数据不一致与脏读；\n   - 缓存雪崩（可以采用分布式缓存服务器集群加以解决，[memcached](http://memcached.org)是广泛采用的解决方案）；\n   - 缓存预热\n   - 缓存穿透（恶意持续请求不存在的数据）。\n\n2. 异步操作：可以使用消息队列将调用异步化，通过异步处理将短时间高并发产生的事件消息存储在消息队列中，从而起到削峰作用。电商网站在进行促销活动时，可以将用户的订单请求存入消息队列，这样可以抵御大量的并发订单请求对系统和数据库的冲击。目前，绝大多数的电商网站即便不进行促销活动，订单系统都采用了消息队列来处理。\n\n3. 使用集群。\n\n4. 代码优化：\n\n   - 多线程：基于Java的Web开发基本上都通过多线程的方式响应用户的并发请求，使用多线程技术在编程上要解决线程安全问题，主要可以考虑以下几个方面：\n     - 将对象设计为无状态对象（这和面向对象的编程观点是矛盾的，在面向对象的世界中被视为不良设计），这样就不会存在并发访问时对象状态不一致的问题。\n     - 在方法内部创建对象，这样对象由进入方法的线程创建，不会出现多个线程访问同一对象的问题。使用ThreadLocal将对象与线程绑定也是很好的做法，这一点在前面已经探讨过了。\n     - 对资源进行并发访问时应当使用合理的锁机制。\n   - 非阻塞I/O： 使用单线程和非阻塞I/O是目前公认的比多线程的方式更能充分发挥服务器性能的应用模式，基于Node.js构建的服务器就采用了这样的方式。Java在JDK 1.4中就引入了NIO（Non-blocking I/O）,在Servlet 3规范中又引入了异步Servlet的概念，这些都为在服务器端采用非阻塞I/O提供了必要的基础。\n   - 资源复用：资源复用主要有两种方式，一是单例，二是对象池，我们使用的数据库连接池、线程池都是对象池化技术，这是典型的用空间换取时间的策略，另一方面也实现对资源的复用，从而避免了不必要的创建和释放资源所带来的开销。\n\n\n\n# 安全\n\n### 什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？ \n\n- XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范XSS主要有两方面：消毒（对危险字符进行转义）和HttpOnly（防范XSS攻击者窃取Cookie数据）。 \n\n- SQL注入攻击是注入攻击最常见的形式（此外还有OS注入攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）），当服务器使用请求参数构造SQL语句时，恶意的SQL被嵌入到SQL中交给数据库执行。SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：\n\n  1. 如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；\n  2. 错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；\n  3. 盲注。防范SQL注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的SQL会被当做SQL的参数而不是命令被执行，JDBC中的PreparedStatement就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。 \n\n- CSRF攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份，其原理如下图所示。防范CSRF的主要手段是识别请求者的身份，主要有以下几种方式：\n\n  1. 在表单中添加令牌（token）；\n  2. 验证码；\n  3. 检查请求头中的Referer（前面提到防图片盗链接也是用的这种方式）。\n\n  令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验。\n\n  > **补充：**防火墙的架设是Web安全的重要保障，[ModSecurity](http://www.modsecurity.org/)是开源的Web防火墙中的佼佼者。企业级防火墙的架设应当有两级防火墙，Web服务器和部分应用服务器可以架设在两级防火墙之间的DMZ，而数据和资源服务器应当架设在第二级防火墙之后。\n\n\n\n\n\n\n\n> 参考链接：\n>\n> https://blog.csdn.net/jackfrued/article/details/44921941","tags":["性能"],"categories":["interview"]},{"title":"面试之---java基础相关","url":"/2018/09/16/interview-java-basic/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](interview-java-basic/interview.png)\n\n> 持续维护java面试题系列博文，发现好的面试题会更新进来。总结的并不只是如何回答面试官，而是这道题涉及到的知识点，明白了相关知识点和面试官要问的点，回答起来就不是问题了。\n\n## java基础\n\n### 概念相关\n\n#### 面向对象的特征：`抽象`、`继承`、`封装`、`多态`\n\n1. `抽象`：抽象就是忽略一个主题中与当前目标无关的那些方面，以便充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一个过程抽象，而是数据抽象。\n2. `继承`：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更合适特殊的需要。\n3. `封装`：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向、对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。\n4. `多态性`：多态性事指允许不同类的对象对同一个消息作出响应。多态性包括参数多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。\n\n#### 什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？\n\n1. 具有关键字abstract，实现内容上没有完全定义的类就叫抽象类。\n2. 抽象类和接口的区别如下：\n   1. 在类来继承抽象类时，只需要实现部分方法和全部抽象方法，而实现接口则要实现里面的全部方法。\n   2. 在接口中无成员变量，而抽象类可有成员变量。\n   3. 在java中引进接口主要是为了解决多继承的问题。\n\n#### （`Overload`）和重写（`Override`）的区别。重载的方法能否根据返回类型进行区分？\n\n方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。\n\n#### 接口的意义\n\n规范、扩展、回调\n\n#### 创建对象的几种方式\n\nnew、反射、clone、序列化\n\n\n\n### jdk源码相关（不包含多线程和集合）\n\n#### `int` `Integer`的区别：\n\n1. java提供两种不同的类型：引用类型和原始类型（或内置类型）。`int`是java的原始类型数据，`Integer`是java为`int`提供的封装类。Java为每个原始类提供了封装类。\n2. 原始类型封装： `boolean` `Boolean`、`char` `Character`、`byte` `Byte`、`short` `Short`、`int` `Integer`、`long` `Long`、`float` `Float`、`double` `Double`\n3. 引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为`null`，而原始类型实例变量的缺省值与它们的类型有关。\n\n#### ++i与i++仅是“先加”与“后加”的差别吗？\n\n前置 ++ 是将变量的值加1后，使用增值后的变量进行运算的，而后置++ 是首先将变量赋值给一个临时变量，接下来对变量的值加1，然后使用那个临时变量进行运算。\n\n#### 两个对象值相同(x.equals(y) == true)，但却可有不同的`hashCode`，这句话对不对？\n\n1. 如果两个对象x和y满足x.equals(y) == true，它们的哈希码（`hash code`）应当相同。Java对于`eqauls`方法和`hashCode`方法是这样规定的：\n2. 如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；\n3. 如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，    同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。\n\n> 补充：在Joshua Bloch的大作《Effective Java》中是这样介绍`equals`方法的：首先`equals`方法必须满足`自反性`（x.equals(x)必须返回`true`）、`对称性`（x.equals(y)返回`true`时，y.equals(x)也必须返回`true`）、`传递性`（x.equals(y)和y.equals(z)都返回`true`时，x.equals(z)也必须返回`true`）和`一致性`（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非`null`值的引用x，x.equals(null)必须返回`false`。实现高质量的`equals`方法的诀窍包括： 使用`==`操作符检查”参数是否为这个对象的引用”；2. 使用`instanceof`操作符检查”参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完`equals`方法后，问自己它是否满足`对称性`、`传递性`、`一致性`；5. 重写`equals`时总是要重写`hashCode`；6. 不要将`equals`方法参数中的`Object`对象替换为其他的类型，在重写时不要忘掉`@Override`注解。\n\n#### 基本for循环与加强型for循环的差别\n\n1. 在访问数组与Iterable类型变量时，使用加强型for循环比基本for循环要方便快捷。但是，加强型for循环也有一定的局限性，也就意味着加强型for循环不可能完全取代基本for循环。\n2. 加强型for循环右侧变量必须为数组类型或者Iterable类型。\n3. 加强型for循环在底层也是由基本for循环来实现的。\n\n#### Java语言如何进行异常处理，关键字：`throws`、`throw`、`try`、`catch`、`finally`分别如何使用？\n\n1. Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是`Throwable`类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：`try`、`catch`、`throw`、`throws`和`finally`。\n2. 一般情况下是用`try`来执行一段程序，如果系统会抛出（`throw`）一个异常对象，可以通过它的类型来捕获（`catch`）它，或通过总是执行代码块（`finally`）来处理；\n   1. `try`用来指定一块预防所有异常的程序；`catch`子句紧跟在`try`块后面，用来指定你想要捕获的异常的类型；\n   2. `throw`语句用来明确地抛出一个异常；\n   3. `throws`用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；\n   4. `finally`为确保一段代码不管发生什么异常状况都要被执行；\n   5. `try`语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的`try`语句或者最终将异常抛给`JVM`。\n\n#### Java中如何实现序列化，有什么意义？\n\n1. 序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。\n2. 要实现序列化，需要让一个类实现`Serializable`接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过`writeObject(Object)`方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过`readObject`方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。\n\n#### 获得一个类的类对象有哪些方式？\n\n1. 类型`.class`，例如：String.class\n2. 对象`.getClass()`，例如：”hello”.getClass()\n3. `Class.forName()`，例如：Class.forName(“java.lang.String”)\n\n#### 如何通过反射创建对象？\n\n1. 通过类对象调用`newInstance()`方法，例如：String.class.newInstance()\n2. 通过类对象的`getConstructor()`或`getDeclaredConstructor()`方法获得构造器（`Constructor`）对象并调用其`newInstance()`方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);\n\n#### 如何通过反射调用对象的方法？\n\n    ```java\n    import java.lang.reflect.Method;\n    \n    class MethodInvokeTest {\n    \n        public static void main(String[] args) throws Exception {\n            String str = \"hello\";\n            Method m = str.getClass().getMethod(\"toUpperCase\");\n            System.out.println(m.invoke(str));  // HELLO\n        }\n    }\n    ```\n\n#### Java中如何实现序列化，有什么意义？\n\n序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。  要实现序列化，需要让一个类实现`Serializable`接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过`writeObject(Object)`方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过`readObject`方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。\n\n#### 两个`Integer`的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？\n\n第一种**错误方法**\n```java\npublic class App {\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException{\n        Integer a = 1,b = 2;\n        System.out.println(\"before:a=\"+a+\",b=\"+b);\n        swap(a, b);\n        System.out.println(\"after:a=\"+a+\",b=\"+b);\n    }\n    public static void swap(Integer i1, Integer i2) throws NoSuchFieldException, IllegalAccessException{\n        Integer tmp = i1;\n        i2 = i1;\n        i1 = tmp;\n    }\n}\n```\n> before:a=1,b=2\n> after:a=1,b=2\n\n第二种**错误方法**\n```java\npublic class App {\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException{\n        Integer a = 1,b = 2;\n        System.out.println(\"before:a=\"+a+\",b=\"+b);\n        swap(a, b);\n        System.out.println(\"after:a=\"+a+\",b=\"+b);\n    }\n    public static void swap(Integer i1, Integer i2) throws NoSuchFieldException, IllegalAccessException{\n        Field field = Integer.class.getDeclaredField(\"value\");\n        field.setAccessible(true);\n        Integer tmp = i1;\n        field.set(i1,i2);\n        field.set(i2,tmp);\n    }\n}\n```\n> before:a=1,b=2\n> after:a=2,b=2\n\n正确的一种做法\n```java\npublic class App {\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException{\n        Integer a = 1,b = 2;\n        System.out.println(\"before:a=\"+a+\",b=\"+b);\n        swap(a, b);\n        System.out.println(\"after:a=\"+a+\",b=\"+b);\n    }\n    public static void swap(Integer i1, Integer i2) throws NoSuchFieldException, IllegalAccessException{\n        Field field = Integer.class.getDeclaredField(\"value\");\n        field.setAccessible(true);\n        Integer tmp = new Integer(i1);\n        field.set(i1,i2);\n        field.set(i2,tmp);\n    }\n}\n```\n> before:a=1,b=2\n> after:a=2,b=1\n\n涉及到的知识点：\n- 自动装箱和拆箱\n- Integer -128到127之间的缓存\n- 如何通过反射区修改private final变量的值\n\n####  java 中 IO 流分为几种?\n\n- 按照流的流向分，可以分为输入流和输出流；\n- 按照操作单元划分，可以划分为字节流和字符流；\n- 按照流的角色划分为节点流和处理流。\n\nJava Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。\n\n- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。\n- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。\n\n按操作方式分类结构图：![](/interview-java-basic/image2.png)\n\n按操作对象分类结构图：![](/interview-java-basic/image3.png)\n\n\n\n####  BIO,NIO,AIO 有什么区别?\n\n- **BIO (Blocking I/O):** 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。\n- **NIO (New I/O):** NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发\n- **AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。\n\n### 集合\n\n![](interview-java-basic/image9.png)\n\n\n\n\n\n#### List、Set、Map是否继承自Collection接口？\n\nList、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。\n\n### 多线程\n\n#### `Thread`类的`sleep()`方法和对象的`wait()`方法都可以让线程暂停执行，它们有什么区别？\n\n`sleep()`方法（休眠）是线程类（`Thread`）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。`wait()`是`Object`类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的`notify()`方法（或`notifyAll()`方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。\n\n> 补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。\n\n#### synchronized关键字的用法？\n\n`synchronized`关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将`synchronized`作为方法的修饰符。\n\n#### 线程的基本状态以及状态之间的关系？\n\n![](interview-java-basic/image1.png)\n\n> **说明：**其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。\n\n#### 简述synchronized 和java.util.concurrent.locks.Lock的异同？\n\n`Lock`是Java 5以后引入的新的API，和关键字`synchronized`相比主要相同点：`Lock` 能完成`synchronized`所实现的所有功能；主要不同点：`Lock`有比`synchronized`更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。`synchronized`会自动释放锁，而`Lock`一定要求程序员手工释放，并且最好在`finally` 块中释放（这是释放外部资源的最好的地方）。\n\n#### 如何控制线程的执行顺序？\n\n1. 使用join方法，join方法是让主线程等待子线程结束后才能继续运行\n\n2. 使用`ExecutorService executor = Executors.newSingleThreadExecutor();`方法\n\n   - `newSingleThreadExecutor()`方法会创建一个只有一个线程的线程池FIFO的方式来操作\n\n   ```java\n   executorService.submit(thread1);\n   executorService.submit(thread1);\n   executorService.submit(thread1);\n   executorService.shutdown();\n   ```\n\n#### java中的Volatile和synchronized的差异？\n\n1. 线程之间通信的两种方式：\n\n   1. 共享内存-隐式通信\n\n   2. 消息传递-显式通信\n\n2. 线程之间如何保证消息同步：\n\n   1. 在共享内存的并发模型中，同步是显示做的：synchronized\n   2. 在消息传递的并发模型中，由于消息的发送必须在消息接收之前，所以同步是隐式的\n\n3. 多线程的共享变量是如何同步的\n\n   1. 线程A修改本地内存的变量值——>同步到主内存的共享变量——>线程B从主内存取得共享变量的值，刷新本地内存中的变量值\n\n4. Volatile关键字保证可见性\n\n   1. 对声明了Volatile的变量进行写操作的时候，JVM会向处理器发送一条Lock前缀的指令，会把这个变量所在缓存行的数据写回到主内存\n\n#### 什么是Callable和Future?\n\nCallable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。 \n\n可以认为是带有回调的Runnable。\n\nFuture接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。\n\n#### 为什么使用Executor框架比使用应用创建和管理线程好？\n\n**为什么要使用Executor线程池框架**\n\n每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。 \n\n调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。 \n\n直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。\n\n**使用Executor线程池框架的优点**\n\n能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开销。 \n\n可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。 \n\n框架中已经有定时、定期、单线程、并发数控制等功能。 \n\n综上所述使用线程池框架Executor能更好的管理线程、提供系统资源使用率。\n\n#### 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\n\n**悲观锁**：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。\n\n**乐观锁**：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。\n\n**乐观锁的实现方式**： \n\n使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。 \n\njava中的Compare and Swap即CAS ，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。　CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。\n\n**CAS缺点**：\n\n**ABA问题**： \n比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。 \n\n**循环时间长开销大**： \n对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 \n\n**只能保证一个共享变量的原子操作**： \n当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。\n\n#### Java线程池中submit() 和 execute()方法有什么区别？\n\n两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中。\n\n而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。\n\n### JVM\n\n#### JVM体系结构\n\n`方法区`和`堆`为线程共享资源，`虚拟机栈`、`本地方法栈`和`程序计数器`线程私有\n\n1. `本地方法栈`：它的具体做法是`Native Method Stack`中登记`native`方法，在`Execution Engine`执行时加载native libraies。\n\n2. `程序计数器`：每个线程都有一个程序计算器，就是一个指针，指向方法区中的方法字节码（下一个将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。\n\n3. `方法区`：方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域。`静态变量`+`常量`+`类信息`+`运行时常量池`存在`方法区`中，`实例变量`存在`堆内存`中。\n\n4. `栈`：`栈`也叫`栈内存`，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。基本类型的变量和对象的引用变量都是在函数的栈内存中分配。\n\n   > 栈帧中主要保存3类数据：本地变量（Local Variables）：输入参数和输出参数以及方法内的变量；栈操作（Operand Stack）：记录出栈、入栈的操作；栈帧数据（Frame Data）：包括类文件、方法等等。\n\n5. `堆`：`堆`这块区域是JVM中最大的，应用的对象和数据都是存在这个区域，这块区域也是线程共享的，也是 `gc` 主要的回收区，一个 JVM 实例只存在一个堆类存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分为三部分：新生区、养老区、永久区：\n\n   1. `新生区`：新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（`Eden space`）和幸存者区（`Survivor pace`），所有的类都是在伊甸区被new出来的。幸存区有两个：0区（`Survivor 0 space`）和1区（`Survivor 1 space`）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园进行垃圾回收（`Minor GC`）,将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1去也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生`Major GC`（`FullGCC`），进行养老区的内存清理。若养老区执行`Full GC` 之后发现依然无法进行对象的保存，就会产生OOM异常`OutOfMemoryError`。\n\n      如果出现`java.lang.OutOfMemoryError: Java heap space`异常，说明Java虚拟机的堆内存不够。原因有二：\n\n      1. Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。\n      2. 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。\n\n   2. `养老区`：养老区用于保存从新生区筛选出来的 JAVA 对象，一般池对象都在这个区域活跃。\n\n   3. `永久区`：永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。\n\n   > 如果出现`java.lang.OutOfMemoryError: PermGen space`，说明是Java虚拟机对永久代`Perm`内存设置不够。原因有二：\n   >\n   > - 程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。\n   > - 大量动态反射生成的类不断被加载，最终导致`Perm`区被占满。\n\n   > 说明：\n   >\n   > Jdk1.6及之前：常量池分配在永久代 。\n   >\n   > Jdk1.7：有，但已经逐步“去永久代” 。\n   >\n   > Jdk1.8及之后：无(`java.lang.OutOfMemoryError: PermGen space`,这种错误将不会出现在JDK1.8中)。\n\n#### 如何识别垃圾，判定对象是否可被回收？\n\n- 引用计数法：给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。缺点：无法解决循环引用的问题\n- 根搜索算法：也称可达性分析法，通过“GC ROOTs”的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收（可作为GC ROOTs的对象：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）\n\n#### Java 中的堆是 GC 收集垃圾的主要区域\n\nGC 分为两种：Minor GC、Full GC ( 或称为 Major GC )\n\n- Minor GC：新生代（Young Gen）空间不足时触发收集，由于Java 中的大部分对象通常不需长久存活，新生代是GC收集频繁区域，所以采用复制算法。\n- Full GC：老年代（Old Gen ）空间不足或元空间达到高水位线执行收集动作，由于存放大对象及长久存活下的对象，占用内存空间大，回收效率低，所以采用标记-清除算法。\n\n#### GC算法\n\n##### **按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。**\n\n1. 标记-清除算法：分为两阶段“标记”和“清除”。首先标记出哪些对象可被回收，在标记完成之后统一回收所有被标记的对象所占用的内存空间。不足之处：1.无法处理循环引用的问题2.效率不高3.产生大量内存碎片（ps：空间碎片太多可能会导致以后在分配大对象的时候而无法申请到足够的连续内存空间，导致提前触发新一轮gc）\n\n2. 标记-整理算法：分为两阶段“标记”和“整理”。首先标记出哪些对象可被回收，在标记完成后，将对象向一端移动，然后直接清理掉边界以外的内存。\n\n3. 复制算法：把内存空间划为两个相等的区域，每次只使用其中一个区域。gc时遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。不足之处：1.内存利用率问题2.在对象存活率较高时，其效率会变低。\n\n##### **按分区对待可分为：增量收集算法，分代收集算法**\n\n1. 增量收集:实时垃圾回收算法，即：在应用进行的同时进行垃圾回收，理论上可以解决传统分代方式带来的问题。增量收集把对堆空间划分成一系列内存块，使用时先使用其中一部分，垃圾收集时把之前用掉的部分中的存活对象再放到后面没有用的空间中，这样可以实现一直边使用边收集的效果，避免了传统分代方式整个使用完了再暂停的回收的情况。\n\n2. 分代收集:（商用默认）基于对象生命周期划分为新生代、老年代、元空间，对不同生命周期的对象使用不同的算法进行回收。\n\n##### 系统线程可分为：串行收集算法，并行收集算法，并发收集算法**\n\n1. 串行收集:使用单线程处理垃圾回收工作，实现容易，效率较高。不足之处：1.无法发挥多处理器的优势 2.需要暂停用户线程\n\n2. 并行收集:使用多线程处理垃圾回收工作，速度快，效率高。理论上CPU数目越多，越能体现出并行收集器的优势。不足之处：需要暂停用户线程\n\n3. 并发收集:垃圾线程与用户线程同时工作。系统在垃圾回收时不需要暂停用户线程\n\n#### Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制\n\n1. Java源码编译机制：Java 源码编译由以下三个过程组成：①分析和输入到符号表，②注解处理，③语义分析和生成class文件。最后生成的class文件由以下部分组成：\n\n   1. 结构信息：包括class文件格式版本号及各部分的数量与大小的信息\n   2. 元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池\n   3. 方法信息：对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息\n\n2. 类加载机制：JVM的类加载是通过`ClassLoader`及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：\n\n   ![](interview-java-basic/image7.png)\n\n   1. `Bootstrap ClassLoader`：负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类\n   2. `Extension ClassLoader`：负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包\n   3. `App ClassLoader`：负责记载classpath中指定的jar包及目录中class\n   4. `Custom ClassLoader`：属于应用程序根据自身需要自定义的`ClassLoader`，如`tomcat`、`jboss`都会根据j2ee规范自行实现`ClassLoader`\n\n   加载过程中会先检查类是否被已加载，检查顺序是自底向上，从`Custom ClassLoader`到`BootStrap ClassLoader`逐层检查，只要某个`classloader`已加载就视为已加载此类，保证此类只所有`ClassLoader`加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。\n\n3. 类执行机制：JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈，也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。\n\n   JVM执行class字节码，线程创建后，都会产生`程序计数器`（`PC`）和`栈`（`Stack`），`程序计数器`存放下一条要执行的指令在方法内的偏移量，`栈`中存放一个个`栈帧`，每个`栈帧`对应着每个方法的每次调用，而`栈帧`又是有`局部变量区`和`操作数栈`两部分组成，`局部变量区`用于存放方法中的局部变量和参数，`操作数栈`中用于存放方法执行过程中产生的中间结果。\n\n\n\n\n### Java与数据库\n\n#### 阐述JDBC操作数据库的步骤\n\n加载驱动 -> 创建连接 -> 创建语句 -> 执行语句 -> 处理结果 -> 关闭资源\n\n#### 在进行数据库编程时，连接池有什么作用？\n\n由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：`C3P0`、`Proxool`、`DBCP`、`BoneCP`、`Druid`、`HikariCP`等。\n\n> 补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。\n\n#### JDBC中如何进行事务处理？\n\n`Connection`提供了事务处理的方法，通过调用`setAutoCommit(false)`可以设置手动提交事务；当事务完成后用`commit()`显式提交事务；如果在事务处理过程中发生异常则通过`rollback()`进行事务回滚。除此之外，从`JDBC 3.0`中还引入了`Savepoint`（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。\n\n## J2EE\n\n### servlet\n\n#### Servlet的优点:\n\n1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销\n\n2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销\n\n3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。\n\n4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。\n\n> 补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。\n\n####  Servlet接口中有哪些方法及Servlet生命周期探秘\n\nServlet接口定义了5个方法，其中**前三个方法与Servlet生命周期相关**：\n\n- **void init(ServletConfig config) throws ServletException**\n- **void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException**\n- **void destory()**\n- java.lang.String getServletInfo()\n- ServletConfig getServletConfig()\n\n**生命周期：** **Web容器加载Servlet并将其实例化后，Servlet生命周期开始**，容器运行其**init()方法**进行Servlet的初始化；请求到达时调用Servlet的**service()方法**，service()方法会根据需要调用与请求对应的**doGet或doPost**等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的**destroy()方法**。**init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行**。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。\n\n### jsp\n\n#### JSP有哪些内置对象、作用分别是什么\n\nJSP有9个内置对象：\n\n- `request`：封装客户端的请求，其中包含来自GET或POST请求的参数；\n- `response`：封装服务器对客户端的响应；\n- `pageContext`：通过该对象可以获取其他对象；\n- `session`：封装用户会话的对象；\n- `application`：封装服务器运行环境的对象；\n- `out`：输出服务器响应的输出流对象；\n- `config`：Web应用的配置对象；\n- `page`：JSP页面本身（相当于Java程序中的this）；\n- `exception`：封装页面抛出异常的对象。\n\n#### Request对象的主要方法有哪些\n\n- `setAttribute(String name,Object)`：设置名字为name的request 的参数值\n- `getAttribute(String name)`：返回由name指定的属性值\n- `getAttributeNames()`：返回request 对象所有属性的名字集合，结果是一个枚举的实例\n- `getCookies()`：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组\n- `getCharacterEncoding()` ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度\n- `getHeader(String name)` ：获得HTTP协议定义的文件头信息\n- `getHeaders(String name)` ：返回指定名字的request Header 的所有值，结果是一个枚举的实例\n- `getHeaderNames()` ：返回所以request Header 的名字，结果是一个枚举的实例\n- `getInputStream()` ：返回请求的输入流，用于获得请求中的数据\n- `getMethod()` ：获得客户端向服务器端传送数据的方法\n- `getParameter(String name)` ：获得客户端传送给服务器端的有 name指定的参数值\n- `getParameterNames()` ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例\n- `getParameterValues(String name)`：获得有name指定的参数的所有值\n- `getProtocol()`：获取客户端向服务器端传送数据所依据的协议名称\n- `getQueryString()` ：获得查询字符串\n- `getRequestURI()` ：获取发出请求字符串的客户端地址\n- `getRemoteAddr()`：获取客户端的 IP 地址\n- `getRemoteHost()` ：获取客户端的名字\n- `getSession([Boolean create])` ：返回和请求相关 Session\n- `getServerName()` ：获取服务器的名字\n- `getServletPath()`：获取客户端所请求的脚本文件的路径\n- `getServerPort()`：获取服务器的端口号\n- `removeAttribute(String name)`：删除请求中的一个属性\n\n> 参考链接：\n>\n> https://blog.csdn.net/jackfrued/article/details/44921941\n>\n> https://github.com/Snailclimb/JavaGuide?utm_source=gold_browser_extension","tags":["java基础"],"categories":["interview"]},{"title":"linux常用命令","url":"/2018/09/15/linux-commands/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![linux](linux-commands/linux.jpg)\n\n　　记录下linux常用操作文件命令，以及安装常用软件方法，备忘以及方便查找\n\n## 常用命令\n\n### 文件和目录\n\n- `cd ..`：返回上一级目录\n- `cd /`：进入根目录\n- `cd ~`：进入用户主目录\n- `pwd`：打印当前目录juedui路径\n- `ls`：列出当前目录中的文件\n- `ll`：列出当前目录中的文件详细信息\n- `ls -a`：显示隐藏文件 \n- `tree`：显示文件和目录由根目录开始的树形结构\n- `lstree`：显示文件和目录由根目录开始的树形结构\n- `mkdir` dir1：创建一个叫做 'dir1' 的目录'\n- `mkdir` dir1 dir2：同时创建两个目录 \n- `mkdir -p` /tmp/dir1/dir2：创建/tmp/dir1/dir2目录树\n- `rm -f` file1：删除一个叫做 'file1' 的文件'\n- `rmdir` dir1：删除一个叫做 'dir1' 的目录'\n- `rm -rf` dir1：删除一个叫做 'dir1' 的目录并同时删除其内容\n- `rm -rf` dir1 dir2：同时删除两个目录及它们的内容\n- `mv` dir1 dir2：重命名/移动 一个目录\n\n### 文件搜索\n\n- `find . -name` \"*.txt\"：列出当前目录及子目录下所有后缀为 txt 的文件\n- `find . -type f`：列出当前目录及子目录下所有一般文件\n- `find . -ctime` -20：列出当前目录及子目录下所有最近 20 天内更新过的文件\n\n### 打包和压缩文件\n\n- `bunzip2` file1.bz2：解压一个叫做 'file1.bz2'的文件 \n- `bzip2` file1：压缩一个叫做 'file1' 的文件 \n- `gunzip` file1.gz：解压一个叫做 'file1.gz'的文件\n- `gzip` file1：压缩一个叫做 'file1'的文件 \n- `gzip -9` file1：最大程度压缩  \n- `rar a` file1.rar test_file：创建一个叫做 'file1.rar' 的包  \n- `rar a` file1.rar file1 file2 dir1：同时压缩 'file1', 'file2' 以及目录 'dir1'  \n- `rar x` file1.rar：解压rar包  \n- `unrar x` file1.rar：解压rar包  \n- `tar -cvf` archive.tar file1：创建一个非压缩的 tarball  \n- `tar -cvf` archive.tar file1 file2 dir1：创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件  \n- `tar -tf` archive.tar：显示一个包中的内容 \n- `tar -xvf` archive.tar：释放一个包  \n- `tar -xvf` archive.tar `-C` /tmp：将压缩包释放到 /tmp目录下  \n- `tar -cvfj` archive.tar.bz2 dir1：创建一个bzip2格式的压缩包  \n- `tar -jxvf` archive.tar.bz2：解压一个bzip2格式的压缩包  \n- `tar -cvfz` archive.tar.gz dir1：创建一个gzip格式的压缩包  \n- `tar -zxvf` archive.tar.gz：解压一个gzip格式的压缩包  \n- `zip` file1.zip file1：创建一个zip格式的压缩包 \n- `zip -r` file1.zip file1 file2 dir1：将几个文件和目录同时压缩成一个zip格式的压缩包  \n- `unzip` file1.zip：解压一个zip格式压缩包 \n\n### yum相关\n\n- `yum install` package_name：下载并安装一个软件包  \n- `yum localinstall` package_name.rpm：将安装一个软件包，使用你自己的软件仓库为你解决所有依赖关系\n- `yum update`：更新当前系统中所有安装的软件包  \n- `yum update` package_name：更新一个软件包\n- `yum remove` package_name：删除一个软件包  \n- `yum list` ：列出当前系统中安装的所有包  \n- `yum search` package_name：在仓库中搜寻软件包  \n- `yum clean packages`：清理缓存目录下软件包  \n- `yum clean headers`：删除所有头文件  \n- `yum clean all`： 删除所有缓存的包和头文件 \n\n### 查看文件内容\n\n- `cat` file1：从第一个字节开始正向查看文件的内容\n- `more` file1：分页查看一个长文件的内容\n- `less` file1：less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。\n- `head` -2 file1：查看一个文件的前两行\n- `tail` -2 file1：查看一个文件的最后两行\n- `tail -f` file1：实时查看一个文件中的内容\n\n### 文本处理\n\n- `grep` test *file：当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行\n- `grep -r` update /etc/acpi：查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串\"update\"的文件，并打印出该字符串所在行的内容\n- `grep -v` test `*`test`*`：查找文件名中包含 test 的文件中不包含test 的行\n\n### 系统设置\n\n- `top`：实时显示 process 的动态\n- `free -m`：查看内存使用量和交换区使用量\n- `date`：显示当前时间\n- `clear`：清屏\n- `alias` lx=ls：指定lx别名为ls\n- `bind -l`：列出所有按键组合\n- `eval`：重新运算求出参数的内容\n- `ps -ef|grep` mysql：查看mysql服务进程信息","tags":["命令"],"categories":["集成&运维"]},{"title":"项目树","url":"/2018/09/13/tree-projects/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n　　总结下java能实现的项目，慢慢补充，持续更新，有个计划就是后续用微服务的形式，把每个项目都撸一遍，下面是我在ProcessOn上总结的，点击[**这里**](https://www.processon.com/i/5aacfa26e4b0f68cc01c8b7a)注册ProcessOn，点击[**这里**](https://www.processon.com/view/5ad09927e4b0518eacad7ddb)，可查看或克隆，后续还会不定期补充完善。如果觉得哪里分类或者总结的不太合理，欢迎留言拍砖！\n\n<iframe id=\"embed_dom\" name=\"embed_dom\" frameborder=\"0\" style=\"display:block;width:1465px; height:950px;\" src=\"https://www.processon.com/embed/mind/5ad09927e4b0518eacad7ddb\"></iframe>","tags":["总结"],"categories":["tree"]},{"title":"Redis总结","url":"/2018/09/12/redis-summary/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](redis-summary\\words13.jpg)\n\n> 资源列表:\n>\n> [Redis 命令参考](http://doc.redisfans.com/)\n>\n> [Commands](https://redis.io/commands)\n\n## Redis是什么\n\n　　`Redis`是一个开源(`BSD许可`)的内存中的数据结构存储，用作数据库、缓存和消息中间件。它支持多种数据结构，如`字符串`、`哈希表`、`列表`、`无序集合`、`有序集合`的范围查询，`位图`、`基数统计`和`地理空间索引`的与查询。Redis内置`复制`、`Lua脚本`、`LRU回收`、`事务`和不同级别的`磁盘持久化`，并通过`哨兵`和`自动分区`提供高可用性集群。\n\n\n\n## 单线程结构\n\n- 纯内存数据库，瓶颈不在内存，在于网络IO\n- 单线程，避免频繁切换上下文\n- 异步阻塞I/O（多路复用）\n\n## 持久化\n\n### RDB（Redis DataBase）持久化\n\n- 快照\n- 优点：适合备份、还原、恢复数据快、最大化 Redis 的性能\n- 缺点：两次快照间的数据会丢失、数据集比较庞大时， `fork()` 可能会非常耗时\n\n### AOF（Append Only File）持久化\n\n- 日志\n- 优点：数据完整性高、可读性高、可重写（重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合）\n- 缺点：体积大、慢于RDB、有bug\n\n## 事务\n\n`multi`开启事务，`exec`执行事务\n\n![tx](redis-summary/tx.png)\n\n　　可以看到，redis事务实现原理是将要执行的命令，存储到一个队列中，依次执行，报错时停止并取消事务，不报错则提交事务。\n\n> 例外：不会回滚的情况：\n>\n> 当一个事务中某一条（多条）命令加入队列不报错，执行时才会报错，则redis会忽略错误继续执行。\n\n　　使用`watch`监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。当`exec`被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。或者调用`unwatch`手动取消监控。\n\n## 管道\n\n- pipeline通过减少客户端与redis的通信次数来实现降低往返延时时间，而且Pipeline 实现的原理是队列，而队列的原理是时先进先出，这样就保证数据的顺序性。\n\n- 适用场景：批量操作、可靠性要求不高、\n\n## Lua脚本\n\n　　Lua是一个高效的轻量级脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能，从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。\n\n- 通过lua脚本可以原子执行多条redis命令\n- 执行lua脚本期间，会阻塞所有命令操作\n\n### 使用脚本的好处\n\n- 减少网络开销，在Lua脚本中可以把多个命令放在同一个脚本中运行\n- 原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说，编写脚本的过程中无需担心会出现竞态条件\n- 复用性，客户端发送的脚本会永远存储在redis中，这意味着其他客户端可以复用这一脚本来完成同样的逻辑\n\n## 多数据库支持\n\n默认支持16个数据库；可以理解为一个命名空间\n\n跟关系型数据库不一样的点\n\n1. redis不支持自定义数据库名词\n\n2. 每个数据库不能单独设置授权\n\n3. 每个数据库之间并不是完全隔离的。 可以通过flushall命令清空redis实例面的所有数据库中的数据\n\n> 通过  select dbid 去选择不同的数据库命名空间 。 dbid的取值范围默认是0 -15\n\n\n\n## 分布式集群\n\n　　Redis Cluster中，Sharding采用slot(槽)的概念，一共分成16384个槽，这有点儿类似前面讲的pre sharding思路。对于每个进入Redis的键值对，根据key进行散列，分配到这16384个slot中的某一个中。使用的hash算法也比较简单，就是CRC16后16384取模。Redis集群中的每个node(节点)负责分摊这16384个slot中的一部分，也就是说，每个slot都对应一个node负责处理。当动态添加或减少node节点时，需要将16384个槽做个再分配，槽中的键值也要迁移。当然，这一过程，在目前实现中，还处于半自动状态，需要人工介入。Redis集群，要保证16384个槽对应的node都正常工作，如果某个node发生故障，那它负责的slots也就失效，整个集群将不能工作。为了增加集群的可访问性，官方推荐的方案是将node配置成主从结构，即一个master主节点，挂n个slave从节点。这时，如果主节点失效，Redis Cluster会根据选举算法从slave节点中选择一个上升为主节点，整个集群继续对外提供服务。这非常类似服务器节点通过Sentinel监控架构成主从结构，只是Redis Cluster本身提供了故障转移容错的能力。\n\n- redis sharding\n- codis\n- twemproxy\n\n## 支持的数据类型、常用命令、常用场景\n\n### String\n\n> 默认存储最大容量为512M\n>\n> 常用命令：[set](http://doc.redisfans.com/string/set.html)、[get](http://doc.redisfans.com/string/get.html)、[incr](http://doc.redisfans.com/string/incr.html)、[decr](http://doc.redisfans.com/string/decr.html)、[append](http://doc.redisfans.com/string/append.html)、[strlen](http://doc.redisfans.com/string/strlen.html)、[mget](http://doc.redisfans.com/string/mget.html)、[setnx](http://doc.redisfans.com/string/setnx.html)\n\n- set+get：缓存、单点登录\n\n- bitmap：用户上线次数统计\n- incr：计数器、限速器\n\n### List\n\n> 有序，可重复\n>\n> 常用命令：[lpush](http://doc.redisfans.com/list/push.html)、[rpush](http://doc.redisfans.com/list/rpush.html)、[lpop](http://doc.redisfans.com/list/lpop.html)、[rpop](http://doc.redisfans.com/list/rpop.html)、[llen](http://doc.redisfans.com/list/llen.html)、[lrange](http://doc.redisfans.com/list/lrange.html)、[lrem](http://doc.redisfans.com/list/lrem.html)、[lset](http://doc.redisfans.com/list/lset.html)\n\n- lpush+lpop：Stack(栈)  \n- lpush+rpop：Queue（队列）  \n- lpush+ltrim：Capped Collection（有限集合）  \n- lpush+brpop：Message Queue（消息队列）\n- blpop：事件提醒（替代轮询）\n\n### Hash\n\n> 不支持数据类型的嵌套\n>\n> 适合存储对象\n>\n> 常用命令：[hset](http://doc.redisfans.com/hash/hset.html)、[hget](http://doc.redisfans.com/hash/hget.html)、[hmset](http://doc.redisfans.com/hash/hmset\n> ,.html)、[hmget](http://doc.redisfans.com/hash/hmget.html)、[hgetall](http://doc.redisfans.com/hash/hgetall.html)、[hexists](http://doc.redisfans.com/hash/hexists.html)、[hincrby](http://doc.redisfans.com/hash/hincryby.html)、[hsetnx](http://doc.redisfans.com/hash/hsetnx.html)、[hdel](http://doc.redisfans.com/hash/hdel.html)\n\n### Set\n\n> 无序、不重复\n>\n> 常用命令：[sadd](http://doc.redisfans.com/set/sadd.html)、[srem](http://doc.redisfans.com/set/srem.html)、[smembers](http://doc.redisfans.com/set/smembers.html)、[sdiff](http://doc.redisfans.com/set/sdiff.html)、[sunion](http://doc.redisfans.com/set/sunion.html)、[sinter](http://doc.redisfans.com/set/sinter.html)\n\n- sadd：标签\n- sinter：交集\n- sunion：并集\n\n### SortedSet\n\n> 有序、不重复\n>\n> 常用命令：[zadd](http://doc.redisfans.com/sorted_set/zadd.html)、[zrange](http://doc.redisfans.com/sorted_set/zrange.html)\n\n- zcount：统计信息\n- zrevrange：排行榜\n\n### key\n\n>  常用命令：[expire](http://doc.redisfans.com/key/expire.html)、[ttl](http://doc.redisfans.com/key/ttl.html)\n\n### Script\n\n>  常用命令：[eval](http://redisdoc.com/script/eval.html)\n\n## Redis安装\n\n### 安装\n\n首先，到redis官网找到要安装的redis版本，[Redis下载页](https://redis.io/download)，我们这里选用`v4.0.11`，依次执行下面命令：\n\n```shell\n# wget http://download.redis.io/releases/redis-4.0.11.tar.gz\n# tar xzf redis-4.0.11.tar.gz\n# cd redis-4.0.11\n# make\n```\n\n到此安装完成，然后可以通过`make test`测试编译状态\n\n```shell\n# make test\n```\n\n无报错完成编译应该会有这样的输出：\n\n![make-test](redis-summary/redis-make-test.png)\n\n> 报错：需要tcl 8.5以上来运行redis test\n>\n> You need tcl 8.5 or newer in order to run the Redis test\n> make: *** [test] Error 1\n\n下面安装`tcl8.6.1`：\n\n```shell\n# wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz\n# sudo tar xzvf tcl8.6.1-src.tar.gz\n# cd tcl8.6.1/unix/\n# sudo ./configure\n# sudo make\n# sudo make install \n```\n\n再次运行`make test`，没问题之后，运行最后一步，完成安装：\n\n```shell\n# make install\n```\n\n![redis-make-install](redis-summary/redis-make-install.png)\n\n直接启动：\n\n```shell\n# ./redis-server ../redis.conf\n```\n\n![redis-server](redis-summary/redis-server.png)\n\n后台启动redis，只需修改`redis.conf`配置文件的`daemonize yes`，再次启动即可。\n\n![daemonize](redis-summary/daemonize.png)\n\n### 安装启动相关命令\n\n#### 启动redis服务器：\n\n```shell\n# ./redis-server ../redis.conf\n```\n\n#### 停止redis服务:\n\n```shell\n# ./redis-cli shutdown\n```\n\n#### 连接本地启动好的redis：\n\n```shell\n# redis-cli\n```\n\n#### 根据ip端口连接redis：\n\n```shell\n# redis-cli -h 127.0.0.1 -p 6379\n```\n\n#### 查看当前是否设置了密码\n\n```shell\n127.0.0.1:6379> config get requirepass\n1) \"requirepass\"\n2) \"\"\n```\n\n#### 设置密码\n\n```shell\n127.0.0.1:6379> config set requirepass 123456 //密码是123456\nOK\n```\n\n\n\n## 使用总结\n\n### 关于key\n\n- 建议key不要太长，不要超过1024字节，占用内存且会降低查询效率\n- 建议统一命名规则，例如：String:001:zhangsan:age\n\n### 使用 bitmap 实现用户上线次数统计\n\n　　Bitmap 对于一些特定类型的计算非常有效。\n\n　　假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 [*SETBIT*](http://doc.redisfans.com/string/setbit.html#setbit) 和 [*BITCOUNT*](http://doc.redisfans.com/string/bitcount.html#bitcount) 来实现。\n\n　　比如说，每当用户在某一天上线的时候，我们就使用 [*SETBIT*](http://doc.redisfans.com/string/setbit.html#setbit) ，以用户名作为 `key` ，将那天所代表的网站的上线日作为 `offset` 参数，并将这个 `offset` 上的为设置为 `1` 。\n\n　　举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 `SETBIT peter 100 1` ；如果明天 peter 也继续阅览网站，那么执行命令 `SETBIT peter 101 1` ，以此类推。\n\n　　当要计算 peter 总共以来的上线次数时，就使用 [*BITCOUNT*](http://doc.redisfans.com/string/bitcount.html#bitcount) 命令：执行 `BITCOUNT peter` ，得出的结果就是 peter 上线的总天数。\n\n　　更详细的实现可以参考博文(墙外) [Fast, easy, realtime metrics using Redis bitmaps](http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/) 。\n\n### 缓存\n\n#### 缓存一致性\n\n- 先更新库数据，再删除缓存\n\n#### 缓存击穿和缓存雪崩\n\n\n\n### 分布式锁的实现\n\n`setnx`+`lua`实现\n\n```java\npublic class RedisTool {\n\n    private static final String LOCK_SUCCESS = \"OK\";\n    private static final String SET_IF_NOT_EXIST = \"NX\";\n    private static final String SET_WITH_EXPIRE_TIME = \"PX\";\n    private static final Long RELEASE_SUCCESS = 1L;\n\n    // 获取锁\n    public static boolean getLock(Jedis jedis, String lockKey, String requestId, int expireTime) {\n\n        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);\n\n        if (LOCK_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n\n    }\n\n\t// 释放锁\n    public static boolean releaseLock(Jedis jedis, String lockKey, String requestId) {\n\n        String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\";\n        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));\n\n        if (RELEASE_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n### 抢红包，秒杀的实现\n\n`incr`+`lua`脚本实现\n\n\n\n> 参考链接：\n>\n> http://doc.redisfans.com\n>\n> https://blog.csdn.net/liqingtx/article/details/60330555","tags":["redis"],"categories":["总结"]},{"title":"Hexo博客搭建相关","url":"/2018/09/11/about-Hexo/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![hexo](about-Hexo/hexo.png)\n\n> 本文默认已经安装好`git`和`node.js`环境\n>\n> 版本说明：`git version 2.16.2.windows.1` 、` node.js v8.9.4`\n\n## Hexo是什么\n\n　　Hexo 是一个快速、简洁且高效的博客框架，这里不多介绍，丢个链接，感兴趣的自己去看吧：[Hexo中文官网](https://hexo.io/zh-cn/)，里面的东西比较多，不光有hexo使用文档，还有众多的hexo插件和主题。\n\n## 我的Hexo博客主页效果图\n\n欢迎来访~[逸竹小站](https://www.yizhuxiaozhan.site/)\n\n![hexo-homepage](about-Hexo/homepage.png)\n\n## 安装Hexo\n\n```shell\n$ npm install -g hexo-cli\n```\n\n## 建立默认主题博客\n\n```shell\n$ hexo init blog\n$ cd blog\n$ npm install\n```\n\n>  `blog`为博客存储文件夹名称，可随意命名，本文以`blog`为例。最好命名与GitHub Pages仓库名称一致，省的后面修改，不过都是小case\n\n![hexo博客初始文件夹截图](about-Hexo/hexo-init.png)\n\n> 因为要下载文件，而且是从github下载，如果可以“科学上网”，可以开一下。\n>\n> 此时打开`localhost:4000`即可看到默认主题的Hexo博客\n\n## 选择主题\n\n在[官网-主题](https://hexo.io/themes/)里面有200+的主题可供选择，我推荐几款个人比较喜欢的\n\n- 简约款\n  - [**hexo-theme-next**](https://github.com/iissnan/hexo-theme-next)\n  - [**maupassant-hexo**](https://github.com/tufu9441/maupassant-hexo)\n  - [**hexo-theme-melody**](https://github.com/Molunerfinn/hexo-theme-melody)\n- 炫酷款\n  - [**black-blue**](https://github.com/maochunguang/black-blue)\n  - [**hexo-theme-nebula**](https://github.com/Suolawangzai/hexo-theme-nebula)\n- 实用款\n  - [**hexo-theme-pure**](https://github.com/cofess/hexo-theme-pure)\n\n## 应用主题\n\n　　选择好主题后，进入对应的github项目主页，一般都会有README文件帮助完成后续搭建，若无可以参考下面步骤进行，进入之前搭建好的博客主题文件目录下（本文为：blog/themes/），检出主题文件\n\n```shell\n$ git clone https://github.com/xxxx\n```\n\n　　然后修改博客配置文件`_config.yml`，添加下面这行\n\n```\ntheme: xxx\n```\n\n> 注意：①`xxx`为主题名称\n>\n> ②不是主题的配置文件哦，在博客文件夹根目录下\n\n## 配置文件详解\n\n　　搭建整个博客过程中有两个配置文件，非常重要，一个是博客配置文件，一个是主题配置文件分别存放在各自的根目录下，文件名均为`_config.yml`\n\n博客配置文件\n\n```yml\n# Hexo 配置\n\n# Site\ntitle: Hexo\t\t# Hexo博客网站标题\nsubtitle:\t\t# Hexo博客网站子标题\ndescription:\t# Hexo博客网站描述\nkeywords:\t\t# Hexo博客关键词\nauthor: John Doe\t# 作者\nlanguage:\t\t\t# 语言\ntimezone:\t\t\t# 时区\n\n# URL\nurl: http://yoursite.com\t# 网站网址\nroot: /\t\t\t\t\t\t# 网站根目录\npermalink: :year/:month/:day/:title/\t# 文章永久链接格式\npermalink_defaults:\t\t\t# 永久链接每部分默认值，一般不设置\n\n# Directory\nsource_dir: source\t\t# 资源文件存储目录\npublic_dir: public\t\t# 公共文件夹，静态网站生成目录\ntag_dir: tags\t\t\t# 标签目录\narchive_dir: archives\t# 文章目录\ncategory_dir: categories\t# 分类目录\ncode_dir: downloads/code\t# 代码目录\ni18n_dir: :lang\t\t\t# i18n国际化\nskip_render:\n\n# Writing\nnew_post_name: :title.md \t# 新博客文件名格式\ndefault_layout: post\t\t# 默认布局\ntitlecase: false \t\t\t# 是否标题小写\nexternal_link: true \t\t# 是否在新的标签页打开链接\nfilename_case: 0\t\t\t# 转换文件名1：小写，2：大写\nrender_drafts: false\t\t# 显示草稿\npost_asset_folder: false\t# \nrelative_link: false\t\t# 是否是用相对路径作为连接\nfuture: true\t\t\t\t# 是否展示未来的文章\nhighlight:\t\t\t\t\t# 代码高亮设置\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n  \n# Home page setting\nindex_generator:\t\t# 主页设置\n  path: ''\t\t\t\t# 博客根目录\n  per_page: 10\t\t\t# 分页大小\n  order_by: -date\t\t# 排序，默认日期\n  \n# Category & Tag\ndefault_category: uncategorized\t# 默认分类\ncategory_map:\t\t\t# 分类集合\ntag_map:\t\t\t\t# 标签集合\n\n# Date / Time format\ndate_format: YYYY-MM-DD\t# 日期格式\ntime_format: HH:mm:ss\t# 时间格式\n\n# Pagination\nper_page: 10\t\t\t# 分页大小\npagination_dir: page\t# 分页目录\n\n# Extensions\ntheme: landscape\t\t# 主题\n\n# Deployment\ndeploy:\t\t\t\t\t# 部署\n  type:\t\t\t\t\t# 类别：git\n```\n\n　　主题配置文件，这个是[**black-blue**](https://github.com/maochunguang/black-blue)主题的配置文件，已经比较详细了，直接贴上来了\n\n```yml\n# >>> Basic Setup | 基础设置 <<<\n\n# Header | 主菜单\n## About Page: `hexo new page about`\n## Tags Cloud Page: `hexo new page tags`\nmenu:\n  # 主页: /archives/\n  所有文章: /archives/\n  玩转开发工具: /categories/开发工具/\n  玩转数码: /categories/digital\n  算法学习: /categories/algorithm\n  关于我: /about/\n# 静心阅读: /tags\n\n# Link to your avatar | 填写头像地址\navatar: /img/avatar.png\n\n# Small icon of Your site | 站点小图标地址\nfavicon: /img/favicon.png\n\n# 域名是否启用https，如果启用，js文件必须https加载\nisHttps: true\n\n# Social info. Bar | 社交信息展示\n## Keep \"mailto:\" in Email | 设置 Email 时保留 \"mailto:\"\n## Encrypt email 加密邮件地址 http://ctrlq.org/encode/\n## RSS requires a plugin to take effect | 使用 RSS 需先安装对应插件\n## https://github.com/hexojs/hexo-generator-feed\nsubnav:\n  github: xxxxx\n  weibo: xxxxxxxx\n  rss: /atom.xml\n\n  # Google: \"#\"\n# search_box: true\n\n# >>> Conments 评论系统 <<<\n\ndisqus:\n  on: false\n  shortname: xxxxxxxxx\n  # https://help.disqus.com/customer/en/portal/articles/466208-what-s-a-shortname-\n  # It is unnecessary to enable disqus here if\n  # you have set \"disqus_shortname\" in your site's \"_config.yml\"\nchangyan:\n  on: true\n  appid: xxxx\n  conf: xxxxxxxxx\n  # 是否开启畅言评论，\n  # id 中填写你的友言用户数字ID，注册后进入后台管理即可查看\n  # 畅言评论在 Web 环境下运行，普通本地环境无法查看，请部署后在线上测试。\ngitment:\n  on: true\n  githubID: yourid\n  repo: yourrepo\n  client_id: yourid\n  client_secret: yoursecret\n  lazy: true\n\n# >>> Style Customisation 样式自定义 <<<\n\n# Background | 背景\n## \"background_sum\": show images form /source/background/的图片数目\n## \"on: true\": 自动随机显示这5张图片\n## \"on: false\": 自定义显示图片设置background_image: 5\nbackground:\n  on: true\n  background_sum: 1\n  background_image: 1\n\nhighlight_style:\n  on: true\n  inline_code: 3  # Value: 0 - 9 可选\n  code_block: 2  # Value: 0 - 4\n  # Set inline_code to style highlight text\n  # Chose a highlight theme for code block\n  # 通过 inline_code 切换内置文本高亮样式\n  # 通过 code_block 切换内置代码高亮配色主题\n\nblockquote_style:\n  #on: true\n  blockquote: 5  # Value: 0 - 7 可选\n  # 自定义文章「引用部分」的样式\n\n# 左边栏宽度 px\nleft_col_width: 300\n\n# 目录中标题不换行\n# Keep TOC title on the same line |\ntoc_nowrap: false\n\n# 自定义\"阅读全文\"链接按钮的显示文字\n# Customize the text on excerpt link\nexcerpt_link: 查看更多 #修改more>>的文字\n\n# 是否显示边栏中的搜索框（站内搜索）\n# Search Box in left column\nsearch_box: true\n\n# 是否开启主页及加载头像时的动画效果\n# Animation in Homepage and Loading avatar\nanimate: true\n\n# >>> Small features | 小功能设置 <<<\n\n# 是否开启边栏多标签切换\n# Birdhouse button in left column\ntagcloud: true\n\n# Blogroll, Link exchange | 友情链接\n# friends: false\nfriends:\n  csdn: http://blog.csdn.net/baidu_21483933\n  segmentfault: https://segmentfault.com/blog/maocg_web\n  简书: http://www.jianshu.com/users/eb37ef89c746/latest_articles\n#是否开启“关于我”。\naboutme: 爱动漫,爱游戏,爱编程,爱运动,爱的太多了!\n#aboutme: false\n\n# 是否在新窗口打开链接\nopen_in_new: false\n\n# Customize feed link 自定义订阅地址\nrss: /atom.xml\n\n# >>> Vendors | 第三方工具 & 服务 <<<\n\n# images viewer | 图片浏览器\n## http://www.fancyapps.com/fancybox/\nfancybox: true\n\n# Display Math(LaTeX, MathML...) | 数学公式支持\n## https://www.mathjax.org/\nmathjax: false\n\n# Socail Share | 是否开启分享\n# share: true\nbaidushare: true\n#showshare: true\n\n# 百度、谷歌站长验证。填写 HTML 标签 content\n# Site Verification for Google and Baidu. HTML label content.\n# google_site: # pFW527fHrjfI0si2w4NQ0w3cTw12AvvuohAu1PUfqKA\n# baidu_site: #c167b9feb4f0b208b712c79629c188e4\n\n# Fill in Google Analytics tracking ID, #e.g. UA-XXXXX-X, or Baidu Analytics hash key\ngoogle_analytics: xxxxx\nbaidu_analytics: xxxxxx\n\n# 不蒜子网站计数设置\n# http://ibruce.info/2015/04/04/busuanzi/\nvisit_counter:\n  on: true\n  site_visit: 极客到访数\n  page_visit: 本页阅读量\n\n# A标签提示\nTipTitle: true\n\n# Loading\n# Loading: true\n```\n\n## 日常产出博客\n\n### 写作\n\n#### 新建文章\n\n```shell\n$ hexo new [layout] <title>\n```\n\n\t您可以在命令中指定文章的布局（layout），默认为 `post`，可以通过修改 `_config.yml` 中的 `default_layout` 参数来指定默认布局。\n\n```shell\n$ hexo new photo \"My Gallery\"\n```\n\n\t在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，所以可以新建几个博客模板文件放置在 scaffolds 文件夹下。\n\n我用的博客模板为：\n\n```markdown\n---\ntitle: {{ title }}\ncategories: 分类\ntags: \n  - 标签\ndate: {{ date }}\ndescription: 描述\n---\n\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n```\n\n#### 新建页面\n\n```shell\n$ hexo new [layout] <title>\n```\n\n### 本地启动\n\n```shell\n$ hexo s[erver]\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\n```\n\n　　启动之后http://localhost:4000 即可看到效果\n\n### 本地调试\n\n```shell\n$ hexo s[erver] --debug\n```\n\n　　进入调试模式，可以看到详细的启动日志，包含hexo版本、工作目录、插件、博客目录、静态文件等信息，同时访问调试博客时还可以看到各资源响应状态和时间等信息。这种模式下调试博客样式及特效非常方便。\n\n### 提交文件到github\n\n```shell\n$ git add .\n$ git commit -m \"提交备注\"\n```\n\n　　即可提交到本地仓库，不熟悉git命令的可以查看我的另一篇博文[Git命令汇总](https://www.yizhuxiaozhan.site/2018/09/27/git-commands/)\n\n### GitHub Pages配置\n\n![githubPages](about-Hexo/github-pages.png)\n\n>这里仓库名称有两种命名方式：\n>\n>①github账户的 `用户名`+`github.io`，这种仓库访问地址为:`https://用户名.github.io/`\n>\n>②随意命名只要与你其他仓库名称不冲突即可，例如`hexo-blog`，则访问地址为：`https://github.com/`+`用户名`+`/hexo-blog/`\n>\n>大多数都会选择第一种格式创建仓库\n\n![githubPages1](about-Hexo/github-pages1.png)\n\n> ①GitHub Page仓库资源文件必须存放master分之\n>\n> ②下面可以配置自己的域名，配置之后会在仓库根目录生成`CNAME`文件，同时要将域名解析到仓库访问地址\n\n### 连接本地仓库和远程仓库\n\n　　**将本地博客文件夹名称改为与仓库名称一致**，然后将二者关联\n\n```shell\n$ git remote git@github.com:用户名/仓库名.git\n```\n\n### 部署到Hexo远程仓库\n\n```shell\n$ hexo c[lean]\n$ hexo g[enerate]\n$ hexo d[eploy]\n```\n\n> hexo命令支持简写，条件是只有一个匹配项，egs：当安装了`hexo-douban` 之后执行`hexo d`就需要区分`hexo deploy`和`hexo douban`这两个命令了，可以分别使用`hexo de`和`hexo do`来调用\n\n部署完成之后即可在上面设置的访问地址中看到效果了。\n\n## Hexo插件推荐\n\n与主题一样，[官方-插件](https://hexo.io/plugins/)也收录了200余种插件，这里推荐几款个人喜欢的\n\n- [hexo-cli](https://github.com/hexojs/hexo-cli)：Hexo命令行基础插件\n- [hexo-server](https://github.com/hexojs/hexo-server)：基础插件\n- [hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git)：git支持基础插件\n\n- [hexo-douban](https://github.com/mythsman/hexo-douban)：分享豆瓣读书、电影、游戏的豆瓣秀插件\n- [hexo-admin](https://github.com/jaredly/hexo-admin)：插件版博客后台管理系统\n- [hexo-admin-ehc](https://github.com/lwz7512/hexo-admin-ehc)：hexo-admin增强版\n- [hexo-auto-category](https://github.com/xu-song/hexo-auto-category)：根据文件夹自动生成分类\n- [hexo-auto-excerpt](https://github.com/ashisherc/hexo-auto-excerpt)：自动摘录标签\n- [hexo-generator-search](https://github.com/wzpan/hexo-generator-search)：提供搜索支持\n- [hexo-generator-sitemap](https://github.com/hexojs/hexo-generator-sitemap)：生成sitemap\n\n## 豆瓣插件\n\n　　这款插件貌似对于我正在用的主题插件(black-blue)支持的不是很好，要修改很多东西，我直接弃用了，但是这款插件的还是不错的，所以推荐下。\n\n### 安装\n\n```shell\n$ npm install hexo-douban --save\n```\n\n### 配置\n\n```yml\ndouban:\n  user: myDoubanID\n  builtin: false\n  book:\n    title: 'This is my book title'\n    quote: 'This is my book quote'\n  movie:\n    title: 'This is my movie title'\n    quote: 'This is my movie quote'\n  game:\n    title: 'This is my game title'\n    quote: 'This is my game quote'\n  timeout: 10000 \n```\n\n- **user**: 你的豆瓣ID.打开豆瓣，登入账户，然后在右上角点击 \"个人主页\" ，这时候地址栏的URL大概是这样：\"<https://www.douban.com/people/xxxxxx/>\" ，其中的\"xxxxxx\"就是你的个人ID了。\n- **builtin**: 是否将生成页面的功能嵌入`hexo s`和`hexo g`中，默认是`false`,另一可选项为`true`(1.x.x版本新增配置项)。\n- **title**: 该页面的标题.\n- **quote**: 写在页面开头的一段话,支持html语法.\n- **timeout**: 爬取数据的超时时间，默认是 10000ms ,如果在使用时发现报了超时的错(ETIMEOUT)可以把这个数据设置的大一点。\n\n### 使用\n\n```shell\n$ hexo douban\n或\n$ hexo douban -h\nUsage: hexo douban\n\nDescription:\nGenerate pages from douban\n\nOptions:\n  -b, --books   Generate douban books only\n  -g, --games   Generate douban games only\n  -m, --movies  Generate douban movies only\n```\n\n### 菜单\n\n　　如果上面的显示没有问题就可以在主题的配置文件 `_config.yml` 里添加如下配置来为这些页面添加菜单链接.\n\n```yml\nmenu:\n  Home: /\n  Archives: /archives\n  Books: /books     #This is your books page\n  Movies: /movies   #This is your movies page\n  Games: /games   #This is your games page\n```","tags":["hexo"],"categories":["总结"]},{"title":"设计模式之---单例模式(Singleton Pattern)","url":"/2018/09/10/pattern-singleton/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](pattern-singleton/it7.png)\n\n\n## 概述\n\n### 基本概念\n\n　　确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种创建型模式。\n\n### 缘起\n\n　　某些类，我们希望在程序运行期间有且只有一个实例，原因可能是该类的创建需要消耗系统过多的资源、花费很多的时间，或者业务上客观就要求了只能有一个实例。\n\n### 特点\n1. 单例类只能有一个实例。\n2. 单例类必须自己创建自己的唯一实例。\n3. 单例类必须给所有其他对象提供这一实例。\n\n### 应用场景\n\n1. 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。\n2. 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。\n\n### 常见应用\n1. 配置文件\n2. 日历类\n3. IOC容器\n4. Windows任务管理器\n5. IOC容器级别的单例bean\n\n\n## 常见的几种实现方式\n### 饿汉式单例\n``` \npublic class EagerSingleton {   \n    private static final EagerSingleton instance = new EagerSingleton();   \n    private EagerSingleton() { }   \n    public static EagerSingleton getInstance() {  \n        return instance;   \n    }     \n}\n```\n> 优点：\n> 线程安全、在类加载的同时已经创建好一个静态对象，调用时反应速度快\n\n> 缺点：\n> 资源效率不高，类加载时就初始化，浪费内存。可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化 \n\n### 懒汉式单例\n\n```\npublic class LazySingleton {   \n    private volatile static LazySingleton instance = null;\n     \n    private LazySingleton() { }   \n     \n    public static LazySingleton getInstance() {   \n        //第一重判断  \n        if (instance == null) {  \n            //锁定代码块  \n            synchronized (LazySingleton.class) {  \n                //第二重判断  \n                if (instance == null) {  \n                    instance = new LazySingleton(); //创建单例实例  \n                }  \n            }  \n        }  \n        return instance;   \n    } \n}\n```\n> 优点：\n> 资源利用率高，不执行getInstance()就不被实例，可以执行该类其他静态方法 \n\n> 缺点 ： \n> 第一次加载时反应不快，由于java内存模型一些原因偶尔失败 \n\n### 内部静态类实现\n```\npublic class Singleton {  \n    private Singleton() {  \n    }  \n      \n    private static class SingletonHolder {  \n        private final static Singleton instance = new Singleton();  \n    }  \n      \n    public static Singleton getInstance() {  \n        return SingletonHolder.instance;  \n    }    \n}  \n```\n> 优点：\n> 资源利用率高，不执行getInstance()不被实例，可以执行该类其他静态方法 \n\n> 缺点 ：\n> 第一次加载时反应不够快 \n\n### 枚举实现\n```\npublic enum EnumSingleton {\n  INSTANCE;\n}\n```\n> 优点：\n> 代码简洁，线程安全，防反射攻击、防止序列化生成新的实例\n\n> 缺点：\n> 不支持java1.5以下\n\n----------\n\n## 单例模式总结\n\n### 一.主要优点\n1.  单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。\n2.  由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。\n3.  允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例对象共享过多有损性能的问题。\n\n###  二.主要缺点\n1. 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。\n2. 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。\n3. 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。\n\n\n>参考文章：[https://blog.csdn.net/lovelion/article/details/17517213/](https://blog.csdn.net/lovelion/article/details/17517213/)","tags":["单例模式"],"categories":["设计模式"]},{"title":"常用网站清单","url":"/2018/09/09/list-sites/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](list-sites/sites.jpg)\n\n常用网站清单，记录一下方便日常使用，排名不分先后！持续更新！\n\n## 常用网站\n\n### 开发社区\n\n- [github](https://github.com)：全球最大的同性交友平台 >_>\n- [gitee](https://gitee.com/)：码云-github中国版\n- [stackoverflow](https://stackoverflow.com/)\n- [segmentfault](https://segmentfault.com/)\n- [掘金](https://juejin.im/timeline)\n- [CSDN](https://www.csdn.net/)\n- [博客园](https://www.cnblogs.com/)\n- [简书](https://www.jianshu.com/)\n\n### 团队组织\n\n- [美团点评技术团队](https://tech.meituan.com/)\n- [阿里中间件团队博客](http://jm.taobao.org/)\n- [FiT Design腾讯支付基金基础平台与金融引用线](http://fitdesign.tencent.com/)\n- [腾讯MXD移动互联网设计中心](http://mxd.tencent.com/)\n- [Alloy Team|腾讯前端Alloy Team团队](http://www.alloyteam.com/)\n- [IBM developer](https://www.ibm.com/developerworks/cn/java/)\n- [Java知音](https://www.javazhiyin.com/)：专注java后端的优质博客网站\n\n### 技术官网\n\n- [Spring](https://spring.io/)\n- [Mybatis](http://www.mybatis.org/)\n- [Hibernate](http://hibernate.org/)\n- [Angularjs](https://angularjs.org/)\n- [jquery](https://jquery.com/)\n- [Ehcache](http://www.ehcache.org/)\n- [Quartz](http://www.quartz-scheduler.org/)\n- [Zookeeper](http://zookeeper.apache.org/)\n- [Vertx](https://vertx.io/)\n- [Mysql](https://dev.mysql.com/)\n- [Oracle](https://www.oracle.com/index.html)\n- [Jenkins](https://jenkins.io)\n- [Gradle](https://gradle.org/)\n- [Maven](https://maven.apache.org/)\n\n### 小众网站\n\n- [ZCOOL](https://www.zcool.com.cn/)：中国最具人气的设计师互动平台\n\n### 在线工具\n\n- [JSON在线编辑器](https://www.qqe2.com/)：Cron、JSON、JS压缩、websocket测试、加解密、markdown、yaml在线编辑、随机工具\n- [在线工具](http://tool.oschina.net)：技术文档、对照表、格式化工具、压缩工具、加解密、正则\n- [比特虫](http://www.bitbug.net/)：ico图标在线制作\n- [jquery在线手册](http://www.jq22.com/chm/jquery/index.html)\n- [iconfont](http://www.iconfont.cn/)：阿里巴巴矢量图标库\n- [鸠摩搜书](https://www.jiumodiary.com/)\n\n### 工具插件\n\n- [Browsersync ](http://www.browsersync.cn/)：省时的浏览器同步测试工具\n\n### 开放平台\n\n- [百度开发者中心](https://developer.baidu.com/)\n- [腾讯开放平台](https://open.tencent.com/)\n- [微信公众平台](https://mp.weixin.qq.com)\n\n### 求职网站\n\n- [拉钩网](https://www.lagou.com/)\n- [Boss直聘](https://www.zhipin.com/?ka=header-home-logo)\n- [哪上班](https://www.nashangban.com/)\n\n### 高质量个人博客\n\n- [何海涛的日志](http://zhedahht.blog.163.com/blog/#m=0)\n- [骆昊的技术专栏](https://blog.csdn.net/jackfrued)\n- [五月的仓颉](https://www.cnblogs.com/xrq730/)\n- [占小狼](https://www.jianshu.com/u/90ab66c248e6)\n- [肥朝](https://www.jianshu.com/u/f7daa458b874)\n- [朱小厮的博客](https://blog.csdn.net/u013256816)\n- [纳达丶无忌](https://www.jianshu.com/u/957e5f43e612)\n- [惨绿少年](http://www.cnblogs.com/clsn/)\n\n### 其他网站清单\n\n- [极客学院Wiki](http://wiki.jikexueyuan.com/)\n- [前端导航](https://luuman.github.io/FrontEndGuideV2/FrontEndGuide/#/Index)：一个前端大神自己整理的资源列表\n- [前端网址导航](http://www.daqianduan.com/nav)\n\n### 待整理\n\n- [40个高质量Java开发者博客](https://blog.csdn.net/net19880504/article/details/20807403)","tags":["在线工具"],"categories":["lists"]},{"title":"我的画集","url":"/2018/09/07/my-pictures/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n嘿嘿，一点个人爱好，无聊时画画，欢迎批评指教。\n\n### 狗狗    ·2018-03-10\n可怜、萌萌的狗狗\n![狗狗·2018-03-10](my-pictures/dog.png)\n\n### 哈利波特    ·2018-03-11\n如果我不说这是哈利波特，希望你也能看的出来0.0\n![哈利波特·2018-03-11](my-pictures/halibote.png)\n\n### 应该是个什么明星吧    ·2018-03-14\n\n![小帅哥·2018-03-14](my-pictures/people.png)\n\n### 杨幂，大幂幂    ·2018-08-10\n画的匆忙，但是人物特点很明显，所以也传上来分享一下了。\n![杨幂·2018-08-10](my-pictures/yangmi.png)\n\n### 范爷\t·2018-08-25\n讲道理有点难画，没抓住特点，但也是个美女呀！\n![范冰冰·2018-08-25](my-pictures/fanbingbing.png)","tags":["素描"],"categories":["兴趣爱好"]},{"title":"【转载】nginx配置文件nginx.conf超详细讲解","url":"/2018/09/07/nginx-config/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](nginx-config/p4.jpg)\n\n> 原文地址：[nginx配置文件nginx.conf超详细讲解](https://www.cnblogs.com/liang-wei/p/5849771.html)\n\n## nginx.conf配置文件详解\n\n```conf\n# nginx进程,一般设置为和cpu核数一样\nworker_processes 4;\n                        \n# 错误日志存放目录 \nerror_log    /data1/logs/error.log  crit;\n  \n# 运行用户，默认即是nginx，可不设置\nuser    nginx;\n       \n# 进程pid存放位置\npid    /application/nginx/nginx.pid;        \n\n#Specifies the value for maximum file descriptors that can be opened by this process. \n# 最大文件打开数（连接），可设置为系统优化后的ulimit -HSn的结果\nworker_rlimit_nofile    51200;\n\n# cpu亲和力配置，让不同的进程使用不同的cpu\nworker_cpu_affinity    0001 0010 0100 1000 0001 00100100 1000;\n\n# 工作模式及连接数上限\nevents \n{\n    use epoll;        # epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能\n    worker_connections 1024;        # 单个后台worker process进程的最大并发链接数\n}\n###################################################\nhttp \n{\n    include mime.types;        # 文件扩展名与类型映射表\n    default_type application/octet-stream;    # 默认文件类型\n\n    # limit模块，可防范一定量的DDOS攻击\n    # 用来存储session会话的状态，如下是为session分配一个名为one的10M的内存存储区，限制了每秒只接受一个ip的一次请求 1r/s\n    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;\n    limit_conn_zone $binary_remote_addr zone=addr:10m;\n    include    mime.types;\n    default_type  application/octet-stream;\n\n    # 第三方模块lua防火墙\n    lua_need_request_body on;\n    #lua_shared_dict limit 50m;\n    lua_package_path \"/application/nginx/conf/waf/?.lua\";\n    init_by_lua_file \"/application/nginx/conf/waf/init.lua\";\n    access_by_lua_file \"/application/nginx/conf/waf/access.lua\";\n\n    # 设定请求缓存    \n    server_names_hash_bucket_size 128;\n    client_header_buffer_size 512k;\n    large_client_header_buffers 4 512k;\n    client_max_body_size 100m;\n\n    # 隐藏响应header和错误通知中的版本号\n    server_tokens off;\n    # 开启高效传输模式   \n    sendfile on;\n\n###################################################\n\n    # 激活tcp_nopush参数可以允许把httpresponse header和文件的开始放在一个文件里发布，积极的作用是减少网络报文段的数量\n    tcp_nopush    on;\n\n    # 激活tcp_nodelay，内核会等待将更多的字节组成一个数据包，从而提高I/O性能\n    tcp_nodelay    on;\n\n    # FastCGI相关参数：为了改善网站性能：减少资源占用，提高访问速度\n    fastcgi_connect_timeout    300;\n    fastcgi_send_timeout    300;\n    fastcgi_read_timeout    300;\n    fastcgi_buffer_size    64k;\n    fastcgi_buffers    4 64k;\n    fastcgi_busy_buffers_size    128k;\n    fastcgi_temp_file_write_size    128k;\n\n###################################################\n\n    # 连接超时时间，单位是秒\n    keepalive_timeout    60;\n\n    # 开启gzip压缩功能\n    gzip    on；\n\n    # 设置允许压缩的页面最小字节数，页面字节数从header头的Content-Length中获取。默认值是0，表示不管页面多大都进行压缩。建议设置成大于1K。如果小于1K可能会越压越大。\n    gzip_min_length    1k;\n\n    # 压缩缓冲区大小。表示申请4个单位为16K的内存作为压缩结果流缓存，默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果。\n    gzip_buffers    4 16k;\n\n    # 压缩版本（默认1.1，前端为squid2.5时使用1.0）用于设置识别HTTP协议版本，默认是1.1，目前大部分浏览器已经支持GZIP解压，使用默认即可。\n    gzip_http_version    1.0;\n\n    # 压缩比率。用来指定GZIP压缩比，1压缩比最小，处理速度最快；9压缩比最大，传输速度快，但处理最慢，也比较消耗cpu资源。\n    gzip_comp_level    9;\n\n    # 用来指定压缩的类型，“text/html”类型总是会被压缩\n    gzip_types    text/plain application/x-javascript text/css application/xml;\n\n    # vary header支持。该选项可以让前端的缓存服务器缓存经过GZIP压缩的页面，例如用Squid缓存经过Nginx压缩的数据。\n    gzip_vary    off;\n\n    # 开启ssi支持，默认是off\n    ssi    on;\n    ssi_silent_errors    on;\n\n    # 设置日志模式\n    log_format  access  ' $remote_addr - $remote_user [$time_local] \"$request\" '\n                                    ' $status $body_bytes_sent \"$http_referer\" '\n                                    ' \"$http_user_agent\" \"$http_x_forwarded_for\" ';\n\n    # 反向代理负载均衡设定部分\n\n    #upstream表示负载服务器池，定义名字为backend_server的服务器池\n    upstream backend_server {\n        server   10.254.244.20:81 weight=1 max_fails=2 fail_timeout=30s;\n        server   10.254.242.40:81 weight=1 max_fails=2 fail_timeout=30s;\n        server   10.254.245.19:81 weight=1 max_fails=2 fail_timeout=30s;\n        server   10.254.243.39:81 weight=1 max_fails=2 fail_timeout=30s;\n\n    # 设置由 fail_timeout 定义的时间段内连接该主机的失败次数，以此来断定 fail_timeout 定义的时间段内该主机是否可用。默认情况下这个数值设置为 1。零值的话禁用这个数量的尝试。\n    # 设置在指定时间内连接到主机的失败次数，超过该次数该主机被认为不可用。\n    # 这里是在30s内尝试2次失败即认为主机不可用！\n    }\n\n###################################################\n# 基于域名的虚拟主机\n    server \n    {\n        # 监听端口\n        listen       80;\n        server_name  www.abc.com abc.com;    \n        index index.html index.htm index.php;    # 首页排序\n        root  /data0/abc;    # 站点根目录，即网站程序存放目录 \n        error_page 500 502 404 /templates/kumi/phpcms/404.html;    # 错误页面\n\n        # 伪静态   将www.abc.com/list....html的文件转发到index.php。。。\n        #rewrite ^/list-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ /index.php?m=content&c=index&a=lists&catid=$1&types=$2&country=$3&language=$4&age=$5&startDate=$6&typeLetter=$7&type=$8&page=$9 last;\n        #location 标签，根目录下的.svn目录禁止访问\n        location ~ /.svn/ {\n            deny all;\n        }\n\n        location ~ \\.php$   \n            {  \n                #符合php扩展名的请求调度到fcgi server  \n                fastcgi_pass  127.0.0.1:9000;  #抛给本机的9000端口\n                fastcgi_index index.php;        #设定动态首页\n                include fcgi.conf;\n            }\n        allow   219.237.222.30 ;        # 允许访问的ip\n        allow   219.237.222.31 ;\n        allow   219.237.222.32 ;\n        allow   219.237.222.33 ;\n        allow   219.237.222.34 ;\n        allow   219.237.222.35 ;\n        allow   219.237.222.61 ;\n        allow   219.237.222.28 ;\n        deny    all;        # 禁止其他ip访问\n        }\n\n        location ~ ^/admin.php\n        {\n            location ~ \\.php$\n            {\n                fastcgi_pass  127.0.0.1:9000;\n                fastcgi_index index.php;\n                include fcgi.conf;\n            }\n            allow   219.237.222.30 ;\n            allow   219.237.222.31 ;\n            allow   219.237.222.32 ;\n            allow   219.237.222.33 ;\n            allow   219.237.222.34 ;\n            allow   219.237.222.35 ;\n            allow   219.237.222.61;\n            allow   219.237.222.28;\n            deny    all;\n        }\n\n# 将符合js,css文件的等设定expries缓存参数，要求浏览器缓存。\n\n        location~ .*\\.(js|css)?$ {\n\n            expires      30d; #客户端缓存上述js,css数据30天\n\n        }\n#################nginx防sql注入########################\n\n#####################start#############################\n        if ( $query_string ~* \".*[\\;'\\<\\>].*\" ){\n            return 444;\n        }\n        if ($query_string  ~* \".*(insert|select|delete|update|count|\\*|%|master|truncate|declare|\\'|\\;|and|or|\\(|\\)|exec).* \") {  \n            return 444; \n        }\n        if ($request_uri ~* \"(cost\\()|(concat\\()\") {\n            return 444;\n        }\n        if ($request_uri ~* \"[+|(%20)]union[+|(%20)]\") {\n            return 444;\n        }\n        if ($request_uri ~* \"[+|(%20)]and[+|(%20)]\") {\n            return 444;\n        }\n        if ($request_uri ~* \"[+|(%20)]select[+|(%20)]\") {\n            return 444;\n        }\n        set $block_file_injections 0;\n        if ($query_string ~ \"[a-zA-Z0-9_]=(\\.\\.//?)+\") {\n            set $block_file_injections 1;\n        }\n        if ($query_string ~ \"[a-zA-Z0-9_]=/([a-z0-9_.]//?)+\") {\n            set $block_file_injections 1;\n        }\n        if ($block_file_injections = 1) {\n            return 448;\n        }\n        set $block_common_exploits 0;\n        if ($query_string ~ \"(<|%3C).*script.*(>|%3E)\") {\n            set $block_common_exploits 1;\n        }\n        if ($query_string ~ \"GLOBALS(=|\\[|\\%[0-9A-Z]{0,2})\") {\n            set $block_common_exploits 1;\n        }\n        if ($query_string ~ \"_REQUEST(=|\\[|\\%[0-9A-Z]{0,2})\") {\n            set $block_common_exploits 1;\n        }\n        if ($query_string ~ \"proc/self/environ\") {\n            set $block_common_exploits 1;\n        }\n        if ($query_string ~ \"mosConfig_[a-zA-Z_]{1,21}(=|\\%3D)\") {\n            set $block_common_exploits 1;\n        }\n        if ($query_string ~ \"base64_(en|de)code\\(.*\\)\") {\n            set $block_common_exploits 1;\n        }\n        if ($block_common_exploits = 1) {\n            return 444;\n        }\n        set $block_spam 0;\n        if ($query_string ~ \"\\b(ultram|unicauca|valium|viagra|vicodin|xanax|ypxaieo)\\b\") {\n            set $block_spam 1;\n        }\n        if ($query_string ~ \"\\b(erections|hoodia|huronriveracres|impotence|levitra|libido)\\b\") {\n            set $block_spam 1;\n        }\n        if ($query_string ~ \"\\b(ambien|blue\\spill|cialis|cocaine|ejaculation|erectile)\\b\") {\n           set $block_spam 1;\n        }\n        if ($query_string ~ \"\\b(lipitor|phentermin|pro[sz]ac|sandyauer|tramadol|troyhamby)\\b\") {\n            set $block_spam 1;\n        }\n        if ($block_spam = 1) {\n            return 444;\n        }\n        set $block_user_agents 0;\n        if ($http_user_agent ~ \"Wget\") {\n            set $block_user_agents 1;\n        }\n        # Disable Akeeba Remote Control 2.5 and earlier\n        if ($http_user_agent ~ \"Indy Library\") {\n            set $block_user_agents 1;\n        }\n        # Common bandwidth hoggers and hacking tools.\n        if ($http_user_agent ~ \"libwww-perl\") {\n            set $block_user_agents 1;\n        }\n        if ($http_user_agent ~ \"GetRight\") {\n            set $block_user_agents 1;\n        }\n        if ($http_user_agent ~ \"GetWeb!\") {\n            set $block_user_agents 1;\n        }\n        if ($http_user_agent ~ \"Go!Zilla\") {\n            set $block_user_agents 1;\n        }\n        if ($http_user_agent ~ \"Download Demon\") {\n            set $block_user_agents 1;\n        }\n        if ($http_user_agent ~ \"Go-Ahead-Got-It\") {\n            set $block_user_agents 1;\n        }\n        if ($http_user_agent ~ \"TurnitinBot\") {\n            set $block_user_agents 1;\n        }\n        if ($http_user_agent ~ \"GrabNet\") {\n            set $block_user_agents 1;\n        }\n        if ($block_user_agents = 1) {\n            return 444;\n        }\n###################### end #############################\n         location ~ ^/list {\n             # 如果后端的服务器返回502、504、执行超时等错误，自动将请求转发到upstream负载均衡池中的另一台服务器，实现故障转移。\n             proxy_next_upstream    http_502    http_504    error timeout invalid_header;\n             proxy_cache    cache_one;\n             # 对不同的HTTP状态码设置不同的缓存时间\n             proxy_cache_valid    200    301    302    304    1d;\n             # proxy_cache_valid    any    1d;\n             # 以域名、URI、参数组合成Web缓存的Key值，Nginx根据Key值哈希，存储缓存内容到二级缓存目录内\n             proxy_cache_key    $host$uri$is_args$args;\n             proxy_set_header Host    $host;\n             proxy_set_header X-Forwarded-For    $remote_addr;\n             proxy_ignore_headers    \"Cache-Control\"    \"Expires\"    \"Set-Cookie\";\n             # proxy_ignore_headers    Set-Cookie;\n             # proxy_hide_header    Set-Cookie;\n             proxy_pass    http://backend_server;\n             add_header    Nginx-Cache    \"$upstream_cache_status  from  km\";\n             expires    1d;\n        }\n        access_log  /data1/logs/abc.com.log access;    #nginx访问日志\n    }\n\n####################ssl（https）相关####################\n\n    server {\n        listen    13820;        # 监听端口\n        server_name    localhost;\n        charset    utf-8;        # gbk,utf-8,gb2312,gb18030 可以实现多种编码识别\n　　 ssl    on;        # 开启ssl\n        ssl_certificate    /ls/app/nginx/conf/mgmtxiangqiankeys/server.crt;        # 服务的证书\n        ssl_certificate_key    /ls/app/nginx/conf/mgmtxiangqiankeys/server.key;        # 服务端key\n　　 ssl_client_certificate    /ls/app/nginx/conf/mgmtxiangqiankeys/ca.crt;        # 客户端证书\n　　ssl_session_timeout        5m;        # session超时时间\n　　ssl_verify_client    on;        # 开户客户端证书验证 \n　　ssl_protocols    SSLv2    SSLv3    TLSv1;        # 允许SSL协议 \n　　ssl_ciphers    ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;        # 加密算法\n　　ssl_prefer_server_ciphers    on;    # 启动加密算法\n　　access_log    /lw/logs/nginx/dataadmin.test.com.ssl.access.log    access;        # 日志格式及日志存放路径\n　　error_log    /lw/logs/nginx/dataadmin.test.com.ssl.error.log;        # 错误日志存放路径\n    }\n\n#####################################################\n\n}\n\n```\n## 极简配置\n```con\nworker_processes    2;\n\nevents {\n    worker_connections    1024;\n}\n\nhttp {\n    include    mime.types;\n    default_type    application/octet-stream;\n\n    sendfile    on;\n\n    keepalive_timeout    65;\n\n    server {\n        listen    80;\n        server_name    localhost;\n\n        location / {\n            root    html;\n            index    index.html    index.htm;\n        }\n\n        error_page    500    502    503    504    /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n\n    server {\n        listen    80;\n        server_name    www.yizhuxiaozhan.site;\n        index index.jsp    index.html index.html    index.shtml;\n        location / {\n            proxy_pass http://localhost:8081;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n    }\n}\n```\n","tags":["nginx"],"categories":["集成&运维"]},{"title":"创建线程的几种方式","url":"/2018/09/07/thread-realize/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](thread-realize/words14.jpg)\n\n## 继承Thread类\n\n```java\npublic class ExtendsThreadTest extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"thread is running！\");\n    }\n    public static void main(String[] args) {\n        ExtendsThreadTest et1 = new ExtendsThreadTest();\n        et1.start();\n    }\n}\n```\n\n---\n## 实现Runnable接口\n```java\npublic class RunnableTest implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(\"thread is running！\");\n    }\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new RunnableTest());\n        t1.start();\n    }\n}\n```\n\n---\n## 匿名内部类的两种写法\n```java\npublic class App {\n    public static void main(String[] args){\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"thread1 is running！\");\n            }\n        }){}.start();\n\n        new Thread(){\n            @Override\n            public void run(){\n                System.out.println(\"thread2 is running！\");\n            }\n        }.start();\n    }\n}\n```\n\n---\n## 基于java.util.concurrent.Callable工具类的实现，带返回值\n```java\npublic class CallableTest {\n    public static void main(String[] args) throws Exception {\n        Callable<Integer> call = new Callable<Integer>() {\n            @Override\n            public Integer call() throws Exception {\n                System.out.println(\"thread is running！\");\n                return 1;\n            }\n        };\n        FutureTask<Integer> task = new FutureTask<>(call);\n        Thread t =  new Thread(task);\n        t.start();\n    }\n}\n```\n\n---\n## 基于java.util.Timer工具类的实现\n```java\npublic class TimerTest {\n    public static void main(String[] args) throws Exception {\n        Timer timer = new Timer();\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                System.out.println(\"thread is running!\");\n            }\n        }, new Date());\n    }\n}\n```\n---\n## 基于java.util.concurrent.Executors工具类，基于线程池的实现\n```java\npublic class ThreadPoolTest {\n    public static void main(String[] args) {\n        // 创建线程池\n        ExecutorService threadPool = Executors.newFixedThreadPool(10);\n        while(true) {\n            threadPool.execute(new Runnable() { // 提交多个线程任务，并执行\n                @Override\n                public void run() {\n                    System.out.println(Thread.currentThread().getName() + \" is running ..\");\n                    try {\n                        Thread.sleep(3000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n    }\n}\n```\n\n","tags":["多线程"],"categories":["基础"]},{"title":"SpringBoot项目打包发布Linux环境完整流程","url":"/2018/09/07/springboot-app-deploy/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n![](springboot-app-deploy/words11.jpg)\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 环境说明\n\n> Linux机器环境：`CentOS 7.4 64位` + `JDK8` + `MySql5.6.41` + `Nginx-1.1.10`\n\n> 框架：`Spring Boot v2.0.4.RELEASE`,` Spring v5.0.8.RELEASE`\n\n## 安装JDK\n\n```\nyum install java-1.8.0-openjdk* -y\n```\n执行这条命令后若无报错，则jdk就下载并安装完成，到这里一般没什么问题。\n\n## 安装Mysql\n\n这里选择的是mysql5.6.41，可以在[这里](https://dev.mysql.com/downloads/repo/yum/)自己选择对应版本mysql，另外我这里把软件都安装在/usr/app目录下，方便管理。\n```\nwget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\nrpm -ivh mysql-community-release-el7-5.noarch.rpm\nyum install mysql-community-server\n```\n安装过程中会让你确认两次，输入‘y’就好，如下图\n![请输入图片描述](springboot-app-deploy/install-mysql.png)\n\n重启Mysql服务\n\n```\nservice mysqld restart\n```\n### 进入Mysql\n```\nmysql -u root\n```\n### 修改Mysql密码\n这里修改为root\n```\nset password for 'root'@'localhost' =password('root');\n```\n到这里Mysql就安装完成了，但是不能远程连接数据库的，下面设置mysql数据库远程连接权限\n### 设置mysql数据库远程连接权限\n```\ngrant all privileges on *.* to root@'%'identified by 'root';\n```\n\n## 安装Nginx\n\n### 安装C++环境\n\n```\nyum -y install gcc automake autoconf libtool make\nyum install gcc gcc-c++\n```\n### 安装Nginx依赖pcre库\n```\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz \ntar -zxvf pcre-8.39.tar.gz \ncd pcre-8.39\n./configure\nmake & make install\n```\n### 安装Nginx依赖zlib库\n\n```\nwget http://zlib.net/zlib-1.2.11.tar.gz\ntar -zxvf zlib-1.2.11.tar.gz\ncd zlib-1.2.11\n./configure\nmake & make install\n```\n### 安装openssl\n```\ncd ..\nwget https://www.openssl.org/source/openssl-1.0.1t.tar.gz\ntar -zxvf openssl-1.0.1t.tar.gz\n```\n### 安装nginx\n```\nwget http://nginx.org/download/nginx-1.1.10.tar.gz\ntar -zxvf nginx-1.1.10.tar.gz\ncd nginx-1.1.10\n./configure\nmake & make install\n```\n### 配置nginx\n在/usr/local/nginx/conf/nginx.conf文件中增加应用的反向代理配置，server_name 配置你要代理的域名，proxy_pass 配置本地应用访问地址\n```\n    server {\n        listen        80;\n        server_name   www.yizhuxiaozhan.club;\n        index index.jsp index.html index.html index.shtml;\n        location / {\n                proxy_pass http://localhost:8081;\n                proxy_set_header Host $host;\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                }\n        }\n```\n> nginx 相关命令:\n\n启动nginx\n```\n/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n```\n查找nginx PID\n```\nps -ef|grep nginx\n```\nnginx服务完当前任务停止服务\n```\nkill -QUIT 23205\n```\n## 打包发布\n首先，将本地代码打包成jar，然后将jar上传至服务器，最后用脚本启动\n### IDEA打包配置\n![请输入图片描述](springboot-app-deploy/repackage.png)\n\n### 上传打包完成的jar\n```\nrz -y\n```\n![请输入图片描述](springboot-app-deploy/upload-jar.png)\n若报错`-bash: rz: command not found`，则需要安装rz命令，安装好之后则可正常使用rz系列命令了\n\n```\nyum -y install lrzsz\n```\n在弹出窗口中选择打包好的jar包应用\n\n### 重启应用脚本\n```sh\n#!/bin/sh\nRESOURCE_NAME=my-blog-*.jar\n \ntpid=`ps -ef|grep $RESOURCE_NAME|grep -v grep|grep -v kill|awk '{print $2}'`\nif [ ${tpid} ]; then\necho 'Stop Process...'\nkill -15 $tpid\nfi\nsleep 5\ntpid=`ps -ef|grep $RESOURCE_NAME|grep -v grep|grep -v kill|awk '{print $2}'`\nif [ ${tpid} ]; then\necho 'Kill Process!'\nkill -9 $tpid\nelse\necho 'Stop Success!'\nfi\n \ntpid=`ps -ef|grep $RESOURCE_NAME|grep -v grep|grep -v kill|awk '{print $2}'`\nif [ ${tpid} ]; then\n    echo 'App is running.'\nelse\n    echo 'App is NOT running.'\nfi\n \nrm -f tpid\nnohup java -jar ./$RESOURCE_NAME >/dev/null 2>&1 &\necho $! > tpid\necho Start Success!\n```\n运行脚本的时候运行的时候如果报错，应该是文件格式转换的问题\n\n`bash: ./a.sh: /bin/bash^M: bad interpreter: No such file or directory`\n```\nyum -y install dos2unix\ndos2unix start.sh\n```\n## 重启服务\n> 注意：第一次运行的时候获取一下超级管理员权限\n```\nchmod +x start.sh\n```\n```\n./start.sh\n```\n\n","tags":["springboot"],"categories":["集成&运维"]},{"title":"【转载】ConcurrentHashMap原理分析","url":"/2018/09/07/concurrentHashMap-analyze/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](concurrentHashMap-analyze/words8.jpg)\n\n> 原文地址：[https://my.oschina.net/hosee/blog/639352#h2_9](https://my.oschina.net/hosee/blog/639352#h2_9)\n\n　　曾经在 [[高并发Java 五]JDK并发包1](https://my.oschina.net/hosee/blog/607677)  中提到过ConcurrentHashMap，只是简单的提到了下ConcurrentHashMap的优点，以及大概的实现原理。\n\n　　而本文则重点介绍ConcurrentHashMap实现的细节。\n\n　　HashMap就不介绍了，具体请查看JDK7与JDK8中HashMap的实现\n\n　　HashTable是一个线程安全的类，它使用synchronized来锁住整张Hash表来实现线程安全，即每次锁住整张表让线程独占。ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的Hashtable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。\n\n　　有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。\n\n## 实现原理\n　　ConcurrentHashMap使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。如下图是ConcurrentHashMap的内部结构图：\n　![这里写图片描述](concurrentHashMap-analyze/concurrenthashmap.png)\n\t从图中可以看到，ConcurrentHashMap内部分为很多个Segment，每一个Segment拥有一把锁，然后每个Segment（继承`ReentrantLock`）\n\t```\n\tstatic final class Segment<K,V> extends ReentrantLock implements Serializable\n\t```\n　　Segment继承了ReentrantLock，表明每个segment都可以当做一个锁。（ReentrantLock前文已经提到，不了解的话就把当做synchronized的替代者吧）这样对每个segment中的数据需要同步操作的话都是使用每个segment容器对象自身的锁来实现。只有对全局需要改变时锁定的是所有的segment。\n\n　　Segment下面包含很多个HashEntry列表数组。对于一个key，需要经过三次（为什么要hash三次下文会详细讲解）hash操作，才能最终定位这个元素的位置，这三次hash分别为：\n\n1. 对于一个key，先进行一次hash操作，得到hash值h1，也即h1 = hash1(key)；\n2. 将得到的h1的高几位进行第二次hash，得到hash值h2，也即h2 = hash2(h1高几位)，通过h2能够确定该元素的放在哪个Segment；\n3. 将得到的h1进行第三次hash，得到hash值h3，也即h3 = hash3(h1)，通过h3能够确定该元素放置在哪个HashEntry。\n\n    \nConcurrentHashMap中主要实体类就是三个：ConcurrentHashMap（整个Hash表）,Segment（桶），HashEntry（节点），对应上面的图可以看出之间的关系\n```\n/** \n* The segments, each of which is a specialized hash table \n*/  \nfinal Segment<K,V>[] segments;\n```\n　　不变(Immutable)和易变(Volatile)ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。HashEntry代表每个hash链中的一个节点，其结构如下所示\n```\nstatic final class HashEntry<K,V> {  \n     final K key;  \n     final int hash;  \n     volatile V value;  \n     volatile HashEntry<K,V> next;  \n }\n```\n\n　　在JDK 1.6中，HashEntry中的next指针也定义为final，并且每次插入将新添加节点作为链的头节点（同HashMap实现），而且每次删除一个节点时，会将删除节点之前的所有节点 拷贝一份组成一个新的链，而将当前节点的上一个节点的next指向当前节点的下一个节点，从而在删除以后 有两条链存在，因而可以保证即使在同一条链中，有一个线程在删除，而另一个线程在遍历，它们都能工作良好，因为遍历的线程能继续使用原有的链。因而这种实现是一种更加细粒度的happens-before关系，即如果遍历线程在删除线程结束后开始，则它能看到删除后的变化，如果它发生在删除线程正在执行中间，则它会使用原有的链，而不会等到删除线程结束后再执行，即看不到删除线程的影响。如果这不符合你的需求，还是乖乖的用Hashtable或HashMap的synchronized版本，Collections.synchronizedMap()做的包装。\n\n　　而HashMap中的Entry只有key是final的\n　　\n```\nstatic class Entry<K,V> implements Map.Entry<K,V> {\n        final K key;\n        V value;\n        Entry<K,V> next;\n        int hash;\n```\n\n　　**不变 模式（immutable）**是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。\n不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。\n\n### 初始化\n先看看ConcurrentHashMap的初始化做了哪些事情，构造函数的源码如下：\n```\npublic ConcurrentHashMap(int initialCapacity,\n                             float loadFactor, int concurrencyLevel) {\n        if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)\n            throw new IllegalArgumentException();\n        if (concurrencyLevel > MAX_SEGMENTS)\n            concurrencyLevel = MAX_SEGMENTS;\n        // Find power-of-two sizes best matching arguments\n        int sshift = 0;\n        int ssize = 1;\n        while (ssize < concurrencyLevel) {\n            ++sshift;\n            ssize <<= 1;\n        }\n        this.segmentShift = 32 - sshift;\n        this.segmentMask = ssize - 1;\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        int c = initialCapacity / ssize;\n        if (c * ssize < initialCapacity)\n            ++c;\n        int cap = MIN_SEGMENT_TABLE_CAPACITY;\n        while (cap < c)\n            cap <<= 1;\n        // create segments and segments[0]\n        Segment<K,V> s0 =\n            new Segment<K,V>(loadFactor, (int)(cap * loadFactor),\n                             (HashEntry<K,V>[])new HashEntry[cap]);\n        Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];\n        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n        this.segments = ss;\n    }\n```\n\n传入的参数有initialCapacity，loadFactor，concurrencyLevel这三个。\n\n- initialCapacity表示新创建的这个ConcurrentHashMap的初始容量，也就是上面的结构图中的Entry数量。默认值为static final int DEFAULT_INITIAL_CAPACITY = 16;\n- loadFactor表示负载因子，就是当ConcurrentHashMap中的元素个数大于loadFactor * 最大容量时就需要rehash，扩容。默认值为static final float DEFAULT_LOAD_FACTOR = 0.75f;\n- concurrencyLevel表示并发级别，这个值用来确定Segment的个数，Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数。比如，如果concurrencyLevel为12，13，14，15，16这些数，则Segment的数目为16(2的4次方)。默认值为static final int DEFAULT_CONCURRENCY_LEVEL = 16;。理想情况下ConcurrentHashMap的真正的并发访问量能够达到concurrencyLevel，因为有concurrencyLevel个Segment，假如有concurrencyLevel个线程需要访问Map，并且需要访问的数据都恰好分别落在不同的Segment中，则这些线程能够无竞争地自由访问（因为他们不需要竞争同一把锁），达到同时访问的效果。这也是为什么这个参数起名为“并发级别”的原因。\n\n初始化的一些动作：\n\n1. 验证参数的合法性，如果不合法，直接抛出异常。\n2. concurrencyLevel也就是Segment的个数不能超过规定的最大Segment的个数，默认值为static final int MAX_SEGMENTS = 1 << 16;，如果超过这个值，设置为这个值。\n3. 然后使用循环找到大于等于concurrencyLevel的第一个2的n次方的数ssize，这个数就是Segment数组的大小，并记录一共向左按位移动的次数sshift，并令segmentShift = 32 - sshift，并且segmentMask的值等于ssize - 1，segmentMask的各个二进制位都为1，目的是之后可以通过key的hash值与这个值做&运算确定Segment的索引。\n4. 检查给的容量值是否大于允许的最大容量值，如果大于该值，设置为该值。最大容量值为static final int MAXIMUM_CAPACITY = 1 << 30;。\n5. 然后计算每个Segment平均应该放置多少个元素，这个值c是向上取整的值。比如初始容量为15，Segment个数为4，则每个Segment平均需要放置4个元素。\n6. 最后创建一个Segment实例，将其当做Segment数组的第一个元素。\n### put操作\n\nput操作的源码如下：\n```\npublic V put(K key, V value) {\n      Segment<K,V> s;\n      if (value == null)\n          throw new NullPointerException();\n      int hash = hash(key);\n      int j = (hash >>> segmentShift) & segmentMask;\n      if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck\n           (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment\n          s = ensureSegment(j);\n      return s.put(key, hash, value, false);\n  }\n```\n操作步骤如下：\n\n1. 判断value是否为null，如果为null，直接抛出异常。\n2. key通过一次hash运算得到一个hash值。(这个hash运算下文详说)\n3. 将得到hash值向右按位移动segmentShift位，然后再与segmentMask做&运算得到segment的索引j。\n    在初始化的时候我们说过segmentShift的值等于32-sshift，例如concurrencyLevel等于16，则sshift等于4，则segmentShift为28。hash值是一个32位的整数，将其向右移动28位就变成这个样子：\n    0000 0000 0000 0000 0000 0000 0000 xxxx，然后再用这个值与segmentMask做&运算，也就是取最后四位的值。这个值确定Segment的索引。\n4. 使用Unsafe的方式从Segment数组中获取该索引对应的Segment对象。\n5. 向这个Segment对象中put值，这个put操作也基本是一样的步骤（通过&运算获取HashEntry的索引，然后set）。\n\n```\nfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n            HashEntry<K,V> node = tryLock() ? null :\n                scanAndLockForPut(key, hash, value);\n            V oldValue;\n            try {\n                HashEntry<K,V>[] tab = table;\n                int index = (tab.length - 1) & hash;\n                HashEntry<K,V> first = entryAt(tab, index);\n                for (HashEntry<K,V> e = first;;) {\n                    if (e != null) {\n                        K k;\n                        if ((k = e.key) == key ||\n                            (e.hash == hash && key.equals(k))) {\n                            oldValue = e.value;\n                            if (!onlyIfAbsent) {\n                                e.value = value;\n                                ++modCount;\n                            }\n                            break;\n                        }\n                        e = e.next;\n                    }\n                    else {\n                        if (node != null)\n                            node.setNext(first);\n                        else\n                            node = new HashEntry<K,V>(hash, key, value, first);\n                        int c = count + 1;\n                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                            rehash(node);\n                        else\n                            setEntryAt(tab, index, node);\n                        ++modCount;\n                        count = c;\n                        oldValue = null;\n                        break;\n                    }\n                }\n            } finally {\n                unlock();\n            }\n            return oldValue;\n        }\n```\nput操作是要加锁的。\n\n### get操作\nget操作的源码如下：\n```\npublic V get(Object key) {\n        Segment<K,V> s; // manually integrate access methods to reduce overhead\n        HashEntry<K,V>[] tab;\n        int h = hash(key);\n        long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n        if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n            (tab = s.table) != null) {\n            for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                     (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n                 e != null; e = e.next) {\n                K k;\n                if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                    return e.value;\n            }\n        }\n        return null;\n    }\n```\n操作步骤为：\n\n1. 和put操作一样，先通过key进行两次hash确定应该去哪个Segment中取数据。\n2. 使用Unsafe获取对应的Segment，然后再进行一次&运算得到HashEntry链表的位置，然后从链表头开始遍历整个链表（因为Hash可能会有碰撞，所以用一个链表保存），如果找到对应的key，则返回对应的value值，如果链表遍历完都没有找到对应的key，则说明Map中不包含该key，返回null。\n\n值得注意的是，get操作是不需要加锁的（如果value为null，会调用readValueUnderLock，只有这个步骤会加锁），通过前面提到的volatile和final来确保数据安全。\n\n### size操作\n\n　　size操作与put和get操作最大的区别在于，size操作需要遍历所有的Segment才能算出整个Map的大小，而put和get都只关心一个Segment。假设我们当前遍历的Segment为SA，那么在遍历SA过程中其他的Segment比如SB可能会被修改，于是这一次运算出来的size值可能并不是Map当前的真正大小。所以一个比较简单的办法就是计算Map大小的时候所有的Segment都Lock住，不能更新(包含put，remove等等)数据，计算完之后再Unlock。这是普通人能够想到的方案，但是牛逼的作者还有一个更好的Idea：先给3次机会，不lock所有的Segment，遍历所有Segment，累加各个Segment的大小得到整个Map的大小，如果某相邻的两次计算获取的所有Segment的更新的次数（每个Segment都有一个modCount变量，这个变量在Segment中的Entry被修改时会加一，通过这个值可以得到每个Segment的更新操作的次数）是一样的，说明计算过程中没有更新操作，则直接返回这个值。如果这三次不加锁的计算过程中Map的更新次数有变化，则之后的计算先对所有的Segment加锁，再遍历所有Segment计算Map大小，最后再解锁所有Segment。源代码如下：\n```\npublic int size() {\n        // Try a few times to get accurate count. On failure due to\n        // continuous async changes in table, resort to locking.\n        final Segment<K,V>[] segments = this.segments;\n        int size;\n        boolean overflow; // true if size overflows 32 bits\n        long sum;         // sum of modCounts\n        long last = 0L;   // previous sum\n        int retries = -1; // first iteration isn't retry\n        try {\n            for (;;) {\n                if (retries++ == RETRIES_BEFORE_LOCK) {\n                    for (int j = 0; j < segments.length; ++j)\n                        ensureSegment(j).lock(); // force creation\n                }\n                sum = 0L;\n                size = 0;\n                overflow = false;\n                for (int j = 0; j < segments.length; ++j) {\n                    Segment<K,V> seg = segmentAt(segments, j);\n                    if (seg != null) {\n                        sum += seg.modCount;\n                        int c = seg.count;\n                        if (c < 0 || (size += c) < 0)\n                            overflow = true;\n                    }\n                }\n                if (sum == last)\n                    break;\n                last = sum;\n            }\n        } finally {\n            if (retries > RETRIES_BEFORE_LOCK) {\n                for (int j = 0; j < segments.length; ++j)\n                    segmentAt(segments, j).unlock();\n            }\n        }\n        return overflow ? Integer.MAX_VALUE : size;\n    }\n```\n举个例子：\n> 一个Map有4个Segment，标记为S1，S2，S3，S4，现在我们要获取Map的size。计算过程是这样的：第一次计算，不对S1，S2，S3，S4加锁，遍历所有的Segment，假设每个Segment的大小分别为1，2，3，4，更新操作次数分别为：2，2，3，1，则这次计算可以得到Map的总大小为1+2+3+4=10，总共更新操作次数为2+2+3+1=8；第二次计算，不对S1,S2,S3,S4加锁，遍历所有Segment，假设这次每个Segment的大小变成了2，2，3，4，更新次数分别为3，2，3，1，因为两次计算得到的Map更新次数不一致(第一次是8，第二次是9)则可以断定这段时间Map数据被更新，则此时应该再试一次；第三次计算，不对S1，S2，S3，S4加锁，遍历所有Segment，假设每个Segment的更新操作次数还是为3，2，3，1，则因为第二次计算和第三次计算得到的Map的更新操作的次数是一致的，就能说明第二次计算和第三次计算这段时间内Map数据没有被更新，此时可以直接返回第三次计算得到的Map的大小。最坏的情况：第三次计算得到的数据更新次数和第二次也不一样，则只能先对所有Segment加锁再计算最后解锁。\n\n### containsValue操作\ncontainsValue操作采用了和size操作一样的想法:\n```\npublic boolean containsValue(Object value) {\n        // Same idea as size()\n        if (value == null)\n            throw new NullPointerException();\n        final Segment<K,V>[] segments = this.segments;\n        boolean found = false;\n        long last = 0;\n        int retries = -1;\n        try {\n            outer: for (;;) {\n                if (retries++ == RETRIES_BEFORE_LOCK) {\n                    for (int j = 0; j < segments.length; ++j)\n                        ensureSegment(j).lock(); // force creation\n                }\n                long hashSum = 0L;\n                int sum = 0;\n                for (int j = 0; j < segments.length; ++j) {\n                    HashEntry<K,V>[] tab;\n                    Segment<K,V> seg = segmentAt(segments, j);\n                    if (seg != null && (tab = seg.table) != null) {\n                        for (int i = 0 ; i < tab.length; i++) {\n                            HashEntry<K,V> e;\n                            for (e = entryAt(tab, i); e != null; e = e.next) {\n                                V v = e.value;\n                                if (v != null && value.equals(v)) {\n                                    found = true;\n                                    break outer;\n                                }\n                            }\n                        }\n                        sum += seg.modCount;\n                    }\n                }\n                if (retries > 0 && sum == last)\n                    break;\n                last = sum;\n            }\n        } finally {\n            if (retries > RETRIES_BEFORE_LOCK) {\n                for (int j = 0; j < segments.length; ++j)\n                    segmentAt(segments, j).unlock();\n            }\n        }\n        return found;\n    }\n```\n\n## 关于hash\n看看hash的源代码：\n```\nprivate int hash(Object k) {\n        int h = hashSeed;\n\n        if ((0 != h) && (k instanceof String)) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // Spread bits to regularize both segment and index locations,\n        // using variant of single-word Wang/Jenkins hash.\n        h += (h <<  15) ^ 0xffffcd7d;\n        h ^= (h >>> 10);\n        h += (h <<   3);\n        h ^= (h >>>  6);\n        h += (h <<   2) + (h << 14);\n        return h ^ (h >>> 16);\n    }\n```\n源码中的注释是这样的：\n> Applies a supplemental hash function to a given hashCode, which defends against poor quality hash functions. This is critical because ConcurrentHashMap uses power-of-two length hash tables, that otherwise encounter collisions for hashCodes that do not differ in lower or upper bits.\n\n　　这里用到了Wang/Jenkins hash算法的变种，主要的目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。\n\n举个简单的例子：\n```\nSystem.out.println(Integer.parseInt(\"0001111\", 2) & 15);\nSystem.out.println(Integer.parseInt(\"0011111\", 2) & 15);\nSystem.out.println(Integer.parseInt(\"0111111\", 2) & 15);\nSystem.out.println(Integer.parseInt(\"1111111\", 2) & 15);\n```\n　　这些数字得到的hash值都是一样的，全是15，所以如果不进行第一次预hash，发生冲突的几率还是很大的，但是如果我们先把上例中的二进制数字使用hash()函数先进行一次预hash，得到的结果是这样的：\n> 0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110 1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000 0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110 1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010\n\n上面这个例子引用自:  [InfoQ](http://www.infoq.com/cn/articles/ConcurrentHashMap/)\n\n可以看到每一位的数据都散开了，并且ConcurrentHashMap中是使用预hash值的高位参与运算的。比如之前说的先将hash值向右按位移动28位，再与15做&运算，得到的结果都别为：4，15，7，8，没有冲突！\n\n## 注意事项\n- ConcurrentHashMap中的key和value值都不能为null，HashMap中key可以为null，HashTable中key不能为null。\n- ConcurrentHashMap是线程安全的类并不能保证使用了ConcurrentHashMap的操作都是线程安全的！\n- ConcurrentHashMap的get操作不需要加锁，put操作需要加锁\n\nReference：\n1. http://www.cnblogs.com/ITtangtang/p/3948786.html\n2. [http://qifuguang.me/2015/09/10/](Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E5%85%AB]%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90ConcurrentHashMap/)\n3. http://www.cnblogs.com/yydcdut/p/3959815.html","tags":["ConcurrentHashMap"],"categories":["源码分析"]},{"title":"技能树","url":"/2018/09/07/tree-skills/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n　　最近在总结技能树，打算先拓宽下视野和技术的广度，后面会详细研究每个常用的技术点，补充技术的深度！下面是我在ProcessOn上总结的，里面有些有注释，点击[**这里**](https://www.processon.com/i/5aacfa26e4b0f68cc01c8b7a)注册ProcessOn，点击[**这里**](https://www.processon.com/view/5ad06c97e4b0518eacacdfa8)，可查看或克隆，后续还会不定期补充完善。如果觉得哪里分类或者总结的不太合理，欢迎留言拍砖！\n\n<iframe id=\"embed_dom\" name=\"embed_dom\" frameborder=\"0\" style=\"display:block;width:1465px; height:1400px;\" src=\"https://www.processon.com/embed/mind/5ad06c97e4b0518eacacdfa8\"></iframe>","tags":["总结"],"categories":["tree"]},{"title":"设计模式之---汇总","url":"/2018/09/07/pattern-all/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](pattern-all/words4.jpg)\n\n> 说明：本系列所有实现方式都是基于`java`语言实现，由于设计模式种类众多此处`并未能包含所有设计模式`。\n## 定义\n**模式**：模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。【A pattern is a successful or efficient solution to a recurring  problem within a context】\n\n**设计模式**：设计模式设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。\n\n## 七大设计原则\n- `单一职责原则`(Single Responsibility Principle, SRP)\n  - 一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n- `开闭原则`(Open-Closed Principle, OCP)\n  - 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。\n- `里氏代换原则`(Liskov Substitution Principle, LSP)\n  - 所有引用基类（父类）的地方必须能透明地使用其子类的对象。\n- `依赖倒转原则`(Dependence  Inversion Principle, DIP)\n  - 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n- `接口隔离原则`(Interface Segregation Principle, ISP)\n  - 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。\n- `合成复用原则`(Composite Reuse Principle, CRP)\n  - 尽量使用对象组合，而不是继承来达到复用的目的。\n- `迪米特法则`(Law of Demeter, LoD)\n  - 一个软件实体应当尽可能少地与其他实体发生相互作用。\n\n## GoF 23种设计模式\n### 创建型模式\n- `工厂方法模式`(Factory Method)\n- `抽象工厂模式`(Abstract Factory)\n- `建造者模式`(Builder)\n- `原型模式`(Prototype)\n- [`单例模式`(Singleton)](https://www.yizhuxiaozhan.site/2018/09/10/pattern-singleton/)\n### 结构型模式\n- `代理模式`(Proxy)\n- `适配器模式`(Adapter)\n- `桥接模式`(Bridge)\n- `组合模式`(Composite)\n- `装饰者模式`(Decorator)\n- `门面模式`/`外观模式`(Facade)\n- `享元模式`(Flyweight)\n### 行为型模式\n- `解释器模式`(Interpreter)\n- `模板方法模式`(Template Method)\n- `责任链模式`/`职责链模式`(Chain of Responsibility)\n- `命令模式`(Command)\n- `迭代器模式`(Iterator)\n- `调解者模式`/`中介者模式`(Mediator)\n- `备忘录模式`(Memento)\n- `观察者模式`(Observer)\n- `状态模式`(State)\n- `策略模式`(Strategy)\n- `访问者模式`(Visitor)\n### GoF 23种设计模式之间的关系图\n**![yangmi](pattern-all/patterns.jpg)**\n\n## 其他常见设计模式\n- `简单工厂模式`（Simple Factory ）\n- `委派模式`（Delegate）\n- `过滤器模式`/`标准模式`（Filter、Criteria）\n- `空对象模式`（Null Object）\n### J2EE 模式\n- `MVC 模式`（MVC）\n- `业务代表模式`（Business Delegate）\n- `组合实体模式`（Composite Entity）\n- `数据访问对象模式`（Data Access Object）\n- `前端控制器模式`（Front Controller）\n- `拦截过滤器模式`（Intercepting Filter）\n- `服务定位器模式`（Service Locator）\n- `传输对象模式`（Transfer Object）\n## 参考文章：\n[https://blog.csdn.net/lovelion/article/details/17517213/](https://blog.csdn.net/lovelion/article/details/17517213/)","tags":["总结"],"categories":["设计模式"]},{"title":"SpringBoot源码分析之---SpringBoot项目启动类SpringApplication浅析","url":"/2018/09/06/springApplication-analyze/","content":"\n** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n![](springApplication-analyze/words12.jpg)\n\n## 源码版本说明\n\n> 本文源码采用版本为`SpringBoot 2.1.0BUILD`,对应的`SpringFramework 5.1.0.RC1`\n\n> 注意：本文只是从整体上梳理流程，不做具体深入分析\n\n## SpringBoot入口类\n``` java\n@SpringBootApplication \npublic class DemoApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DemoApplication.class, args);\n\t}\n}\n```\n　　这是我们日常使用springboot开发见到次数最多的引导类了，完成这个类的编写，就完成了一个springboot项目的框架，springboot就回自动为我们完成一些默认配置，并帮我们初始化上下文容器，但细节我们是不知道的，下面我们就一起探索下`SpringApplication.run(DemoApplication .class, args);`这行代码背后的故事！\n\n## SpringApplication初始化阶段\n```java\npublic SpringApplication(Class<?>... primarySources) {\n\tthis(null, primarySources);\n}\n\n// 初始化准备阶段\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n\tthis.resourceLoader = resourceLoader;\n\tAssert.notNull(primarySources, \"PrimarySources must not be null\");\n\t// 参数初始化\n\tthis.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n\t// 推断应用类型\n\tthis.webApplicationType = deduceWebApplicationType();\n\t// 加载ApplicationContextInitializer系列初始化器（从spring.factories文件加载，并实例化和排序后存到this.initializers）\n\tsetInitializers((Collection) getSpringFactoriesInstances(\n\t\t\tApplicationContextInitializer.class));\n\t// 加载ApplicationListener系列监听器（从spring.factories文件加载，并实例化和排序后存到this.listeners）\n\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n\t// 推断应用入口类（main函数所在类）\n\tthis.mainApplicationClass = deduceMainApplicationClass();\n}\n```\n### 推断应用类型\n```java\n// 推断应用类型\nthis.webApplicationType = deduceWebApplicationType();\n```\n```java\nprivate WebApplicationType deduceWebApplicationType() {\n\tif (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null)\n\t\t\t&& !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)\n\t\t\t&& !ClassUtils.isPresent(JERSEY_WEB_ENVIRONMENT_CLASS, null)) {\n\t\treturn WebApplicationType.REACTIVE;\n\t}\n\tfor (String className : WEB_ENVIRONMENT_CLASSES) {\n\t\tif (!ClassUtils.isPresent(className, null)) {\n\t\t\treturn WebApplicationType.NONE;\n\t\t}\n\t}\n\treturn WebApplicationType.SERVLET;\n}\n```\n```java\nprivate static final String REACTIVE_WEB_ENVIRONMENT_CLASS = \"org.springframework.\"\n\t\t+ \"web.reactive.DispatcherHandler\";\n\nprivate static final String MVC_WEB_ENVIRONMENT_CLASS = \"org.springframework.\"\n\t\t+ \"web.servlet.DispatcherServlet\";\n\nprivate static final String JERSEY_WEB_ENVIRONMENT_CLASS = \"org.glassfish.jersey.server.ResourceConfig\";\n\nprivate static final String[] WEB_ENVIRONMENT_CLASSES = { \"javax.servlet.Servlet\",\n\t\t\"org.springframework.web.context.ConfigurableWebApplicationContext\" };\n```\n根据当前应用ClassPath下是否存在相关类，来确定应用类型。\n### 加载`ApplicationContextInitializer`系列初始化器\n```java\n// 加载ApplicationContextInitializer系列初始化器（从spring.factories文件加载，并实例化和排序后存到this.initializers）\nsetInitializers((Collection) getSpringFactoriesInstances(\n\t\tApplicationContextInitializer.class));\n```\n```java\npublic void setInitializers(\n\t\tCollection<? extends ApplicationContextInitializer<?>> initializers) {\n\tthis.initializers = new ArrayList<>();\n\tthis.initializers.addAll(initializers);\n}\n```\n```java\nprivate <T> Collection<T> getSpringFactoriesInstances(Class<T> type) {\n\treturn getSpringFactoriesInstances(type, new Class<?>[] {});\n}\n```\n```java\nprivate <T> Collection<T> getSpringFactoriesInstances(Class<T> type,\n\t\tClass<?>[] parameterTypes, Object... args) {\n\tClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\t// Use names and ensure unique to protect against duplicates\n\tSet<String> names = new LinkedHashSet<>(\n\t\t\tSpringFactoriesLoader.loadFactoryNames(type, classLoader));\n\tList<T> instances = createSpringFactoriesInstances(type, parameterTypes,\n\t\t\tclassLoader, args, names);\n\tAnnotationAwareOrderComparator.sort(instances);\n\treturn instances;\n}\n```\n```java\n@SuppressWarnings(\"unchecked\")\nprivate <T> List<T> createSpringFactoriesInstances(Class<T> type,\n\t\tClass<?>[] parameterTypes, ClassLoader classLoader, Object[] args,\n\t\tSet<String> names) {\n\tList<T> instances = new ArrayList<>(names.size());\n\tfor (String name : names) {\n\t\ttry {\n\t\t\tClass<?> instanceClass = ClassUtils.forName(name, classLoader);\n\t\t\tAssert.isAssignable(type, instanceClass);\n\t\t\tConstructor<?> constructor = instanceClass\n\t\t\t\t\t.getDeclaredConstructor(parameterTypes);\n\t\t\tT instance = (T) BeanUtils.instantiateClass(constructor, args);\n\t\t\tinstances.add(instance);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Cannot instantiate \" + type + \" : \" + name, ex);\n\t\t}\n\t}\n\treturn instances;\n}\n```\n　　利用Spring工厂加载机制，实例化ApplicationContextInitializer接口的实现类，被加载的实现类都配置在`MATE-INF/spring.factories`文件中，`getSpringFactoriesInstances(Class<T> type,Class<?>[] parameterTypes, Object... args)`这个方法就负责加载配置类并实例化和排序后返回，后面监听器、异常收集器和Runner等也是通过这个类实现实例化对应实现类的。下面是`spring-boot-autoconfigure\\src\\main\\resources\\META-INF\\spring.factories`文件的配置内容。\n```factories\n# Initializers\norg.springframework.context.ApplicationContextInitializer=\\\norg.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\\norg.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener\n\n# Application Listeners\norg.springframework.context.ApplicationListener=\\\norg.springframework.boot.autoconfigure.BackgroundPreinitializer\n\n# Auto Configuration Import Listeners\norg.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\\norg.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener\n\n# Auto Configuration Import Filters\norg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\\norg.springframework.boot.autoconfigure.condition.OnClassCondition\n\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\\norg.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\\norg.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration\n\n# Failure analyzers\norg.springframework.boot.diagnostics.FailureAnalyzer=\\\norg.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\\\norg.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\\\norg.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer\n\n# Template availability providers\norg.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\\\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\\\norg.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\\\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\\\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\\\norg.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider\n\n```\n### 加载ApplicationListener系列监听器\n```java\n// 加载ApplicationListener系列监听器（从spring.factories文件加载，并实例化和排序后存到this.listeners）\nsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n```\n```java\npublic void setListeners(Collection<? extends ApplicationListener<?>> listeners) {\n\tthis.listeners = new ArrayList<>();\n\tthis.listeners.addAll(listeners);\n}\n```\n\n```java\nprivate <T> Collection<T> getSpringFactoriesInstances(Class<T> type) {\n\treturn getSpringFactoriesInstances(type, new Class<?>[] {});\n}\n```\n　　如上面的初始化器，`ApplicationListener`系列监听器也是通过`getSpringFactoriesInstances(Class<T> type,\n\t\t\tClass<?>[] parameterTypes, Object... args)`这个方法完成加载、排序及实例化的，而后存入到`this.listeners`中。\n\n### 推断应用入口类\n```java\n// 推断应用入口类（main函数所在类）\nthis.mainApplicationClass = deduceMainApplicationClass();\n```\n```java\nprivate Class<?> deduceMainApplicationClass() {\n\ttry {\n\t\t// 通过new一个运行时异常获取堆栈信息\n\t\tStackTraceElement[] stackTrace = new RuntimeException().getStackTrace();\n\t\tfor (StackTraceElement stackTraceElement : stackTrace) {\n\t\t\t// 找到main函数所在的入口类\n\t\t\tif (\"main\".equals(stackTraceElement.getMethodName())) {\n\t\t\t\treturn Class.forName(stackTraceElement.getClassName());\n\t\t\t}\n\t\t}\n\t}\n\tcatch (ClassNotFoundException ex) {\n\t\t// Swallow and continue\n\t}\n\treturn null;\n}\n```\n　　推断应用入口类这部分比较有意思，他是通过new了一个运行时异常来拿到main线程的堆栈信息，遍历所有方法找到main方法所在的类。\n## 运行阶段\n```java\n// 运行阶段\npublic ConfigurableApplicationContext run(String... args) {\n\t// 初始化容器启动计时器\n\tStopWatch stopWatch = new StopWatch();\n\t// 开始计时\n\tstopWatch.start();\n\t// 初始化上下文ConfigurableApplicationContext\n\tConfigurableApplicationContext context = null;\n\t// 初始化异常收集器\n\tCollection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n\t// 配置系统参数\"java.awt.headless\"\n\tconfigureHeadlessProperty();\n\t// 获取SpringApplicationRunListener系列监听器（从spring.factories文件加载，并实例化和排序）\n\tSpringApplicationRunListeners listeners = getRunListeners(args);\n\t// 遍历所有SpringApplicationRunListener系列监听器，广播ApplicationStartingEvent\n\tlisteners.starting();\n\ttry {\n\t\t// 处理args参数\n\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(\n\t\t\t\targs);\n\t\t// 准备环境（创建、配置、绑定环境、广播ApplicationEnvironmentPreparedEvent）\n\t\tConfigurableEnvironment environment = prepareEnvironment(listeners,\n\t\t\t\tapplicationArguments);\n\t\tconfigureIgnoreBeanInfo(environment);\n\t\t// 打印Banner\n\t\tBanner printedBanner = printBanner(environment);\n\t\t// 根据应用类型创建上下文\n\t\tcontext = createApplicationContext();\n\t\t// 获取SpringBootExceptionReporter系列异常收集器（从spring.factories文件加载，并实例化和排序）\n\t\texceptionReporters = getSpringFactoriesInstances(\n\t\t\t\tSpringBootExceptionReporter.class,\n\t\t\t\tnew Class[] { ConfigurableApplicationContext.class }, context);\n\t\t// 上下文前置处理（执行ApplicationContextInitializer系列初始化器、加载资源、广播ApplicationPreparedEvent）\n\t\tprepareContext(context, environment, listeners, applicationArguments,\n\t\t\t\tprintedBanner);\n\t\t// 刷新上下文（）\n\t\trefreshContext(context);\n\t\t// 上下文后置处理(目前啥也没干)\n\t\tafterRefresh(context, applicationArguments);\n\t\t// 启动完成，打印用时\n\t\tstopWatch.stop();\n\t\tif (this.logStartupInfo) {\n\t\t\tnew StartupInfoLogger(this.mainApplicationClass)\n\t\t\t\t\t.logStarted(getApplicationLog(), stopWatch);\n\t\t}\n\t\t// 遍历前面设置的ConfigurableApplicationContext监听器，发布ApplicationStartedEvent\n\t\tlisteners.started(context);\n\t\t// 按顺序回调实现了ApplicationRunner或CommandLineRunner接口的Runners\n\t\tcallRunners(context, applicationArguments);\n\t}\n\tcatch (Throwable ex) {\n\t\t// 处理异常（发布ExitCodeEvent和ApplicationFailedEvent事件、异常收集器处理异常）\n\t\thandleRunFailure(context, ex, exceptionReporters, listeners);\n\t\tthrow new IllegalStateException(ex);\n\t}\n\n\ttry {\n\t\t// 遍历前面设置好的SpringApplicationRunListener监听器，发布ApplicationReadyEvent\n\t\tlisteners.running(context);\n\t}\n\tcatch (Throwable ex) {\n\t\thandleRunFailure(context, ex, exceptionReporters, null);\n\t\tthrow new IllegalStateException(ex);\n\t}\n\treturn context;\n}\n```\n### 获取`SpringApplicationRunListener`系列监听器\n```java\n// 获取SpringApplicationRunListener系列监听器（从spring.factories文件加载，并实例化和排序）\nSpringApplicationRunListeners listeners = getRunListeners(args);\n```\n```java\nprivate SpringApplicationRunListeners getRunListeners(String[] args) {\n\tClass<?>[] types = new Class<?>[] { SpringApplication.class, String[].class };\n\treturn new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(\n\t\t\tSpringApplicationRunListener.class, types, this, args));\n}\n```\n　　这里我们再一次见到`getSpringFactoriesInstances(Class<T> type,Class<?>[] parameterTypes, Object... args)`这个方法，功能同上。\n### 广播`ApplicationStartingEvent`事件\n```java\n// 遍历所有SpringApplicationRunListener系列监听器，广播ApplicationStartingEvent\nlisteners.starting();\n```\n```java\npublic void starting() {\n\tfor (SpringApplicationRunListener listener : this.listeners) {\n\t\tlistener.starting();\n\t}\n}\n```\n```java\npublic void starting() {\n\tthis.initialMulticaster.multicastEvent(\n\t\t\tnew ApplicationStartingEvent(this.application, this.args));\n}\n```\n　　这里会遍历上面拿到的排序好的所有`SpringApplicationRunListener`系列监听器，广播`ApplicationStartingEvent`事件，这代表Spring应用开始启动，在这之前只进行了注册化初始化器和监听器。\n### 准备环境、广播`ApplicationEnvironmentPreparedEvent`事件\n```java\n// 准备环境（创建、配置、绑定环境、广播ApplicationEnvironmentPreparedEvent）\nConfigurableEnvironment environment = prepareEnvironment(listeners,\n\t\tapplicationArguments);\n```\n```java\nprivate ConfigurableEnvironment prepareEnvironment(\n\t\tSpringApplicationRunListeners listeners,\n\t\tApplicationArguments applicationArguments) {\n\t// Create and configure the environment\n\tConfigurableEnvironment environment = getOrCreateEnvironment();\n\tconfigureEnvironment(environment, applicationArguments.getSourceArgs());\n\tlisteners.environmentPrepared(environment);\n\tbindToSpringApplication(environment);\n\tif (this.webApplicationType == WebApplicationType.NONE) {\n\t\tenvironment = new EnvironmentConverter(getClassLoader())\n\t\t\t\t.convertToStandardEnvironmentIfNecessary(environment);\n\t}\n\tConfigurationPropertySources.attach(environment);\n\treturn environment;\n}\n```\n```java\npublic void environmentPrepared(ConfigurableEnvironment environment) {\n\tfor (SpringApplicationRunListener listener : this.listeners) {\n\t\tlistener.environmentPrepared(environment);\n\t}\n}\n```\n\n```java\n@Override\npublic void environmentPrepared(ConfigurableEnvironment environment) {\n\tthis.initialMulticaster.multicastEvent(new ApplicationEnvironmentPreparedEvent(\n\t\t\tthis.application, this.args, environment));\n}\n```\n　　这里开始创建、配置和绑定`ConfigurableEnvironment`环境，环境准备好之后开始遍历`SpringApplicationRunListener`系列监听器，广播`ApplicationEnvironmentPreparedEvent`事件，代表环境已准备好。\n### 开始打印Banner\n```java\n// 打印Banner\nBanner printedBanner = printBanner(environment);\n```\n```java\nprivate Banner printBanner(ConfigurableEnvironment environment) {\n\t// Mode.OFF：不打印banner\n\tif (this.bannerMode == Banner.Mode.OFF) {\n\t\treturn null;\n\t}\n\t// 加载banner资源，如果自定义了banner样式，在这里加载，否则加载默认banner\n\tResourceLoader resourceLoader = (this.resourceLoader != null)\n\t\t\t? this.resourceLoader : new DefaultResourceLoader(getClassLoader());\n\t// 初始化bannerPrinter\n\tSpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(\n\t\t\tresourceLoader, this.banner);\n\t// Mode.LOG：通过日志打印banner\n\tif (this.bannerMode == Mode.LOG) {\n\t\treturn bannerPrinter.print(environment, this.mainApplicationClass, logger);\n\t}\n\t// 默认通过控制台打印banner\n\treturn bannerPrinter.print(environment, this.mainApplicationClass, System.out);\n}\n```\n　　关于Banner，SpringBoot支持关闭banner打印、打印到log日志和打印到system日志三种方式；同时支持自定义banner，自定义banner又有图片和txt文本两种（同时存在时先打印图片banner，在打印文本banner），图片banner又支持`gif`, `jpg`, `png`这三种类型的图片格式banner（`git`优先于`jpg`优先于`png`），自定义banner非常简单，只需要将banner文件放到`classpath:`下就好了（`resources`目录下），如果存在多个banner文件，想指定某一个文件，只需要在`application.properties`文件加入如下配置就好了，非常方便。\n```propertoties\nspring.banner.image.location=banner.png\nspring.banner.location=banner.txt\n```\n\n### 根据应用类型创建上下文\n```java\n// 根据应用类型创建上下文\ncontext = createApplicationContext();\n```\n```java\nprotected ConfigurableApplicationContext createApplicationContext() {\n\tClass<?> contextClass = this.applicationContextClass;\n\tif (contextClass == null) {\n\t\ttry {\n\t\t\tswitch (this.webApplicationType) {\n\t\t\tcase SERVLET:\n\t\t\t\tcontextClass = Class.forName(DEFAULT_WEB_CONTEXT_CLASS);\n\t\t\t\tbreak;\n\t\t\tcase REACTIVE:\n\t\t\t\tcontextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontextClass = Class.forName(DEFAULT_CONTEXT_CLASS);\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Unable create a default ApplicationContext, \"\n\t\t\t\t\t\t\t+ \"please specify an ApplicationContextClass\",\n\t\t\t\t\tex);\n\t\t}\n\t}\n\treturn (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);\n}\n```\n\n```java\npublic static final String DEFAULT_WEB_CONTEXT_CLASS = \"org.springframework.boot.\"\n\t\t+ \"web.servlet.context.AnnotationConfigServletWebServerApplicationContext\";\n\npublic static final String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = \"org.springframework.\"\n\t\t+ \"boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext\";\n\t\t\npublic static final String DEFAULT_CONTEXT_CLASS = \"org.springframework.context.\"\n\t\t+ \"annotation.AnnotationConfigApplicationContext\";\n```\n　　开始创建`ConfigurableApplicationContext`上下文，其中`Servlet`类型的web应用会创建`AnnotationConfigServletWebServerApplicationContext`类型的上下文，`Reactive`类型的web应用会创建`AnnotationConfigReactiveWebServerApplicationContext`类型的上下文，非web应用会创建`AnnotationConfigApplicationContext`类型的上下文。\n### 获取`SpringBootExceptionReporter`系列异常收集器\n```java\n// 获取SpringBootExceptionReporter系列异常收集器（从spring.factories文件加载，并实例化和排序）\nexceptionReporters = getSpringFactoriesInstances(\n\t\tSpringBootExceptionReporter.class,\n\t\tnew Class[] { ConfigurableApplicationContext.class }, context);\n```\n\n```java\nprivate <T> Collection<T> getSpringFactoriesInstances(Class<T> type,\n\t\tClass<?>[] parameterTypes, Object... args) {\n\tClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\t// Use names and ensure unique to protect against duplicates\n\tSet<String> names = new LinkedHashSet<>(\n\t\t\tSpringFactoriesLoader.loadFactoryNames(type, classLoader));\n\tList<T> instances = createSpringFactoriesInstances(type, parameterTypes,\n\t\t\tclassLoader, args, names);\n\tAnnotationAwareOrderComparator.sort(instances);\n\treturn instances;\n}\n```\n　　可以看到，加载异常收集器与上面初始化器和监听器如出一辙，不做过多阐述。\n### 上下文前置处理、广播`ApplicationPreparedEvent`事件\n```java\n// 上下文前置处理（执行ApplicationContextInitializer系列初始化器、加载资源、广播ApplicationPreparedEvent）\nprepareContext(context, environment, listeners, applicationArguments,\n\t\t\tprintedBanner);\n```\n```java\nprivate void prepareContext(ConfigurableApplicationContext context,\n\t\tConfigurableEnvironment environment, SpringApplicationRunListeners listeners,\n\t\tApplicationArguments applicationArguments, Banner printedBanner) {\n\t// 关联上下文和环境\n\tcontext.setEnvironment(environment);\n\t//\n\tpostProcessApplicationContext(context);\n\t// 去重并排序前面获取好的ApplicationContextInitializer初始化器，执行初始化\n\tapplyInitializers(context);\n\t// 遍历前面设置好的SpringApplicationRunListener，但并没有发布（目前什么都没做，貌似为了以后扩展）\n\tlisteners.contextPrepared(context);\n\tif (this.logStartupInfo) {\n\t\tlogStartupInfo(context.getParent() == null);\n\t\tlogStartupProfileInfo(context);\n\t}\n\n\t// Add boot specific singleton beans\n\t// 添加启动特定的单例bean\n\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n\tbeanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);\n\tif (printedBanner != null) {\n\t\tbeanFactory.registerSingleton(\"springBootBanner\", printedBanner);\n\t}\n\n\tif (beanFactory instanceof DefaultListableBeanFactory) {\n\t\t((DefaultListableBeanFactory) beanFactory)\n\t\t\t\t.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n\t}\n\t// Load the sources\n\t// 加载sources资源\n\tSet<Object> sources = getAllSources();\n\tAssert.notEmpty(sources, \"Sources must not be empty\");\n\n\tload(context, sources.toArray(new Object[0]));\n\t// 广播ApplicationPreparedEvent\n\tlisteners.contextLoaded(context);\n}\n```\n　　在启动上下文之前，会调用前面初始化好的`ApplicationContextInitializer`接口实现类，当然也包含我们自定义的，所以我们可以自定义初始化器，在上下文启动前做一些操作。之后会广播`ApplicationPreparedEvent`事件，通知`SpringApplicationRunListener`监听器`ConfigurableApplicationContext`上下文已准备好（框架中用`listeners.contextLoaded(context);`方法广播了`ApplicationPreparedEvent`事件，而`ApplicationLoadedEvent`事件并没有发布，感觉这里以后还会变动。。。）。\n### 刷新上下文\n```java\n// 刷新上下文（）\nrefreshContext(context);\n```\n```java\nprivate void refreshContext(ConfigurableApplicationContext context) {\n\trefresh(context);\n\tif (this.registerShutdownHook) {\n\t\ttry {\n\t\t\tcontext.registerShutdownHook();\n\t\t}\n\t\tcatch (AccessControlException ex) {\n\t\t\t// Not allowed in some environments.\n\t\t}\n\t}\n}\n```\n### 发布`ApplicationStartedEvent`事件\n```java\n// 遍历前面设置的ConfigurableApplicationContext监听器，发布ApplicationStartedEvent\nlisteners.started(context);\n```\n```java\npublic void started(ConfigurableApplicationContext context) {\n\tfor (SpringApplicationRunListener listener : this.listeners) {\n\t\tlistener.started(context);\n\t}\n}\n```\n```java\n@Override\npublic void started(ConfigurableApplicationContext context) {\n\tcontext.publishEvent(\n\t\t\tnew ApplicationStartedEvent(this.application, this.args, context));\n}\n```\n　　发布`ApplicationStartedEvent`事件，通知　`SpringApplicationRunListener`系列监听器`ConfigurableApplicationContext`上下文已启动完成，Spring Bean 已初始化完成。\n### 回调实现了`ApplicationRunner`或`CommandLineRunner`接口的`Runners`\n```java\n// 按顺序回调实现了ApplicationRunner或CommandLineRunner接口的Runners\ncallRunners(context, applicationArguments);\n```\n```java\nprivate void callRunners(ApplicationContext context, ApplicationArguments args) {\n\tList<Object> runners = new ArrayList<>();\n\trunners.addAll(context.getBeansOfType(ApplicationRunner.class).values());\n\trunners.addAll(context.getBeansOfType(CommandLineRunner.class).values());\n\tAnnotationAwareOrderComparator.sort(runners);\n\tfor (Object runner : new LinkedHashSet<>(runners)) {\n\t\tif (runner instanceof ApplicationRunner) {\n\t\t\tcallRunner((ApplicationRunner) runner, args);\n\t\t}\n\t\tif (runner instanceof CommandLineRunner) {\n\t\t\tcallRunner((CommandLineRunner) runner, args);\n\t\t}\n\t}\n}\n```\n　　这里是有顺序的，`ApplicationRunner`的实现类优先于`CommandLineRunner`的实现类被回调\n### 发布`ApplicationReadyEvent`事件\n```java\ntry {\n\t// 遍历前面设置好的SpringApplicationRunListener监听器，发布ApplicationReadyEvent\n\tlisteners.running(context);\n}\n```\n```java\npublic void running(ConfigurableApplicationContext context) {\n\tfor (SpringApplicationRunListener listener : this.listeners) {\n\t\tlistener.running(context);\n\t}\n}\n```\n\n```java\n@Override\npublic void running(ConfigurableApplicationContext context) {\n\tcontext.publishEvent(\n\t\t\tnew ApplicationReadyEvent(this.application, this.args, context));\n}\n```\n　　发布`ApplicationReadyEvent`事件,通知`SpringApplicationRunListener`系列监听器`ConfigurableApplicationContext`上下文已经在运行，整个容器已经准备好。\n\n### 发布`ExitCodeEvent`和`ApplicationFailedEvent`事件和异常收集器收集异常信息\n```java\ncatch (Throwable ex) {\n\thandleRunFailure(context, ex, exceptionReporters, listeners);\n\tthrow new IllegalStateException(ex);\n}\n```\n```java\nprivate void handleRunFailure(ConfigurableApplicationContext context,\n\t\tThrowable exception,\n\t\tCollection<SpringBootExceptionReporter> exceptionReporters,\n\t\tSpringApplicationRunListeners listeners) {\n\ttry {\n\t\ttry {\n\t\t\thandleExitCode(context, exception);\n\t\t\tif (listeners != null) {\n\t\t\t\tlisteners.failed(context, exception);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\treportFailure(exceptionReporters, exception);\n\t\t\tif (context != null) {\n\t\t\t\tcontext.close();\n\t\t\t}\n\t\t}\n\t}\n\tcatch (Exception ex) {\n\t\tlogger.warn(\"Unable to close ApplicationContext\", ex);\n\t}\n\tReflectionUtils.rethrowRuntimeException(exception);\n}\n```\n\n　　如果启动过程中出现异常，springboot将会发布`ExitCodeEvent`事件通知上下文停止或重启，并发布`ApplicationFailedEvent`事件通知`SpringApplicationRunListener`系列监听器，最后`SpringBootExceptionReporter`异常收集器收集打印异常。\n## 总结\n### SpringBoot启动过程大致脉络\n- 准备阶段\n  - 参数初始化\n  - 推断应用类型\n  - 加载ApplicationContextInitializer系列初始化器\n  - 加载ApplicationListener系列监听器\n  - 推断应用入口类（main函数所在类）\n\n- 运行阶段\n  - 初始化容器启动计时器，开始计时\n  - 初始化上下文ConfigurableApplicationContext、异常收集器\n  - 配置系统参数\"java.awt.headless\"\n  - 获取SpringApplicationRunListener系列监听器\n  - 遍历所有SpringApplicationRunListener系列监听器，广播ApplicationStartingEvent\n  - 处理args参数\n  - 准备环境（创建、配置、绑定环境、广播ApplicationEnvironmentPreparedEvent）\n  - 配置忽略Bean信息\n  - 打印Banner\n  - 根据应用类型创建上下文\n  - 获取SpringBootExceptionReporter系列异常收集器\n  - 上下文前置处理（执行ApplicationContextInitializer系列初始化器、加载资源、广播ApplicationPreparedEvent）\n  - 刷新上下文\n  - 启动完成，打印用时\n  - 遍历前面设置的ConfigurableApplicationContext监听器，发布ApplicationStartedEvent\n  - 回调实现了ApplicationRunner或CommandLineRunner接口的Runners\n  - 遍历前面设置好的SpringApplicationRunListener监听器，发布ApplicationReadyEvent\n\n　　至此，整个SpringBoot项目已经启动完成，我们可以看到，整个过程中Spring的事件驱动机制起着举足轻重的作用，有了这个机制我们可以知晓容器的启动过程，并且可以监听到某些事件，对容器中我们关心的实例做进一步处理，我们深入理解事件驱动机制很有必要，它将帮助我们更好的理解和使用这个Spring框架体系。如果想要文中中文版SpringBoot注释源码，可以在[我的github](https://github.com/ZhaoGitHub1/spring-boot)下载，如果发现哪里写的不对，烦请留言通知我。","tags":["springboot源码分析"],"categories":["源码分析"]}]