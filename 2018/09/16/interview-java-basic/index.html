<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="JF09eNDd2m" />
  
  
  
  
  <title>面试之---java基础相关 | 逸竹小站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="包含定义概念、源码细节、集合、多线程、jvm、jdk新特性等方面java基础相关面试题汇总">
<meta name="keywords" content="总结,java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="面试之---java基础相关">
<meta property="og:url" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/index.html">
<meta property="og:site_name" content="逸竹小站">
<meta property="og:description" content="包含定义概念、源码细节、集合、多线程、jvm、jdk新特性等方面java基础相关面试题汇总">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/interview.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/image2.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/image3.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/image9.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/hashmap.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/image1.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/threadPool.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/F:/code/git/ZhaoGitHub1.github.io/source/_posts/interview-java-basic/image7.png">
<meta property="og:updated_time" content="2019-10-29T14:22:01.807Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试之---java基础相关">
<meta name="twitter:description" content="包含定义概念、源码细节、集合、多线程、jvm、jdk新特性等方面java基础相关面试题汇总">
<meta name="twitter:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/interview.png">
  
    <link rel="alternative" href="/atom.xml" title="逸竹小站" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/logo.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">逸竹</a></h1>
        </hgroup>
        
        <p class="header-subtitle">未来不迎，当时不杂，过往不恋！</p>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/tags/">分类&amp;标签</a></li>
                        
                            <li><a  href="/douban/">我的豆瓣秀</a></li>
                        
                            <li><a  href="/categories/tree/">树</a></li>
                        
                            <li><a  href="/categories/interview/">面试</a></li>
                        
                            <li><a  href="/categories/lists/">清单</a></li>
                        
                            <li><a  href="/aboutme/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="https://github.com/ZhaoGitHub1/" title="github">github</a>
                            
                                <a class="fl douban"  target="_blank" href="https://www.douban.com/people/174692469/" title="douban">douban</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/ConcurrentHashMap/" style="font-size: 10px;">ConcurrentHashMap</a> <a href="/tags/SpringData/" style="font-size: 10px;">SpringData</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hashmap/" style="font-size: 10px;">hashmap</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java基础/" style="font-size: 10px;">java基础</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/linux命令/" style="font-size: 10px;">linux命令</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/orm/" style="font-size: 10px;">orm</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springboot/" style="font-size: 13.33px;">springboot</a> <a href="/tags/springboot源码分析/" style="font-size: 10px;">springboot源码分析</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/中间件/" style="font-size: 10px;">中间件</a> <a href="/tags/优化/" style="font-size: 10px;">优化</a> <a href="/tags/分布式锁/" style="font-size: 10px;">分布式锁</a> <a href="/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/tags/命令/" style="font-size: 10px;">命令</a> <a href="/tags/在线工具/" style="font-size: 10px;">在线工具</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/工具/" style="font-size: 16.67px;">工具</a> <a href="/tags/总结/" style="font-size: 20px;">总结</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/框架/" style="font-size: 13.33px;">框架</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/素描/" style="font-size: 10px;">素描</a> <a href="/tags/编码艺术/" style="font-size: 10px;">编码艺术</a> <a href="/tags/网站地址/" style="font-size: 10px;">网站地址</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/读书/" style="font-size: 13.33px;">读书</a> <a href="/tags/转载/" style="font-size: 13.33px;">转载</a> <a href="/tags/运维/" style="font-size: 10px;">运维</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a> <a href="/tags/项目经验/" style="font-size: 10px;">项目经验</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://blog.csdn.net/qq_25885525">我的csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://github.com/ZhaoGitHub1">我的github</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://gitee.com/zhao-183479916">我的gitee</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://spring.io/">Spring官网</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.mybatis.org/mybatis-3/zh/index.html">Mybatis官网</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://hibernate.org/">Hibernate官网</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">一名普通的java 后台开发工程师~~  邮箱：183479916@qq.com</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">逸竹</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/logo.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">逸竹</a></h1>
            </hgroup>
            
            <p class="header-subtitle">未来不迎，当时不杂，过往不恋！</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">分类&amp;标签</a></li>
                
                    <li><a href="/douban/">我的豆瓣秀</a></li>
                
                    <li><a href="/categories/tree/">树</a></li>
                
                    <li><a href="/categories/interview/">面试</a></li>
                
                    <li><a href="/categories/lists/">清单</a></li>
                
                    <li><a href="/aboutme/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/ZhaoGitHub1/" title="github">github</a>
                    
                        <a class="douban" target="_blank" href="https://www.douban.com/people/174692469/" title="douban">douban</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-interview-java-basic" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/09/16/interview-java-basic/" class="article-date">
      <time datetime="2018-09-16T13:06:51.000Z" itemprop="datePublished">2018-09-16</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面试之---java基础相关
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/interview/">interview</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong> 面试之---java基础相关：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p>
<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">

<p><img src="/2018/09/16/interview-java-basic/interview.png" alt=""></p>
<blockquote>
<p>持续维护java面试题系列博文，发现好的面试题会更新进来。总结的并不只是如何回答面试官，而是这道题涉及到的知识点，明白了相关知识点和面试官要问的点，回答起来就不是问题了。</p>
</blockquote>
<h3 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h3><h4 id="面向对象的特征：抽象、继承、封装、多态"><a href="#面向对象的特征：抽象、继承、封装、多态" class="headerlink" title="面向对象的特征：抽象、继承、封装、多态"></a>面向对象的特征：<code>抽象</code>、<code>继承</code>、<code>封装</code>、<code>多态</code></h4><ol>
<li><code>抽象</code>：抽象就是忽略一个主题中与当前目标无关的那些方面，以便充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一个过程抽象，而是数据抽象。</li>
<li><code>继承</code>：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更合适特殊的需要。</li>
<li><code>封装</code>：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向、对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</li>
<li><code>多态性</code>：多态性事指允许不同类的对象对同一个消息作出响应。多态性包括参数多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</li>
</ol>
<h4 id="什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？"><a href="#什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？" class="headerlink" title="什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？"></a>什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？</h4><ol>
<li>具有关键字abstract，实现内容上没有完全定义的类就叫抽象类。</li>
<li>抽象类和接口的区别如下：<ol>
<li>在类来继承抽象类时，只需要实现部分方法和全部抽象方法，而实现接口则要实现里面的全部方法。</li>
<li>在接口中无成员变量，而抽象类可有成员变量。</li>
<li>在java中引进接口主要是为了解决多继承的问题。</li>
</ol>
</li>
</ol>
<h4 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（<code>Overload</code>）和重写（<code>Override</code>）的区别。重载的方法能否根据返回类型进行区分？</h4><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p>
<h4 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h4><p>规范、扩展、回调</p>
<h4 id="创建对象的几种方式"><a href="#创建对象的几种方式" class="headerlink" title="创建对象的几种方式"></a>创建对象的几种方式</h4><p>new、反射、clone、序列化</p>
<h3 id="jdk源码相关（不包含多线程和集合）"><a href="#jdk源码相关（不包含多线程和集合）" class="headerlink" title="jdk源码相关（不包含多线程和集合）"></a>jdk源码相关（不包含多线程和集合）</h3><h4 id="int-Integer的区别："><a href="#int-Integer的区别：" class="headerlink" title="int Integer的区别："></a><code>int</code> <code>Integer</code>的区别：</h4><ol>
<li>java提供两种不同的类型：引用类型和原始类型（或内置类型）。<code>int</code>是java的原始类型数据，<code>Integer</code>是java为<code>int</code>提供的封装类。Java为每个原始类提供了封装类。</li>
<li>原始类型封装： <code>boolean</code> <code>Boolean</code>、<code>char</code> <code>Character</code>、<code>byte</code> <code>Byte</code>、<code>short</code> <code>Short</code>、<code>int</code> <code>Integer</code>、<code>long</code> <code>Long</code>、<code>float</code> <code>Float</code>、<code>double</code> <code>Double</code></li>
<li>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为<code>null</code>，而原始类型实例变量的缺省值与它们的类型有关。</li>
</ol>
<h4 id="i与i-仅是“先加”与“后加”的差别吗？"><a href="#i与i-仅是“先加”与“后加”的差别吗？" class="headerlink" title="++i与i++仅是“先加”与“后加”的差别吗？"></a>++i与i++仅是“先加”与“后加”的差别吗？</h4><p>前置 ++ 是将变量的值加1后，使用增值后的变量进行运算的，而后置++ 是首先将变量赋值给一个临时变量，接下来对变量的值加1，然后使用那个临时变量进行运算。</p>
<h4 id="两个对象值相同-x-equals-y-true-，但却可有不同的hashCode，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hashCode，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hashCode，这句话对不对？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的<code>hashCode</code>，这句话对不对？</h4><ol>
<li>如果两个对象x和y满足x.equals(y) == true，它们的哈希码（<code>hash code</code>）应当相同。Java对于<code>eqauls</code>方法和<code>hashCode</code>方法是这样规定的：</li>
<li>如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；</li>
<li>如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，    同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</li>
</ol>
<blockquote>
<p>补充：在Joshua Bloch的大作《Effective Java》中是这样介绍<code>equals</code>方法的：首先<code>equals</code>方法必须满足<code>自反性</code>（x.equals(x)必须返回<code>true</code>）、<code>对称性</code>（x.equals(y)返回<code>true</code>时，y.equals(x)也必须返回<code>true</code>）、<code>传递性</code>（x.equals(y)和y.equals(z)都返回<code>true</code>时，x.equals(z)也必须返回<code>true</code>）和<code>一致性</code>（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非<code>null</code>值的引用x，x.equals(null)必须返回<code>false</code>。实现高质量的<code>equals</code>方法的诀窍包括： 使用<code>==</code>操作符检查”参数是否为这个对象的引用”；2. 使用<code>instanceof</code>操作符检查”参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完<code>equals</code>方法后，问自己它是否满足<code>对称性</code>、<code>传递性</code>、<code>一致性</code>；5. 重写<code>equals</code>时总是要重写<code>hashCode</code>；6. 不要将<code>equals</code>方法参数中的<code>Object</code>对象替换为其他的类型，在重写时不要忘掉<code>@Override</code>注解。</p>
</blockquote>
<h4 id="基本for循环与加强型for循环的差别"><a href="#基本for循环与加强型for循环的差别" class="headerlink" title="基本for循环与加强型for循环的差别"></a>基本for循环与加强型for循环的差别</h4><ol>
<li>在访问数组与Iterable类型变量时，使用加强型for循环比基本for循环要方便快捷。但是，加强型for循环也有一定的局限性，也就意味着加强型for循环不可能完全取代基本for循环。</li>
<li>加强型for循环右侧变量必须为数组类型或者Iterable类型。</li>
<li>加强型for循环在底层也是由基本for循环来实现的。</li>
</ol>
<h4 id="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>Java语言如何进行异常处理，关键字：<code>throws</code>、<code>throw</code>、<code>try</code>、<code>catch</code>、<code>finally</code>分别如何使用？</h4><ol>
<li>Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是<code>Throwable</code>类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：<code>try</code>、<code>catch</code>、<code>throw</code>、<code>throws</code>和<code>finally</code>。</li>
<li>一般情况下是用<code>try</code>来执行一段程序，如果系统会抛出（<code>throw</code>）一个异常对象，可以通过它的类型来捕获（<code>catch</code>）它，或通过总是执行代码块（<code>finally</code>）来处理；<ol>
<li><code>try</code>用来指定一块预防所有异常的程序；<code>catch</code>子句紧跟在<code>try</code>块后面，用来指定你想要捕获的异常的类型；</li>
<li><code>throw</code>语句用来明确地抛出一个异常；</li>
<li><code>throws</code>用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；</li>
<li><code>finally</code>为确保一段代码不管发生什么异常状况都要被执行；</li>
<li><code>try</code>语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的<code>try</code>语句或者最终将异常抛给<code>JVM</code>。</li>
</ol>
</li>
</ol>
<h4 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h4><ol>
<li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。</li>
<li>要实现序列化，需要让一个类实现<code>Serializable</code>接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过<code>writeObject(Object)</code>方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过<code>readObject</code>方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。</li>
</ol>
<h4 id="获得一个类的类对象有哪些方式？"><a href="#获得一个类的类对象有哪些方式？" class="headerlink" title="获得一个类的类对象有哪些方式？"></a>获得一个类的类对象有哪些方式？</h4><ol>
<li>类型<code>.class</code>，例如：String.class</li>
<li>对象<code>.getClass()</code>，例如：”hello”.getClass()</li>
<li><code>Class.forName()</code>，例如：Class.forName(“java.lang.String”)</li>
</ol>
<h4 id="如何通过反射创建对象？"><a href="#如何通过反射创建对象？" class="headerlink" title="如何通过反射创建对象？"></a>如何通过反射创建对象？</h4><ol>
<li>通过类对象调用<code>newInstance()</code>方法，例如：String.class.newInstance()</li>
<li>通过类对象的<code>getConstructor()</code>或<code>getDeclaredConstructor()</code>方法获得构造器（<code>Constructor</code>）对象并调用其<code>newInstance()</code>方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);</li>
</ol>
<h4 id="如何通过反射调用对象的方法？"><a href="#如何通过反射调用对象的方法？" class="headerlink" title="如何通过反射调用对象的方法？"></a>如何通过反射调用对象的方法？</h4><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInvokeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">        Method m = str.getClass().getMethod(<span class="string">"toUpperCase"</span>);</span><br><span class="line">        System.out.println(m.invoke(str));  <span class="comment">// HELLO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="Java中如何实现序列化，有什么意义？-1"><a href="#Java中如何实现序列化，有什么意义？-1" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h4><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。  要实现序列化，需要让一个类实现<code>Serializable</code>接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过<code>writeObject(Object)</code>方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过<code>readObject</code>方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。</p>
<h4 id="两个Integer的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？"><a href="#两个Integer的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？" class="headerlink" title="两个Integer的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？"></a>两个<code>Integer</code>的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？</h4><p>第一种<strong>错误方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"before:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"after:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer i1, Integer i2)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Integer tmp = i1;</span><br><span class="line">        i2 = i1;</span><br><span class="line">        i1 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>before:a=1,b=2<br>after:a=1,b=2</p>
</blockquote>
<p>第二种<strong>错误方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"before:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"after:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer i1, Integer i2)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Field field = Integer.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Integer tmp = i1;</span><br><span class="line">        field.set(i1,i2);</span><br><span class="line">        field.set(i2,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>before:a=1,b=2<br>after:a=2,b=2</p>
</blockquote>
<p>正确的一种做法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"before:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"after:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer i1, Integer i2)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Field field = Integer.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Integer tmp = <span class="keyword">new</span> Integer(i1);</span><br><span class="line">        field.set(i1,i2);</span><br><span class="line">        field.set(i2,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>before:a=1,b=2<br>after:a=2,b=1</p>
</blockquote>
<p>涉及到的知识点：</p>
<ul>
<li>自动装箱和拆箱</li>
<li>Integer -128到127之间的缓存</li>
<li>如何通过反射区修改private final变量的值</li>
</ul>
<h4 id="String类为什么是final的？"><a href="#String类为什么是final的？" class="headerlink" title="String类为什么是final的？"></a>String类为什么是final的？</h4><ol>
<li>线程安全</li>
<li>支持字符串常量池数据共享，节省资源，提高效率（因为如果已经存在这个常量便不会再创建，直接拿来用）</li>
</ol>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h4 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h4><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>按操作方式分类结构图：<img src="/2018/09/16/interview-java-basic/image2.png" alt=""></p>
<p>按操作对象分类结构图：<img src="/2018/09/16/interview-java-basic/image3.png" alt=""></p>
<h4 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h4><ul>
<li><strong>BIO (Blocking I/O):</strong> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li><strong>NIO (New I/O):</strong> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
<li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><img src="/2018/09/16/interview-java-basic/image9.png" alt=""></p>
<h4 id="List、Set、Map是否继承自Collection接口？"><a href="#List、Set、Map是否继承自Collection接口？" class="headerlink" title="List、Set、Map是否继承自Collection接口？"></a>List、Set、Map是否继承自Collection接口？</h4><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h4 id="HashMap在JDK1-7和JDK1-8中有哪些不同？"><a href="#HashMap在JDK1-7和JDK1-8中有哪些不同？" class="headerlink" title="HashMap在JDK1.7和JDK1.8中有哪些不同？"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？</h4><table>
<thead>
<tr>
<th>不同</th>
<th>JDK 1.7</th>
<th>JDK 1.8</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>初始化方式</td>
<td>单独函数：<code>inflateTable()</code></td>
<td>直接集成到了扩容函数<code>resize()</code>中</td>
</tr>
<tr>
<td>hash值计算方式</td>
<td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td>
<td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td>
</tr>
<tr>
<td>存放数据的规则</td>
<td>无冲突时，存放数组；冲突时，存放链表</td>
<td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>
</tr>
<tr>
<td>插入数据方式</td>
<td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td>
<td>尾插法（直接插入到链表尾部/红黑树）</td>
</tr>
<tr>
<td>扩容后存储位置的计算方式</td>
<td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>
<td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>
</tr>
</tbody>
</table>
<h4 id="说一说HashMap中put方法"><a href="#说一说HashMap中put方法" class="headerlink" title="说一说HashMap中put方法"></a>说一说HashMap中put方法</h4><p>jdk8中put逻辑如下</p>
<p><img src="/2018/09/16/interview-java-basic/hashmap.png" alt=""></p>
<h4 id="HashMap是使用了哪些方法来有效解决哈希冲突的"><a href="#HashMap是使用了哪些方法来有效解决哈希冲突的" class="headerlink" title="HashMap是使用了哪些方法来有效解决哈希冲突的:"></a>HashMap是使用了哪些方法来有效解决哈希冲突的:</h4><ol>
<li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li>
<li>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</li>
<li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</li>
</ol>
<h4 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h4><p>hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>
<h5 id="面试官：那怎么解决呢？"><a href="#面试官：那怎么解决呢？" class="headerlink" title="面试官：那怎么解决呢？"></a>面试官：那怎么解决呢？</h5><p>HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</p>
<p>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</p>
<h5 id="面试官：为什么数组长度要保证为2的幂次方呢？"><a href="#面试官：为什么数组长度要保证为2的幂次方呢？" class="headerlink" title="面试官：为什么数组长度要保证为2的幂次方呢？"></a>面试官：为什么数组长度要保证为2的幂次方呢？</h5><p>只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，即实现了key的定位，2的幂次方也可以减少冲突次数，提高HashMap的查询效率；</p>
<p>如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。</p>
<h5 id="面试官：那为什么是两次扰动呢？"><a href="#面试官：那为什么是两次扰动呢？" class="headerlink" title="面试官：那为什么是两次扰动呢？"></a>面试官：那为什么是两次扰动呢？</h5><p>这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p>
<h4 id="为什么HashMap中String、Integer这样的包装类适合作为K？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为K？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为K？"></a>为什么HashMap中String、Integer这样的包装类适合作为K？</h4><p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<ol>
<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li>
<li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li>
</ol>
<h5 id="面试官：如果我想要让自己的Object作为K应该怎么办呢？"><a href="#面试官：如果我想要让自己的Object作为K应该怎么办呢？" class="headerlink" title="面试官：如果我想要让自己的Object作为K应该怎么办呢？"></a>面试官：如果我想要让自己的Object作为K应该怎么办呢？</h5><p>重写<code>hashCode()</code>和<code>equals()</code>方法 </p>
<ol>
<li><strong>重写hashCode()</strong>是因为需要计算存储数据的存储位置**，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li>
<li><strong>重写equals()方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li>
</ol>
<h4 id="ArrayList和LinkedList的区别？"><a href="#ArrayList和LinkedList的区别？" class="headerlink" title="ArrayList和LinkedList的区别？"></a>ArrayList和LinkedList的区别？</h4><ol>
<li>LinkedList 实现了 List 和 Deque 接口，一般称为双向链表；ArrayList 实现了 List 接口，动态数组；</li>
<li>LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高；</li>
<li>LinkedList 比 ArrayList 需要更多的内存；</li>
</ol>
<h4 id="Array-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？"><a href="#Array-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？" class="headerlink" title="Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？"></a>Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</h4><p>它们的区别是：</p>
<ol>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li>
</ol>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？"><a href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？" class="headerlink" title="Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？"></a><code>Thread</code>类的<code>sleep()</code>方法和对象的<code>wait()</code>方法都可以让线程暂停执行，它们有什么区别？</h4><p><code>sleep()</code>方法（休眠）是线程类（<code>Thread</code>）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。<code>wait()</code>是<code>Object</code>类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的<code>notify()</code>方法（或<code>notifyAll()</code>方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p>
<blockquote>
<p>补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。</p>
</blockquote>
<h4 id="synchronized关键字的用法？"><a href="#synchronized关键字的用法？" class="headerlink" title="synchronized关键字的用法？"></a>synchronized关键字的用法？</h4><p><code>synchronized</code>关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将<code>synchronized</code>作为方法的修饰符。</p>
<h4 id="线程的基本状态以及状态之间的关系？"><a href="#线程的基本状态以及状态之间的关系？" class="headerlink" title="线程的基本状态以及状态之间的关系？"></a>线程的基本状态以及状态之间的关系？</h4><p><img src="/2018/09/16/interview-java-basic/image1.png" alt=""></p>
<blockquote>
<p><strong>说明：</strong>其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。</p>
</blockquote>
<h4 id="简述synchronized-和java-util-concurrent-locks-Lock的异同？"><a href="#简述synchronized-和java-util-concurrent-locks-Lock的异同？" class="headerlink" title="简述synchronized 和java.util.concurrent.locks.Lock的异同？"></a>简述synchronized 和java.util.concurrent.locks.Lock的异同？</h4><p><code>Lock</code>是Java 5以后引入的新的API，和关键字<code>synchronized</code>相比主要相同点：<code>Lock</code> 能完成<code>synchronized</code>所实现的所有功能；主要不同点：<code>Lock</code>有比<code>synchronized</code>更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。<code>synchronized</code>会自动释放锁，而<code>Lock</code>一定要求程序员手工释放，并且最好在<code>finally</code> 块中释放（这是释放外部资源的最好的地方）。</p>
<h4 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h4><ol>
<li>使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li>
<li>使用 Java. util. concurrent 并发类代替自己手写锁。</li>
<li>降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>
<li>减少同步的代码块。</li>
</ol>
<h4 id="如何控制线程的执行顺序？"><a href="#如何控制线程的执行顺序？" class="headerlink" title="如何控制线程的执行顺序？"></a>如何控制线程的执行顺序？</h4><ol>
<li><p>使用join方法，join方法是让主线程等待子线程结束后才能继续运行</p>
</li>
<li><p>使用<code>ExecutorService executor = Executors.newSingleThreadExecutor();</code>方法</p>
<ul>
<li><code>newSingleThreadExecutor()</code>方法会创建一个只有一个线程的线程池FIFO的方式来操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">executorService.submit(thread1);</span><br><span class="line">executorService.submit(thread1);</span><br><span class="line">executorService.submit(thread1);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="java中的Volatile和synchronized的差异？"><a href="#java中的Volatile和synchronized的差异？" class="headerlink" title="java中的Volatile和synchronized的差异？"></a>java中的Volatile和synchronized的差异？</h4><table>
<thead>
<tr>
<th>差异项</th>
<th>volatile</th>
<th>synchronized</th>
</tr>
</thead>
<tbody>
<tr>
<td>修饰对象</td>
<td>volatile 是变量修饰符</td>
<td>synchronized 是修饰类、方法、代码段</td>
</tr>
<tr>
<td>可见性、原子性</td>
<td>volatile 仅能实现变量的修改可见性，不能保证原子性</td>
<td>synchronized 则可以保证变量的修改可见性和原子性</td>
</tr>
<tr>
<td>线程阻塞</td>
<td>volatile 不会造成线程的阻塞</td>
<td>synchronized 可能会造成线程的阻塞</td>
</tr>
<tr>
<td>编译器优化</td>
<td>volatile 标记的变量不会被编译器优化</td>
<td>synchronized 标记的变量可以被编译器优化</td>
</tr>
</tbody>
</table>
<blockquote>
<ol>
<li>线程之间通信的两种方式：<ol>
<li>共享内存-隐式通信</li>
<li>消息传递-显式通信</li>
</ol>
</li>
<li>线程之间如何保证消息同步：<ol>
<li>在共享内存的并发模型中，同步是显示做的：synchronized</li>
<li>在消息传递的并发模型中，由于消息的发送必须在消息接收之前，所以同步是隐式的</li>
</ol>
</li>
<li>多线程的共享变量是如何同步的<ol>
<li>线程A修改本地内存的变量值——&gt;同步到主内存的共享变量——&gt;线程B从主内存取得共享变量的值，刷新本地内存中的变量值</li>
</ol>
</li>
<li>Volatile关键字保证可见性<ol>
<li>对声明了Volatile的变量进行写操作的时候，JVM会向处理器发送一条Lock前缀的指令，会把这个变量所在缓存行的数据写回到主内存</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="什么是Callable和Future"><a href="#什么是Callable和Future" class="headerlink" title="什么是Callable和Future?"></a>什么是Callable和Future?</h4><p>Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。 </p>
<p>可以认为是带有回调的Runnable。</p>
<p>Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p>
<h4 id="为什么使用Executor框架比使用应用创建和管理线程好？"><a href="#为什么使用Executor框架比使用应用创建和管理线程好？" class="headerlink" title="为什么使用Executor框架比使用应用创建和管理线程好？"></a>为什么使用Executor框架比使用应用创建和管理线程好？</h4><p><strong>为什么要使用Executor线程池框架</strong></p>
<p>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。 </p>
<p>调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。 </p>
<p>直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</p>
<p><strong>使用Executor线程池框架的优点</strong></p>
<p>能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开销。 </p>
<p>可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。 </p>
<p>框架中已经有定时、定期、单线程、并发数控制等功能。 </p>
<p>综上所述使用线程池框架Executor能更好的管理线程、提供系统资源使用率。</p>
<h4 id="创建线程池有哪几种方式？"><a href="#创建线程池有哪几种方式？" class="headerlink" title="创建线程池有哪几种方式？"></a>创建线程池有哪几种方式？</h4><p>线程池创建有七种方式，最核心的是最后一种：</p>
<ol>
<li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li>
<li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li>
<li>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li>
<li>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li>
<li>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li>
<li>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li>
</ol>
<p>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</p>
<h4 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h4><p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p>
<p><strong>乐观锁</strong>：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<p><strong>乐观锁的实现方式</strong>： </p>
<p>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。 </p>
<p>java中的Compare and Swap即CAS ，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。　CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。</p>
<p><strong>CAS缺点</strong>：</p>
<p><strong>ABA问题</strong>：<br>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。 </p>
<p><strong>循环时间长开销大</strong>：<br>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 </p>
<p><strong>只能保证一个共享变量的原子操作</strong>：<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p>
<h4 id="Java线程池中submit-和-execute-方法有什么区别？"><a href="#Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="Java线程池中submit() 和 execute()方法有什么区别？"></a>Java线程池中submit() 和 execute()方法有什么区别？</h4><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中。</p>
<p>而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p>
<h4 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h4><p><img src="/2018/09/16/interview-java-basic/threadPool.png" alt=""></p>
<p>执行流程</p>
<ul>
<li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</li>
<li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li>
<li>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</li>
<li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li>
</ul>
<p>JDK提供了四种拒绝策略处理类</p>
<ul>
<li>AbortPolicy(抛出一个异常，默认的)</li>
<li>DiscardPolicy(直接丢弃任务)</li>
<li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li>
<li>CallerRunsPolicy（交给线程池调用所在的线程进行处理）</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h4><p><code>方法区</code>和<code>堆</code>为线程共享资源，<code>虚拟机栈</code>、<code>本地方法栈</code>和<code>程序计数器</code>线程私有</p>
<ol>
<li><p><code>本地方法栈</code>：它的具体做法是<code>Native Method Stack</code>中登记<code>native</code>方法，在<code>Execution Engine</code>执行时加载native libraies。</p>
</li>
<li><p><code>程序计数器</code>：每个线程都有一个程序计算器，就是一个指针，指向方法区中的方法字节码（下一个将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p>
</li>
<li><p><code>方法区</code>：方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域。<code>静态变量</code>+<code>常量</code>+<code>类信息</code>+<code>运行时常量池</code>存在<code>方法区</code>中，<code>实例变量</code>存在<code>堆内存</code>中。</p>
</li>
<li><p><code>栈</code>：<code>栈</code>也叫<code>栈内存</code>，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。基本类型的变量和对象的引用变量都是在函数的栈内存中分配。</p>
<blockquote>
<p>栈帧中主要保存3类数据：本地变量（Local Variables）：输入参数和输出参数以及方法内的变量；栈操作（Operand Stack）：记录出栈、入栈的操作；栈帧数据（Frame Data）：包括类文件、方法等等。</p>
</blockquote>
</li>
<li><p><code>堆</code>：<code>堆</code>这块区域是JVM中最大的，应用的对象和数据都是存在这个区域，这块区域也是线程共享的，也是 <code>gc</code> 主要的回收区，一个 JVM 实例只存在一个堆类存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分为三部分：新生区、养老区、永久区：</p>
<ol>
<li><p><code>新生区</code>：新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（<code>Eden space</code>）和幸存者区（<code>Survivor pace</code>），所有的类都是在伊甸区被new出来的。幸存区有两个：0区（<code>Survivor 0 space</code>）和1区（<code>Survivor 1 space</code>）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园进行垃圾回收（<code>Minor GC</code>）,将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1去也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生<code>Major GC</code>（<code>FullGCC</code>），进行养老区的内存清理。若养老区执行<code>Full GC</code> 之后发现依然无法进行对象的保存，就会产生OOM异常<code>OutOfMemoryError</code>。</p>
<p>如果出现<code>java.lang.OutOfMemoryError: Java heap space</code>异常，说明Java虚拟机的堆内存不够。原因有二：</p>
<ol>
<li>Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。</li>
</ol>
</li>
<li><p><code>养老区</code>：养老区用于保存从新生区筛选出来的 JAVA 对象，一般池对象都在这个区域活跃。</p>
</li>
<li><p><code>永久区</code>：永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。</p>
</li>
</ol>
<blockquote>
<p>如果出现<code>java.lang.OutOfMemoryError: PermGen space</code>，说明是Java虚拟机对永久代<code>Perm</code>内存设置不够。原因有二：</p>
<ul>
<li>程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。</li>
<li>大量动态反射生成的类不断被加载，最终导致<code>Perm</code>区被占满。</li>
</ul>
</blockquote>
<blockquote>
<p>说明：</p>
<p>Jdk1.6及之前：常量池分配在永久代 。</p>
<p>Jdk1.7：有，但已经逐步“去永久代” 。</p>
<p>Jdk1.8及之后：无(<code>java.lang.OutOfMemoryError: PermGen space</code>,这种错误将不会出现在JDK1.8中)。</p>
</blockquote>
</li>
</ol>
<h4 id="如何识别垃圾，判定对象是否可被回收？"><a href="#如何识别垃圾，判定对象是否可被回收？" class="headerlink" title="如何识别垃圾，判定对象是否可被回收？"></a>如何识别垃圾，判定对象是否可被回收？</h4><ul>
<li>引用计数法：给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。缺点：无法解决循环引用的问题</li>
<li>根搜索算法：也称可达性分析法，通过“GC ROOTs”的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收（可作为GC ROOTs的对象：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）</li>
</ul>
<h4 id="Java-中的堆是-GC-收集垃圾的主要区域"><a href="#Java-中的堆是-GC-收集垃圾的主要区域" class="headerlink" title="Java 中的堆是 GC 收集垃圾的主要区域"></a>Java 中的堆是 GC 收集垃圾的主要区域</h4><p>GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )</p>
<ul>
<li>Minor GC：新生代（Young Gen）空间不足时触发收集，由于Java 中的大部分对象通常不需长久存活，新生代是GC收集频繁区域，所以采用复制算法。</li>
<li>Full GC：老年代（Old Gen ）空间不足或元空间达到高水位线执行收集动作，由于存放大对象及长久存活下的对象，占用内存空间大，回收效率低，所以采用标记-清除算法。</li>
</ul>
<h4 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h4><h5 id="按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。"><a href="#按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。" class="headerlink" title="按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。"></a><strong>按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。</strong></h5><ol>
<li><p>标记-清除算法：分为两阶段“标记”和“清除”。首先标记出哪些对象可被回收，在标记完成之后统一回收所有被标记的对象所占用的内存空间。不足之处：1.无法处理循环引用的问题2.效率不高3.产生大量内存碎片（ps：空间碎片太多可能会导致以后在分配大对象的时候而无法申请到足够的连续内存空间，导致提前触发新一轮gc）</p>
</li>
<li><p>标记-整理算法：分为两阶段“标记”和“整理”。首先标记出哪些对象可被回收，在标记完成后，将对象向一端移动，然后直接清理掉边界以外的内存。</p>
</li>
<li><p>复制算法：把内存空间划为两个相等的区域，每次只使用其中一个区域。gc时遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。不足之处：1.内存利用率问题2.在对象存活率较高时，其效率会变低。</p>
</li>
</ol>
<h5 id="按分区对待可分为：增量收集算法，分代收集算法"><a href="#按分区对待可分为：增量收集算法，分代收集算法" class="headerlink" title="按分区对待可分为：增量收集算法，分代收集算法"></a><strong>按分区对待可分为：增量收集算法，分代收集算法</strong></h5><ol>
<li><p>增量收集:实时垃圾回收算法，即：在应用进行的同时进行垃圾回收，理论上可以解决传统分代方式带来的问题。增量收集把对堆空间划分成一系列内存块，使用时先使用其中一部分，垃圾收集时把之前用掉的部分中的存活对象再放到后面没有用的空间中，这样可以实现一直边使用边收集的效果，避免了传统分代方式整个使用完了再暂停的回收的情况。</p>
</li>
<li><p>分代收集:（商用默认）基于对象生命周期划分为新生代、老年代、元空间，对不同生命周期的对象使用不同的算法进行回收。</p>
</li>
</ol>
<h5 id="系统线程可分为：串行收集算法，并行收集算法，并发收集算法"><a href="#系统线程可分为：串行收集算法，并行收集算法，并发收集算法" class="headerlink" title="系统线程可分为：串行收集算法，并行收集算法，并发收集算法"></a>系统线程可分为：串行收集算法，并行收集算法，并发收集算法</h5><ol>
<li><p>串行收集:使用单线程处理垃圾回收工作，实现容易，效率较高。不足之处：1.无法发挥多处理器的优势 2.需要暂停用户线程</p>
</li>
<li><p>并行收集:使用多线程处理垃圾回收工作，速度快，效率高。理论上CPU数目越多，越能体现出并行收集器的优势。不足之处：需要暂停用户线程</p>
</li>
<li><p>并发收集:垃圾线程与用户线程同时工作。系统在垃圾回收时不需要暂停用户线程</p>
</li>
</ol>
<h4 id="JVM-垃圾收集器有哪些？"><a href="#JVM-垃圾收集器有哪些？" class="headerlink" title="JVM 垃圾收集器有哪些？"></a>JVM 垃圾收集器有哪些？</h4><ul>
<li>新生代收集器<ul>
<li>Serial 收集器</li>
<li>ParNew 收集器：Serial 收集器的多线程版</li>
<li>Parallel Scavenge 收集器</li>
</ul>
</li>
<li>老年代收集器<ul>
<li>Serial Old 收集器：Serial 收集器的老年代版本</li>
<li>Parallel Old 收集器：Parallel Scavenge 收集器的老年代版本</li>
<li>CMS 收集器</li>
</ul>
</li>
<li>新生代 + 老年代收集器<ul>
<li>G1 收集器</li>
<li>ZGC 收集器</li>
</ul>
</li>
</ul>
<p>小结表格如下：</p>
<table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行or并发</th>
<th>新生代/老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Serial</strong></td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td><strong>Serial Old</strong></td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>Parallel Old</strong></td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>并发</td>
<td>both</td>
<td>标记-整理+复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用，将来替换CMS</td>
</tr>
</tbody>
</table>
<h3 id="Java与数据库"><a href="#Java与数据库" class="headerlink" title="Java与数据库"></a>Java与数据库</h3><h4 id="阐述JDBC操作数据库的步骤"><a href="#阐述JDBC操作数据库的步骤" class="headerlink" title="阐述JDBC操作数据库的步骤"></a>阐述JDBC操作数据库的步骤</h4><p>加载驱动 -&gt; 创建连接 -&gt; 创建语句 -&gt; 执行语句 -&gt; 处理结果 -&gt; 关闭资源</p>
<h4 id="在进行数据库编程时，连接池有什么作用？"><a href="#在进行数据库编程时，连接池有什么作用？" class="headerlink" title="在进行数据库编程时，连接池有什么作用？"></a>在进行数据库编程时，连接池有什么作用？</h4><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：<code>C3P0</code>、<code>Proxool</code>、<code>DBCP</code>、<code>BoneCP</code>、<code>Druid</code>、<code>HikariCP</code>等。</p>
<blockquote>
<p>补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。</p>
</blockquote>
<h4 id="JDBC中如何进行事务处理？"><a href="#JDBC中如何进行事务处理？" class="headerlink" title="JDBC中如何进行事务处理？"></a>JDBC中如何进行事务处理？</h4><p><code>Connection</code>提供了事务处理的方法，通过调用<code>setAutoCommit(false)</code>可以设置手动提交事务；当事务完成后用<code>commit()</code>显式提交事务；如果在事务处理过程中发生异常则通过<code>rollback()</code>进行事务回滚。除此之外，从<code>JDBC 3.0</code>中还引入了<code>Savepoint</code>（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制"><a href="#Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制" class="headerlink" title="Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制"></a>Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制</h4><ol>
<li><p>Java源码编译机制：Java 源码编译由以下三个过程组成：①分析和输入到符号表，②注解处理，③语义分析和生成class文件。最后生成的class文件由以下部分组成：</p>
<ol>
<li>结构信息：包括class文件格式版本号及各部分的数量与大小的信息</li>
<li>元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池</li>
<li>方法信息：对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息</li>
</ol>
</li>
<li><p>类加载机制：JVM的类加载是通过<code>ClassLoader</code>及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</p>
<p><img src="/2018/09/16/interview-java-basic/F:/code/git/ZhaoGitHub1.github.io/source/_posts/interview-java-basic/image7.png" alt=""></p>
<ol>
<li><code>Bootstrap ClassLoader</code>：负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类</li>
<li><code>Extension ClassLoader</code>：负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包</li>
<li><code>App ClassLoader</code>：负责记载classpath中指定的jar包及目录中class</li>
<li><code>Custom ClassLoader</code>：属于应用程序根据自身需要自定义的<code>ClassLoader</code>，如<code>tomcat</code>、<code>jboss</code>都会根据j2ee规范自行实现<code>ClassLoader</code></li>
</ol>
<p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从<code>Custom ClassLoader</code>到<code>BootStrap ClassLoader</code>逐层检查，只要某个<code>classloader</code>已加载就视为已加载此类，保证此类只所有<code>ClassLoader</code>加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p>
</li>
<li><p>类执行机制：JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈，也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。</p>
<p>JVM执行class字节码，线程创建后，都会产生<code>程序计数器</code>（<code>PC</code>）和<code>栈</code>（<code>Stack</code>），<code>程序计数器</code>存放下一条要执行的指令在方法内的偏移量，<code>栈</code>中存放一个个<code>栈帧</code>，每个<code>栈帧</code>对应着每个方法的每次调用，而<code>栈帧</code>又是有<code>局部变量区</code>和<code>操作数栈</code>两部分组成，<code>局部变量区</code>用于存放方法中的局部变量和参数，<code>操作数栈</code>中用于存放方法执行过程中产生的中间结果。</p>
</li>
</ol>
<blockquote>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="noopener">https://blog.csdn.net/jackfrued/article/details/44921941</a></p>
<p><a href="https://github.com/Snailclimb/JavaGuide?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide?utm_source=gold_browser_extension</a></p>
</blockquote>
</the>
      
    </div>
    
  </div>
  
    















    <div class="copyright">
        <p><span>本文标题:</span><a  href="/2018/09/16/interview-java-basic/">面试之---java基础相关</a></p>
        <p><span>文章作者:</span><a  href="/" title="访问 逸竹 的个人博客">逸竹</a></p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/09/16/interview-java-basic/" title="面试之---java基础相关">http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/　　作者: 逸竹" title=""></span>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a  href="/2018/09/16/interview-tools/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          面试之---运维及工具使用相关
        
      </div>
    </a>
  
  
    <a  href="/2018/09/16/interview-middleware/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">面试之---中间件相关</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念相关"><span class="toc-number">1.</span> <span class="toc-text">概念相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象的特征：抽象、继承、封装、多态"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象的特征：抽象、继承、封装、多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？"><span class="toc-number">1.2.</span> <span class="toc-text">什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><span class="toc-number">1.3.</span> <span class="toc-text">重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接口的意义"><span class="toc-number">1.4.</span> <span class="toc-text">接口的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建对象的几种方式"><span class="toc-number">1.5.</span> <span class="toc-text">创建对象的几种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk源码相关（不包含多线程和集合）"><span class="toc-number">2.</span> <span class="toc-text">jdk源码相关（不包含多线程和集合）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int-Integer的区别："><span class="toc-number">2.1.</span> <span class="toc-text">int Integer的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i与i-仅是“先加”与“后加”的差别吗？"><span class="toc-number">2.2.</span> <span class="toc-text">++i与i++仅是“先加”与“后加”的差别吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个对象值相同-x-equals-y-true-，但却可有不同的hashCode，这句话对不对？"><span class="toc-number">2.3.</span> <span class="toc-text">两个对象值相同(x.equals(y) == true)，但却可有不同的hashCode，这句话对不对？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本for循环与加强型for循环的差别"><span class="toc-number">2.4.</span> <span class="toc-text">基本for循环与加强型for循环的差别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><span class="toc-number">2.5.</span> <span class="toc-text">Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中如何实现序列化，有什么意义？"><span class="toc-number">2.6.</span> <span class="toc-text">Java中如何实现序列化，有什么意义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获得一个类的类对象有哪些方式？"><span class="toc-number">2.7.</span> <span class="toc-text">获得一个类的类对象有哪些方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何通过反射创建对象？"><span class="toc-number">2.8.</span> <span class="toc-text">如何通过反射创建对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何通过反射调用对象的方法？"><span class="toc-number">2.9.</span> <span class="toc-text">如何通过反射调用对象的方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中如何实现序列化，有什么意义？-1"><span class="toc-number">2.10.</span> <span class="toc-text">Java中如何实现序列化，有什么意义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个Integer的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？"><span class="toc-number">2.11.</span> <span class="toc-text">两个Integer的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String类为什么是final的？"><span class="toc-number">2.12.</span> <span class="toc-text">String类为什么是final的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO"><span class="toc-number">3.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-中-IO-流分为几种"><span class="toc-number">3.1.</span> <span class="toc-text">java 中 IO 流分为几种?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO-NIO-AIO-有什么区别"><span class="toc-number">3.2.</span> <span class="toc-text">BIO,NIO,AIO 有什么区别?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合"><span class="toc-number">4.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List、Set、Map是否继承自Collection接口？"><span class="toc-number">4.1.</span> <span class="toc-text">List、Set、Map是否继承自Collection接口？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap在JDK1-7和JDK1-8中有哪些不同？"><span class="toc-number">4.2.</span> <span class="toc-text">HashMap在JDK1.7和JDK1.8中有哪些不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说一说HashMap中put方法"><span class="toc-number">4.3.</span> <span class="toc-text">说一说HashMap中put方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap是使用了哪些方法来有效解决哈希冲突的"><span class="toc-number">4.4.</span> <span class="toc-text">HashMap是使用了哪些方法来有效解决哈希冲突的:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><span class="toc-number">4.5.</span> <span class="toc-text">HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#面试官：那怎么解决呢？"><span class="toc-number">4.5.1.</span> <span class="toc-text">面试官：那怎么解决呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#面试官：为什么数组长度要保证为2的幂次方呢？"><span class="toc-number">4.5.2.</span> <span class="toc-text">面试官：为什么数组长度要保证为2的幂次方呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#面试官：那为什么是两次扰动呢？"><span class="toc-number">4.5.3.</span> <span class="toc-text">面试官：那为什么是两次扰动呢？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么HashMap中String、Integer这样的包装类适合作为K？"><span class="toc-number">4.6.</span> <span class="toc-text">为什么HashMap中String、Integer这样的包装类适合作为K？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#面试官：如果我想要让自己的Object作为K应该怎么办呢？"><span class="toc-number">4.6.1.</span> <span class="toc-text">面试官：如果我想要让自己的Object作为K应该怎么办呢？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList和LinkedList的区别？"><span class="toc-number">4.7.</span> <span class="toc-text">ArrayList和LinkedList的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？"><span class="toc-number">4.8.</span> <span class="toc-text">Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程"><span class="toc-number">5.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？"><span class="toc-number">5.1.</span> <span class="toc-text">Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized关键字的用法？"><span class="toc-number">5.2.</span> <span class="toc-text">synchronized关键字的用法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的基本状态以及状态之间的关系？"><span class="toc-number">5.3.</span> <span class="toc-text">线程的基本状态以及状态之间的关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简述synchronized-和java-util-concurrent-locks-Lock的异同？"><span class="toc-number">5.4.</span> <span class="toc-text">简述synchronized 和java.util.concurrent.locks.Lock的异同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#怎么防止死锁？"><span class="toc-number">5.5.</span> <span class="toc-text">怎么防止死锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何控制线程的执行顺序？"><span class="toc-number">5.6.</span> <span class="toc-text">如何控制线程的执行顺序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java中的Volatile和synchronized的差异？"><span class="toc-number">5.7.</span> <span class="toc-text">java中的Volatile和synchronized的差异？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Callable和Future"><span class="toc-number">5.8.</span> <span class="toc-text">什么是Callable和Future?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么使用Executor框架比使用应用创建和管理线程好？"><span class="toc-number">5.9.</span> <span class="toc-text">为什么使用Executor框架比使用应用创建和管理线程好？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建线程池有哪几种方式？"><span class="toc-number">5.10.</span> <span class="toc-text">创建线程池有哪几种方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><span class="toc-number">5.11.</span> <span class="toc-text">乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java线程池中submit-和-execute-方法有什么区别？"><span class="toc-number">5.12.</span> <span class="toc-text">Java线程池中submit() 和 execute()方法有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池执行流程"><span class="toc-number">5.13.</span> <span class="toc-text">线程池执行流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM"><span class="toc-number">6.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM体系结构"><span class="toc-number">6.1.</span> <span class="toc-text">JVM体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何识别垃圾，判定对象是否可被回收？"><span class="toc-number">6.2.</span> <span class="toc-text">如何识别垃圾，判定对象是否可被回收？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-中的堆是-GC-收集垃圾的主要区域"><span class="toc-number">6.3.</span> <span class="toc-text">Java 中的堆是 GC 收集垃圾的主要区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC算法"><span class="toc-number">6.4.</span> <span class="toc-text">GC算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。"><span class="toc-number">6.4.1.</span> <span class="toc-text">按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#按分区对待可分为：增量收集算法，分代收集算法"><span class="toc-number">6.4.2.</span> <span class="toc-text">按分区对待可分为：增量收集算法，分代收集算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#系统线程可分为：串行收集算法，并行收集算法，并发收集算法"><span class="toc-number">6.4.3.</span> <span class="toc-text">系统线程可分为：串行收集算法，并行收集算法，并发收集算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-垃圾收集器有哪些？"><span class="toc-number">6.5.</span> <span class="toc-text">JVM 垃圾收集器有哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java与数据库"><span class="toc-number">7.</span> <span class="toc-text">Java与数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#阐述JDBC操作数据库的步骤"><span class="toc-number">7.1.</span> <span class="toc-text">阐述JDBC操作数据库的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在进行数据库编程时，连接池有什么作用？"><span class="toc-number">7.2.</span> <span class="toc-text">在进行数据库编程时，连接池有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDBC中如何进行事务处理？"><span class="toc-number">7.3.</span> <span class="toc-text">JDBC中如何进行事务处理？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-number">8.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制"><span class="toc-number">8.1.</span> <span class="toc-text">Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制</span></a></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>






    
        <section id="comments">
<link rel="stylesheet" href="/css/gitment.min.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: '面试之---java基础相关', // 可选。默认为 location.href
  owner: 'ZhaoGitHub1',
  repo: 'ZhaoGitHub1.github.io',
  oauth: {
    client_id: '0959e9fdfc97cef82968',
    client_secret: '126454836d441306e61dfbf9bb3ddc6cef1bf93d',
  },
})
gitment.render('comments')
</script>
</section>
    



    <div class="scroll" id="post-nav-button">
        
            <a  href="/2018/09/16/interview-tools/" title="上一篇: 面试之---运维及工具使用相关">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a  href="/2018/09/16/interview-middleware/" title="下一篇: 面试之---中间件相关">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/10/29/interview-general/">面试系列整理说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/tool-idea/">IDEA使用总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/12/tool-recommend/">工具推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/spring-data-jpa-summary/">spring-data-jpa使用总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/10/list-books/">推荐书单整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/01/redis-file-lock/">redis实现分布式文件夹锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/16/read-note-readable-code/">读书笔记---《编写可读代码的艺术》</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/27/hashmap/">HashMap源码阅读</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/28/java-code-optimize/">java代码优化建议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/git-commands/">git常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-web/">面试之---web相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-optimize/">面试之---安全和性能优化相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-framework/">面试之---框架相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-project/">面试之---项目相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-network/">面试之---网络相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-spring/">面试之---Spring系列相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-tools/">面试之---运维及工具使用相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-java-basic/">面试之---java基础相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-middleware/">面试之---中间件相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-algorithm/">面试之---算法相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-data-structures/">面试之---数据结构相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-design-pattern/">面试之---设计模式相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-db/">面试之---数据库相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-others/">面试之---其他细小知识点汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/15/linux-commands/">linux常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/tree-projects/">项目树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/12/redis-summary/">Redis总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/about-Hexo/">Hexo博客搭建相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/10/pattern-singleton/">设计模式之---单例模式(Singleton Pattern)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/09/list-sites/">常用网站清单</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/my-pictures/">我的画集</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/tree-skills/">技能树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/pattern-all/">设计模式之---汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/springboot-app-deploy/">SpringBoot项目打包发布Linux环境完整流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/nginx-config/">【转载】nginx配置文件nginx.conf超详细讲解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/concurrentHashMap-analyze/">【转载】ConcurrentHashMap原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/thread-realize/">创建线程的几种方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/springApplication-analyze/">SpringBoot源码分析之---SpringBoot项目启动类SpringApplication浅析</a></li></ul>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2019 逸竹
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/ZhaoGitHub1" target="_blank">Blog</a> by 逸竹
            </div>
        </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 8;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?eb7d8cefd581790a3213e8feb93ae89f";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>