<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="JF09eNDd2m" />
  
  
  
  
  <title>面试之---java基础相关 | 逸竹小站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="包含定义概念、源码细节、集合、多线程、jvm、jdk新特性等方面java基础相关面试题汇总">
<meta name="keywords" content="总结,java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="面试之---java基础相关">
<meta property="og:url" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/index.html">
<meta property="og:site_name" content="逸竹小站">
<meta property="og:description" content="包含定义概念、源码细节、集合、多线程、jvm、jdk新特性等方面java基础相关面试题汇总">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/interview.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/image2.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/image3.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/image9.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/image1.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/threadPool.png">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/image7.png">
<meta property="og:updated_time" content="2019-07-15T14:40:25.976Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试之---java基础相关">
<meta name="twitter:description" content="包含定义概念、源码细节、集合、多线程、jvm、jdk新特性等方面java基础相关面试题汇总">
<meta name="twitter:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/interview.png">
  
    <link rel="alternative" href="/atom.xml" title="逸竹小站" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/logo.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">逸竹</a></h1>
        </hgroup>
        
        <p class="header-subtitle">未来不迎，当时不杂，过往不恋！</p>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/tags/">分类&amp;标签</a></li>
                        
                            <li><a  href="/books/">我的读书</a></li>
                        
                            <li><a  href="/movies/">我的电影</a></li>
                        
                            <li><a  href="/categories/tree/">树</a></li>
                        
                            <li><a  href="/categories/interview/">面试</a></li>
                        
                            <li><a  href="/categories/lists/">清单</a></li>
                        
                            <li><a  href="/aboutme/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="https://github.com/ZhaoGitHub1/" title="github">github</a>
                            
                                <a class="fl douban"  target="_blank" href="https://www.douban.com/people/174692469/" title="douban">douban</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/ConcurrentHashMap/" style="font-size: 10px;">ConcurrentHashMap</a> <a href="/tags/SpringData/" style="font-size: 10px;">SpringData</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hashmap/" style="font-size: 10px;">hashmap</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java基础/" style="font-size: 10px;">java基础</a> <a href="/tags/kafka/" style="font-size: 10px;">kafka</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/linux命令/" style="font-size: 10px;">linux命令</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/orm/" style="font-size: 10px;">orm</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springboot/" style="font-size: 13.33px;">springboot</a> <a href="/tags/springboot源码分析/" style="font-size: 10px;">springboot源码分析</a> <a href="/tags/优化/" style="font-size: 10px;">优化</a> <a href="/tags/分布式锁/" style="font-size: 10px;">分布式锁</a> <a href="/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/tags/命令/" style="font-size: 10px;">命令</a> <a href="/tags/在线工具/" style="font-size: 10px;">在线工具</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/工具/" style="font-size: 16.67px;">工具</a> <a href="/tags/性能/" style="font-size: 10px;">性能</a> <a href="/tags/总结/" style="font-size: 20px;">总结</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/素描/" style="font-size: 10px;">素描</a> <a href="/tags/编码艺术/" style="font-size: 10px;">编码艺术</a> <a href="/tags/网站地址/" style="font-size: 10px;">网站地址</a> <a href="/tags/读书/" style="font-size: 13.33px;">读书</a> <a href="/tags/转载/" style="font-size: 13.33px;">转载</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://blog.csdn.net/qq_25885525">我的csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://github.com/ZhaoGitHub1">我的github</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://gitee.com/zhao-183479916">我的gitee</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://spring.io/">Spring官网</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.mybatis.org/mybatis-3/zh/index.html">Mybatis官网</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://hibernate.org/">Hibernate官网</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">一名普通的java 后台开发工程师~~  邮箱：183479916@qq.com</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">逸竹</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/logo.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">逸竹</a></h1>
            </hgroup>
            
            <p class="header-subtitle">未来不迎，当时不杂，过往不恋！</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">分类&amp;标签</a></li>
                
                    <li><a href="/books/">我的读书</a></li>
                
                    <li><a href="/movies/">我的电影</a></li>
                
                    <li><a href="/categories/tree/">树</a></li>
                
                    <li><a href="/categories/interview/">面试</a></li>
                
                    <li><a href="/categories/lists/">清单</a></li>
                
                    <li><a href="/aboutme/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/ZhaoGitHub1/" title="github">github</a>
                    
                        <a class="douban" target="_blank" href="https://www.douban.com/people/174692469/" title="douban">douban</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-interview-java-basic" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/09/16/interview-java-basic/" class="article-date">
      <time datetime="2018-09-16T13:06:51.000Z" itemprop="datePublished">2018-09-16</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面试之---java基础相关
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/interview/">interview</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong> 面试之---java基础相关：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p>
<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">

<p><img src="/2018/09/16/interview-java-basic/interview.png" alt=""></p>
<blockquote>
<p>持续维护java面试题系列博文，发现好的面试题会更新进来。总结的并不只是如何回答面试官，而是这道题涉及到的知识点，明白了相关知识点和面试官要问的点，回答起来就不是问题了。</p>
</blockquote>
<h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h3><h4 id="面向对象的特征：抽象、继承、封装、多态"><a href="#面向对象的特征：抽象、继承、封装、多态" class="headerlink" title="面向对象的特征：抽象、继承、封装、多态"></a>面向对象的特征：<code>抽象</code>、<code>继承</code>、<code>封装</code>、<code>多态</code></h4><ol>
<li><code>抽象</code>：抽象就是忽略一个主题中与当前目标无关的那些方面，以便充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一个过程抽象，而是数据抽象。</li>
<li><code>继承</code>：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更合适特殊的需要。</li>
<li><code>封装</code>：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向、对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</li>
<li><code>多态性</code>：多态性事指允许不同类的对象对同一个消息作出响应。多态性包括参数多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</li>
</ol>
<h4 id="什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？"><a href="#什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？" class="headerlink" title="什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？"></a>什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？</h4><ol>
<li>具有关键字abstract，实现内容上没有完全定义的类就叫抽象类。</li>
<li>抽象类和接口的区别如下：<ol>
<li>在类来继承抽象类时，只需要实现部分方法和全部抽象方法，而实现接口则要实现里面的全部方法。</li>
<li>在接口中无成员变量，而抽象类可有成员变量。</li>
<li>在java中引进接口主要是为了解决多继承的问题。</li>
</ol>
</li>
</ol>
<h4 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（<code>Overload</code>）和重写（<code>Override</code>）的区别。重载的方法能否根据返回类型进行区分？</h4><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p>
<h4 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h4><p>规范、扩展、回调</p>
<h4 id="创建对象的几种方式"><a href="#创建对象的几种方式" class="headerlink" title="创建对象的几种方式"></a>创建对象的几种方式</h4><p>new、反射、clone、序列化</p>
<h3 id="jdk源码相关（不包含多线程和集合）"><a href="#jdk源码相关（不包含多线程和集合）" class="headerlink" title="jdk源码相关（不包含多线程和集合）"></a>jdk源码相关（不包含多线程和集合）</h3><h4 id="int-Integer的区别："><a href="#int-Integer的区别：" class="headerlink" title="int Integer的区别："></a><code>int</code> <code>Integer</code>的区别：</h4><ol>
<li>java提供两种不同的类型：引用类型和原始类型（或内置类型）。<code>int</code>是java的原始类型数据，<code>Integer</code>是java为<code>int</code>提供的封装类。Java为每个原始类提供了封装类。</li>
<li>原始类型封装： <code>boolean</code> <code>Boolean</code>、<code>char</code> <code>Character</code>、<code>byte</code> <code>Byte</code>、<code>short</code> <code>Short</code>、<code>int</code> <code>Integer</code>、<code>long</code> <code>Long</code>、<code>float</code> <code>Float</code>、<code>double</code> <code>Double</code></li>
<li>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为<code>null</code>，而原始类型实例变量的缺省值与它们的类型有关。</li>
</ol>
<h4 id="i与i-仅是“先加”与“后加”的差别吗？"><a href="#i与i-仅是“先加”与“后加”的差别吗？" class="headerlink" title="++i与i++仅是“先加”与“后加”的差别吗？"></a>++i与i++仅是“先加”与“后加”的差别吗？</h4><p>前置 ++ 是将变量的值加1后，使用增值后的变量进行运算的，而后置++ 是首先将变量赋值给一个临时变量，接下来对变量的值加1，然后使用那个临时变量进行运算。</p>
<h4 id="两个对象值相同-x-equals-y-true-，但却可有不同的hashCode，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hashCode，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hashCode，这句话对不对？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的<code>hashCode</code>，这句话对不对？</h4><ol>
<li>如果两个对象x和y满足x.equals(y) == true，它们的哈希码（<code>hash code</code>）应当相同。Java对于<code>eqauls</code>方法和<code>hashCode</code>方法是这样规定的：</li>
<li>如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；</li>
<li>如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，    同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</li>
</ol>
<blockquote>
<p>补充：在Joshua Bloch的大作《Effective Java》中是这样介绍<code>equals</code>方法的：首先<code>equals</code>方法必须满足<code>自反性</code>（x.equals(x)必须返回<code>true</code>）、<code>对称性</code>（x.equals(y)返回<code>true</code>时，y.equals(x)也必须返回<code>true</code>）、<code>传递性</code>（x.equals(y)和y.equals(z)都返回<code>true</code>时，x.equals(z)也必须返回<code>true</code>）和<code>一致性</code>（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非<code>null</code>值的引用x，x.equals(null)必须返回<code>false</code>。实现高质量的<code>equals</code>方法的诀窍包括： 使用<code>==</code>操作符检查”参数是否为这个对象的引用”；2. 使用<code>instanceof</code>操作符检查”参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完<code>equals</code>方法后，问自己它是否满足<code>对称性</code>、<code>传递性</code>、<code>一致性</code>；5. 重写<code>equals</code>时总是要重写<code>hashCode</code>；6. 不要将<code>equals</code>方法参数中的<code>Object</code>对象替换为其他的类型，在重写时不要忘掉<code>@Override</code>注解。</p>
</blockquote>
<h4 id="基本for循环与加强型for循环的差别"><a href="#基本for循环与加强型for循环的差别" class="headerlink" title="基本for循环与加强型for循环的差别"></a>基本for循环与加强型for循环的差别</h4><ol>
<li>在访问数组与Iterable类型变量时，使用加强型for循环比基本for循环要方便快捷。但是，加强型for循环也有一定的局限性，也就意味着加强型for循环不可能完全取代基本for循环。</li>
<li>加强型for循环右侧变量必须为数组类型或者Iterable类型。</li>
<li>加强型for循环在底层也是由基本for循环来实现的。</li>
</ol>
<h4 id="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>Java语言如何进行异常处理，关键字：<code>throws</code>、<code>throw</code>、<code>try</code>、<code>catch</code>、<code>finally</code>分别如何使用？</h4><ol>
<li>Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是<code>Throwable</code>类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：<code>try</code>、<code>catch</code>、<code>throw</code>、<code>throws</code>和<code>finally</code>。</li>
<li>一般情况下是用<code>try</code>来执行一段程序，如果系统会抛出（<code>throw</code>）一个异常对象，可以通过它的类型来捕获（<code>catch</code>）它，或通过总是执行代码块（<code>finally</code>）来处理；<ol>
<li><code>try</code>用来指定一块预防所有异常的程序；<code>catch</code>子句紧跟在<code>try</code>块后面，用来指定你想要捕获的异常的类型；</li>
<li><code>throw</code>语句用来明确地抛出一个异常；</li>
<li><code>throws</code>用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；</li>
<li><code>finally</code>为确保一段代码不管发生什么异常状况都要被执行；</li>
<li><code>try</code>语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的<code>try</code>语句或者最终将异常抛给<code>JVM</code>。</li>
</ol>
</li>
</ol>
<h4 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h4><ol>
<li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。</li>
<li>要实现序列化，需要让一个类实现<code>Serializable</code>接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过<code>writeObject(Object)</code>方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过<code>readObject</code>方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。</li>
</ol>
<h4 id="获得一个类的类对象有哪些方式？"><a href="#获得一个类的类对象有哪些方式？" class="headerlink" title="获得一个类的类对象有哪些方式？"></a>获得一个类的类对象有哪些方式？</h4><ol>
<li>类型<code>.class</code>，例如：String.class</li>
<li>对象<code>.getClass()</code>，例如：”hello”.getClass()</li>
<li><code>Class.forName()</code>，例如：Class.forName(“java.lang.String”)</li>
</ol>
<h4 id="如何通过反射创建对象？"><a href="#如何通过反射创建对象？" class="headerlink" title="如何通过反射创建对象？"></a>如何通过反射创建对象？</h4><ol>
<li>通过类对象调用<code>newInstance()</code>方法，例如：String.class.newInstance()</li>
<li>通过类对象的<code>getConstructor()</code>或<code>getDeclaredConstructor()</code>方法获得构造器（<code>Constructor</code>）对象并调用其<code>newInstance()</code>方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);</li>
</ol>
<h4 id="如何通过反射调用对象的方法？"><a href="#如何通过反射调用对象的方法？" class="headerlink" title="如何通过反射调用对象的方法？"></a>如何通过反射调用对象的方法？</h4><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInvokeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = <span class="string">"hello"</span>;</span><br><span class="line">        Method m = str.getClass().getMethod(<span class="string">"toUpperCase"</span>);</span><br><span class="line">        System.out.println(m.invoke(str));  <span class="comment">// HELLO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="Java中如何实现序列化，有什么意义？-1"><a href="#Java中如何实现序列化，有什么意义？-1" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h4><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。  要实现序列化，需要让一个类实现<code>Serializable</code>接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过<code>writeObject(Object)</code>方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过<code>readObject</code>方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。</p>
<h4 id="两个Integer的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？"><a href="#两个Integer的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？" class="headerlink" title="两个Integer的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？"></a>两个<code>Integer</code>的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？</h4><p>第一种<strong>错误方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"before:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"after:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer i1, Integer i2)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Integer tmp = i1;</span><br><span class="line">        i2 = i1;</span><br><span class="line">        i1 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>before:a=1,b=2<br>after:a=1,b=2</p>
</blockquote>
<p>第二种<strong>错误方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"before:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"after:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer i1, Integer i2)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Field field = Integer.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Integer tmp = i1;</span><br><span class="line">        field.set(i1,i2);</span><br><span class="line">        field.set(i2,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>before:a=1,b=2<br>after:a=2,b=2</p>
</blockquote>
<p>正确的一种做法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"before:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"after:a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer i1, Integer i2)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException</span>&#123;</span><br><span class="line">        Field field = Integer.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Integer tmp = <span class="keyword">new</span> Integer(i1);</span><br><span class="line">        field.set(i1,i2);</span><br><span class="line">        field.set(i2,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>before:a=1,b=2<br>after:a=2,b=1</p>
</blockquote>
<p>涉及到的知识点：</p>
<ul>
<li>自动装箱和拆箱</li>
<li>Integer -128到127之间的缓存</li>
<li>如何通过反射区修改private final变量的值</li>
</ul>
<h4 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h4><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>按操作方式分类结构图：<img src="/2018/09/16/interview-java-basic/image2.png" alt=""></p>
<p>按操作对象分类结构图：<img src="/2018/09/16/interview-java-basic/image3.png" alt=""></p>
<h4 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h4><ul>
<li><strong>BIO (Blocking I/O):</strong> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li><strong>NIO (New I/O):</strong> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
<li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><img src="/2018/09/16/interview-java-basic/image9.png" alt=""></p>
<h4 id="List、Set、Map是否继承自Collection接口？"><a href="#List、Set、Map是否继承自Collection接口？" class="headerlink" title="List、Set、Map是否继承自Collection接口？"></a>List、Set、Map是否继承自Collection接口？</h4><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？"><a href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？" class="headerlink" title="Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？"></a><code>Thread</code>类的<code>sleep()</code>方法和对象的<code>wait()</code>方法都可以让线程暂停执行，它们有什么区别？</h4><p><code>sleep()</code>方法（休眠）是线程类（<code>Thread</code>）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。<code>wait()</code>是<code>Object</code>类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的<code>notify()</code>方法（或<code>notifyAll()</code>方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p>
<blockquote>
<p>补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。</p>
</blockquote>
<h4 id="synchronized关键字的用法？"><a href="#synchronized关键字的用法？" class="headerlink" title="synchronized关键字的用法？"></a>synchronized关键字的用法？</h4><p><code>synchronized</code>关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将<code>synchronized</code>作为方法的修饰符。</p>
<h4 id="线程的基本状态以及状态之间的关系？"><a href="#线程的基本状态以及状态之间的关系？" class="headerlink" title="线程的基本状态以及状态之间的关系？"></a>线程的基本状态以及状态之间的关系？</h4><p><img src="/2018/09/16/interview-java-basic/image1.png" alt=""></p>
<blockquote>
<p><strong>说明：</strong>其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。</p>
</blockquote>
<h4 id="简述synchronized-和java-util-concurrent-locks-Lock的异同？"><a href="#简述synchronized-和java-util-concurrent-locks-Lock的异同？" class="headerlink" title="简述synchronized 和java.util.concurrent.locks.Lock的异同？"></a>简述synchronized 和java.util.concurrent.locks.Lock的异同？</h4><p><code>Lock</code>是Java 5以后引入的新的API，和关键字<code>synchronized</code>相比主要相同点：<code>Lock</code> 能完成<code>synchronized</code>所实现的所有功能；主要不同点：<code>Lock</code>有比<code>synchronized</code>更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。<code>synchronized</code>会自动释放锁，而<code>Lock</code>一定要求程序员手工释放，并且最好在<code>finally</code> 块中释放（这是释放外部资源的最好的地方）。</p>
<h4 id="如何控制线程的执行顺序？"><a href="#如何控制线程的执行顺序？" class="headerlink" title="如何控制线程的执行顺序？"></a>如何控制线程的执行顺序？</h4><ol>
<li><p>使用join方法，join方法是让主线程等待子线程结束后才能继续运行</p>
</li>
<li><p>使用<code>ExecutorService executor = Executors.newSingleThreadExecutor();</code>方法</p>
<ul>
<li><code>newSingleThreadExecutor()</code>方法会创建一个只有一个线程的线程池FIFO的方式来操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">executorService.submit(thread1);</span><br><span class="line">executorService.submit(thread1);</span><br><span class="line">executorService.submit(thread1);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="java中的Volatile和synchronized的差异？"><a href="#java中的Volatile和synchronized的差异？" class="headerlink" title="java中的Volatile和synchronized的差异？"></a>java中的Volatile和synchronized的差异？</h4><ol>
<li><p>线程之间通信的两种方式：</p>
<ol>
<li><p>共享内存-隐式通信</p>
</li>
<li><p>消息传递-显式通信</p>
</li>
</ol>
</li>
<li><p>线程之间如何保证消息同步：</p>
<ol>
<li>在共享内存的并发模型中，同步是显示做的：synchronized</li>
<li>在消息传递的并发模型中，由于消息的发送必须在消息接收之前，所以同步是隐式的</li>
</ol>
</li>
<li><p>多线程的共享变量是如何同步的</p>
<ol>
<li>线程A修改本地内存的变量值——&gt;同步到主内存的共享变量——&gt;线程B从主内存取得共享变量的值，刷新本地内存中的变量值</li>
</ol>
</li>
<li><p>Volatile关键字保证可见性</p>
<ol>
<li>对声明了Volatile的变量进行写操作的时候，JVM会向处理器发送一条Lock前缀的指令，会把这个变量所在缓存行的数据写回到主内存</li>
</ol>
</li>
</ol>
<h4 id="什么是Callable和Future"><a href="#什么是Callable和Future" class="headerlink" title="什么是Callable和Future?"></a>什么是Callable和Future?</h4><p>Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。 </p>
<p>可以认为是带有回调的Runnable。</p>
<p>Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p>
<h4 id="为什么使用Executor框架比使用应用创建和管理线程好？"><a href="#为什么使用Executor框架比使用应用创建和管理线程好？" class="headerlink" title="为什么使用Executor框架比使用应用创建和管理线程好？"></a>为什么使用Executor框架比使用应用创建和管理线程好？</h4><p><strong>为什么要使用Executor线程池框架</strong></p>
<p>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。 </p>
<p>调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。 </p>
<p>直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</p>
<p><strong>使用Executor线程池框架的优点</strong></p>
<p>能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开销。 </p>
<p>可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。 </p>
<p>框架中已经有定时、定期、单线程、并发数控制等功能。 </p>
<p>综上所述使用线程池框架Executor能更好的管理线程、提供系统资源使用率。</p>
<h4 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h4><p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p>
<p><strong>乐观锁</strong>：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<p><strong>乐观锁的实现方式</strong>： </p>
<p>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。 </p>
<p>java中的Compare and Swap即CAS ，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。　CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。</p>
<p><strong>CAS缺点</strong>：</p>
<p><strong>ABA问题</strong>：<br>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。 </p>
<p><strong>循环时间长开销大</strong>：<br>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 </p>
<p><strong>只能保证一个共享变量的原子操作</strong>：<br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p>
<h4 id="Java线程池中submit-和-execute-方法有什么区别？"><a href="#Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="Java线程池中submit() 和 execute()方法有什么区别？"></a>Java线程池中submit() 和 execute()方法有什么区别？</h4><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中。</p>
<p>而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p>
<h4 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h4><p><img src="/2018/09/16/interview-java-basic/threadPool.png" alt=""></p>
<p>执行流程</p>
<ul>
<li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</li>
<li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li>
<li>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</li>
<li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li>
</ul>
<p>JDK提供了四种拒绝策略处理类</p>
<ul>
<li>AbortPolicy(抛出一个异常，默认的)</li>
<li>DiscardPolicy(直接丢弃任务)</li>
<li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li>
<li>CallerRunsPolicy（交给线程池调用所在的线程进行处理）</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h4><p><code>方法区</code>和<code>堆</code>为线程共享资源，<code>虚拟机栈</code>、<code>本地方法栈</code>和<code>程序计数器</code>线程私有</p>
<ol>
<li><p><code>本地方法栈</code>：它的具体做法是<code>Native Method Stack</code>中登记<code>native</code>方法，在<code>Execution Engine</code>执行时加载native libraies。</p>
</li>
<li><p><code>程序计数器</code>：每个线程都有一个程序计算器，就是一个指针，指向方法区中的方法字节码（下一个将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p>
</li>
<li><p><code>方法区</code>：方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域。<code>静态变量</code>+<code>常量</code>+<code>类信息</code>+<code>运行时常量池</code>存在<code>方法区</code>中，<code>实例变量</code>存在<code>堆内存</code>中。</p>
</li>
<li><p><code>栈</code>：<code>栈</code>也叫<code>栈内存</code>，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。基本类型的变量和对象的引用变量都是在函数的栈内存中分配。</p>
<blockquote>
<p>栈帧中主要保存3类数据：本地变量（Local Variables）：输入参数和输出参数以及方法内的变量；栈操作（Operand Stack）：记录出栈、入栈的操作；栈帧数据（Frame Data）：包括类文件、方法等等。</p>
</blockquote>
</li>
<li><p><code>堆</code>：<code>堆</code>这块区域是JVM中最大的，应用的对象和数据都是存在这个区域，这块区域也是线程共享的，也是 <code>gc</code> 主要的回收区，一个 JVM 实例只存在一个堆类存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分为三部分：新生区、养老区、永久区：</p>
<ol>
<li><p><code>新生区</code>：新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（<code>Eden space</code>）和幸存者区（<code>Survivor pace</code>），所有的类都是在伊甸区被new出来的。幸存区有两个：0区（<code>Survivor 0 space</code>）和1区（<code>Survivor 1 space</code>）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园进行垃圾回收（<code>Minor GC</code>）,将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1去也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生<code>Major GC</code>（<code>FullGCC</code>），进行养老区的内存清理。若养老区执行<code>Full GC</code> 之后发现依然无法进行对象的保存，就会产生OOM异常<code>OutOfMemoryError</code>。</p>
<p>如果出现<code>java.lang.OutOfMemoryError: Java heap space</code>异常，说明Java虚拟机的堆内存不够。原因有二：</p>
<ol>
<li>Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。</li>
</ol>
</li>
<li><p><code>养老区</code>：养老区用于保存从新生区筛选出来的 JAVA 对象，一般池对象都在这个区域活跃。</p>
</li>
<li><p><code>永久区</code>：永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。</p>
</li>
</ol>
<blockquote>
<p>如果出现<code>java.lang.OutOfMemoryError: PermGen space</code>，说明是Java虚拟机对永久代<code>Perm</code>内存设置不够。原因有二：</p>
<ul>
<li>程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。</li>
<li>大量动态反射生成的类不断被加载，最终导致<code>Perm</code>区被占满。</li>
</ul>
</blockquote>
<blockquote>
<p>说明：</p>
<p>Jdk1.6及之前：常量池分配在永久代 。</p>
<p>Jdk1.7：有，但已经逐步“去永久代” 。</p>
<p>Jdk1.8及之后：无(<code>java.lang.OutOfMemoryError: PermGen space</code>,这种错误将不会出现在JDK1.8中)。</p>
</blockquote>
</li>
</ol>
<h4 id="如何识别垃圾，判定对象是否可被回收？"><a href="#如何识别垃圾，判定对象是否可被回收？" class="headerlink" title="如何识别垃圾，判定对象是否可被回收？"></a>如何识别垃圾，判定对象是否可被回收？</h4><ul>
<li>引用计数法：给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。缺点：无法解决循环引用的问题</li>
<li>根搜索算法：也称可达性分析法，通过“GC ROOTs”的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收（可作为GC ROOTs的对象：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）</li>
</ul>
<h4 id="Java-中的堆是-GC-收集垃圾的主要区域"><a href="#Java-中的堆是-GC-收集垃圾的主要区域" class="headerlink" title="Java 中的堆是 GC 收集垃圾的主要区域"></a>Java 中的堆是 GC 收集垃圾的主要区域</h4><p>GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )</p>
<ul>
<li>Minor GC：新生代（Young Gen）空间不足时触发收集，由于Java 中的大部分对象通常不需长久存活，新生代是GC收集频繁区域，所以采用复制算法。</li>
<li>Full GC：老年代（Old Gen ）空间不足或元空间达到高水位线执行收集动作，由于存放大对象及长久存活下的对象，占用内存空间大，回收效率低，所以采用标记-清除算法。</li>
</ul>
<h4 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h4><h5 id="按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。"><a href="#按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。" class="headerlink" title="按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。"></a><strong>按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。</strong></h5><ol>
<li><p>标记-清除算法：分为两阶段“标记”和“清除”。首先标记出哪些对象可被回收，在标记完成之后统一回收所有被标记的对象所占用的内存空间。不足之处：1.无法处理循环引用的问题2.效率不高3.产生大量内存碎片（ps：空间碎片太多可能会导致以后在分配大对象的时候而无法申请到足够的连续内存空间，导致提前触发新一轮gc）</p>
</li>
<li><p>标记-整理算法：分为两阶段“标记”和“整理”。首先标记出哪些对象可被回收，在标记完成后，将对象向一端移动，然后直接清理掉边界以外的内存。</p>
</li>
<li><p>复制算法：把内存空间划为两个相等的区域，每次只使用其中一个区域。gc时遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。不足之处：1.内存利用率问题2.在对象存活率较高时，其效率会变低。</p>
</li>
</ol>
<h5 id="按分区对待可分为：增量收集算法，分代收集算法"><a href="#按分区对待可分为：增量收集算法，分代收集算法" class="headerlink" title="按分区对待可分为：增量收集算法，分代收集算法"></a><strong>按分区对待可分为：增量收集算法，分代收集算法</strong></h5><ol>
<li><p>增量收集:实时垃圾回收算法，即：在应用进行的同时进行垃圾回收，理论上可以解决传统分代方式带来的问题。增量收集把对堆空间划分成一系列内存块，使用时先使用其中一部分，垃圾收集时把之前用掉的部分中的存活对象再放到后面没有用的空间中，这样可以实现一直边使用边收集的效果，避免了传统分代方式整个使用完了再暂停的回收的情况。</p>
</li>
<li><p>分代收集:（商用默认）基于对象生命周期划分为新生代、老年代、元空间，对不同生命周期的对象使用不同的算法进行回收。</p>
</li>
</ol>
<h5 id="系统线程可分为：串行收集算法，并行收集算法，并发收集算法"><a href="#系统线程可分为：串行收集算法，并行收集算法，并发收集算法" class="headerlink" title="系统线程可分为：串行收集算法，并行收集算法，并发收集算法**"></a>系统线程可分为：串行收集算法，并行收集算法，并发收集算法**</h5><ol>
<li><p>串行收集:使用单线程处理垃圾回收工作，实现容易，效率较高。不足之处：1.无法发挥多处理器的优势 2.需要暂停用户线程</p>
</li>
<li><p>并行收集:使用多线程处理垃圾回收工作，速度快，效率高。理论上CPU数目越多，越能体现出并行收集器的优势。不足之处：需要暂停用户线程</p>
</li>
<li><p>并发收集:垃圾线程与用户线程同时工作。系统在垃圾回收时不需要暂停用户线程</p>
</li>
</ol>
<h4 id="Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制"><a href="#Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制" class="headerlink" title="Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制"></a>Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制</h4><ol>
<li><p>Java源码编译机制：Java 源码编译由以下三个过程组成：①分析和输入到符号表，②注解处理，③语义分析和生成class文件。最后生成的class文件由以下部分组成：</p>
<ol>
<li>结构信息：包括class文件格式版本号及各部分的数量与大小的信息</li>
<li>元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池</li>
<li>方法信息：对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息</li>
</ol>
</li>
<li><p>类加载机制：JVM的类加载是通过<code>ClassLoader</code>及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</p>
<p><img src="/2018/09/16/interview-java-basic/image7.png" alt=""></p>
<ol>
<li><code>Bootstrap ClassLoader</code>：负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类</li>
<li><code>Extension ClassLoader</code>：负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包</li>
<li><code>App ClassLoader</code>：负责记载classpath中指定的jar包及目录中class</li>
<li><code>Custom ClassLoader</code>：属于应用程序根据自身需要自定义的<code>ClassLoader</code>，如<code>tomcat</code>、<code>jboss</code>都会根据j2ee规范自行实现<code>ClassLoader</code></li>
</ol>
<p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从<code>Custom ClassLoader</code>到<code>BootStrap ClassLoader</code>逐层检查，只要某个<code>classloader</code>已加载就视为已加载此类，保证此类只所有<code>ClassLoader</code>加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p>
</li>
<li><p>类执行机制：JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈，也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。</p>
<p>JVM执行class字节码，线程创建后，都会产生<code>程序计数器</code>（<code>PC</code>）和<code>栈</code>（<code>Stack</code>），<code>程序计数器</code>存放下一条要执行的指令在方法内的偏移量，<code>栈</code>中存放一个个<code>栈帧</code>，每个<code>栈帧</code>对应着每个方法的每次调用，而<code>栈帧</code>又是有<code>局部变量区</code>和<code>操作数栈</code>两部分组成，<code>局部变量区</code>用于存放方法中的局部变量和参数，<code>操作数栈</code>中用于存放方法执行过程中产生的中间结果。</p>
</li>
</ol>
<h3 id="Java与数据库"><a href="#Java与数据库" class="headerlink" title="Java与数据库"></a>Java与数据库</h3><h4 id="阐述JDBC操作数据库的步骤"><a href="#阐述JDBC操作数据库的步骤" class="headerlink" title="阐述JDBC操作数据库的步骤"></a>阐述JDBC操作数据库的步骤</h4><p>加载驱动 -&gt; 创建连接 -&gt; 创建语句 -&gt; 执行语句 -&gt; 处理结果 -&gt; 关闭资源</p>
<h4 id="在进行数据库编程时，连接池有什么作用？"><a href="#在进行数据库编程时，连接池有什么作用？" class="headerlink" title="在进行数据库编程时，连接池有什么作用？"></a>在进行数据库编程时，连接池有什么作用？</h4><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：<code>C3P0</code>、<code>Proxool</code>、<code>DBCP</code>、<code>BoneCP</code>、<code>Druid</code>、<code>HikariCP</code>等。</p>
<blockquote>
<p>补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。</p>
</blockquote>
<h4 id="JDBC中如何进行事务处理？"><a href="#JDBC中如何进行事务处理？" class="headerlink" title="JDBC中如何进行事务处理？"></a>JDBC中如何进行事务处理？</h4><p><code>Connection</code>提供了事务处理的方法，通过调用<code>setAutoCommit(false)</code>可以设置手动提交事务；当事务完成后用<code>commit()</code>显式提交事务；如果在事务处理过程中发生异常则通过<code>rollback()</code>进行事务回滚。除此之外，从<code>JDBC 3.0</code>中还引入了<code>Savepoint</code>（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。</p>
<h2 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h2><h3 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h3><h4 id="Servlet的优点"><a href="#Servlet的优点" class="headerlink" title="Servlet的优点:"></a>Servlet的优点:</h4><p>1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销</p>
<p>2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</p>
<p>3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。</p>
<p>4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</p>
<blockquote>
<p>补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。</p>
</blockquote>
<h4 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h4><p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p>
<ul>
<li><strong>void init(ServletConfig config) throws ServletException</strong></li>
<li><strong>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</strong></li>
<li><strong>void destory()</strong></li>
<li>java.lang.String getServletInfo()</li>
<li>ServletConfig getServletConfig()</li>
</ul>
<p><strong>生命周期：</strong> <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p>
<h3 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h3><h4 id="JSP有哪些内置对象、作用分别是什么"><a href="#JSP有哪些内置对象、作用分别是什么" class="headerlink" title="JSP有哪些内置对象、作用分别是什么"></a>JSP有哪些内置对象、作用分别是什么</h4><p>JSP有9个内置对象：</p>
<ul>
<li><code>request</code>：封装客户端的请求，其中包含来自GET或POST请求的参数；</li>
<li><code>response</code>：封装服务器对客户端的响应；</li>
<li><code>pageContext</code>：通过该对象可以获取其他对象；</li>
<li><code>session</code>：封装用户会话的对象；</li>
<li><code>application</code>：封装服务器运行环境的对象；</li>
<li><code>out</code>：输出服务器响应的输出流对象；</li>
<li><code>config</code>：Web应用的配置对象；</li>
<li><code>page</code>：JSP页面本身（相当于Java程序中的this）；</li>
<li><code>exception</code>：封装页面抛出异常的对象。</li>
</ul>
<h4 id="Request对象的主要方法有哪些"><a href="#Request对象的主要方法有哪些" class="headerlink" title="Request对象的主要方法有哪些"></a>Request对象的主要方法有哪些</h4><ul>
<li><code>setAttribute(String name,Object)</code>：设置名字为name的request 的参数值</li>
<li><code>getAttribute(String name)</code>：返回由name指定的属性值</li>
<li><code>getAttributeNames()</code>：返回request 对象所有属性的名字集合，结果是一个枚举的实例</li>
<li><code>getCookies()</code>：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组</li>
<li><code>getCharacterEncoding()</code> ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度</li>
<li><code>getHeader(String name)</code> ：获得HTTP协议定义的文件头信息</li>
<li><code>getHeaders(String name)</code> ：返回指定名字的request Header 的所有值，结果是一个枚举的实例</li>
<li><code>getHeaderNames()</code> ：返回所以request Header 的名字，结果是一个枚举的实例</li>
<li><code>getInputStream()</code> ：返回请求的输入流，用于获得请求中的数据</li>
<li><code>getMethod()</code> ：获得客户端向服务器端传送数据的方法</li>
<li><code>getParameter(String name)</code> ：获得客户端传送给服务器端的有 name指定的参数值</li>
<li><code>getParameterNames()</code> ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li>
<li><code>getParameterValues(String name)</code>：获得有name指定的参数的所有值</li>
<li><code>getProtocol()</code>：获取客户端向服务器端传送数据所依据的协议名称</li>
<li><code>getQueryString()</code> ：获得查询字符串</li>
<li><code>getRequestURI()</code> ：获取发出请求字符串的客户端地址</li>
<li><code>getRemoteAddr()</code>：获取客户端的 IP 地址</li>
<li><code>getRemoteHost()</code> ：获取客户端的名字</li>
<li><code>getSession([Boolean create])</code> ：返回和请求相关 Session</li>
<li><code>getServerName()</code> ：获取服务器的名字</li>
<li><code>getServletPath()</code>：获取客户端所请求的脚本文件的路径</li>
<li><code>getServerPort()</code>：获取服务器的端口号</li>
<li><code>removeAttribute(String name)</code>：删除请求中的一个属性</li>
</ul>
<blockquote>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="noopener">https://blog.csdn.net/jackfrued/article/details/44921941</a></p>
<p><a href="https://github.com/Snailclimb/JavaGuide?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide?utm_source=gold_browser_extension</a></p>
</blockquote>
</the>
      
    </div>
    
  </div>
  
    















    <div class="copyright">
        <p><span>本文标题:</span><a  href="/2018/09/16/interview-java-basic/">面试之---java基础相关</a></p>
        <p><span>文章作者:</span><a  href="/" title="访问 逸竹 的个人博客">逸竹</a></p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/09/16/interview-java-basic/" title="面试之---java基础相关">http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yizhuxiaozhan.site/2018/09/16/interview-java-basic/　　作者: 逸竹" title=""></span>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a  href="/2018/09/16/interview-db/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          面试之---数据库相关
        
      </div>
    </a>
  
  
    <a  href="/2018/09/16/interview-others/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">面试之---其他细小知识点汇总</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java基础"><span class="toc-number">1.</span> <span class="toc-text">java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念相关"><span class="toc-number">1.1.</span> <span class="toc-text">概念相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象的特征：抽象、继承、封装、多态"><span class="toc-number">1.1.1.</span> <span class="toc-text">面向对象的特征：抽象、继承、封装、多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？"><span class="toc-number">1.1.2.</span> <span class="toc-text">什么叫抽象类？抽象类跟接口有什么区别？为什么引进数据接口概念？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><span class="toc-number">1.1.3.</span> <span class="toc-text">重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接口的意义"><span class="toc-number">1.1.4.</span> <span class="toc-text">接口的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建对象的几种方式"><span class="toc-number">1.1.5.</span> <span class="toc-text">创建对象的几种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk源码相关（不包含多线程和集合）"><span class="toc-number">1.2.</span> <span class="toc-text">jdk源码相关（不包含多线程和集合）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int-Integer的区别："><span class="toc-number">1.2.1.</span> <span class="toc-text">int Integer的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i与i-仅是“先加”与“后加”的差别吗？"><span class="toc-number">1.2.2.</span> <span class="toc-text">++i与i++仅是“先加”与“后加”的差别吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个对象值相同-x-equals-y-true-，但却可有不同的hashCode，这句话对不对？"><span class="toc-number">1.2.3.</span> <span class="toc-text">两个对象值相同(x.equals(y) == true)，但却可有不同的hashCode，这句话对不对？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本for循环与加强型for循环的差别"><span class="toc-number">1.2.4.</span> <span class="toc-text">基本for循环与加强型for循环的差别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><span class="toc-number">1.2.5.</span> <span class="toc-text">Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中如何实现序列化，有什么意义？"><span class="toc-number">1.2.6.</span> <span class="toc-text">Java中如何实现序列化，有什么意义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获得一个类的类对象有哪些方式？"><span class="toc-number">1.2.7.</span> <span class="toc-text">获得一个类的类对象有哪些方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何通过反射创建对象？"><span class="toc-number">1.2.8.</span> <span class="toc-text">如何通过反射创建对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何通过反射调用对象的方法？"><span class="toc-number">1.2.9.</span> <span class="toc-text">如何通过反射调用对象的方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中如何实现序列化，有什么意义？-1"><span class="toc-number">1.2.10.</span> <span class="toc-text">Java中如何实现序列化，有什么意义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个Integer的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？"><span class="toc-number">1.2.11.</span> <span class="toc-text">两个Integer的引用对象传给一个swap方法内部进行交换，返回后，两个引用的值是否发生变化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-中-IO-流分为几种"><span class="toc-number">1.2.12.</span> <span class="toc-text">java 中 IO 流分为几种?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO-NIO-AIO-有什么区别"><span class="toc-number">1.2.13.</span> <span class="toc-text">BIO,NIO,AIO 有什么区别?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合"><span class="toc-number">1.3.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List、Set、Map是否继承自Collection接口？"><span class="toc-number">1.3.1.</span> <span class="toc-text">List、Set、Map是否继承自Collection接口？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程"><span class="toc-number">1.4.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？"><span class="toc-number">1.4.1.</span> <span class="toc-text">Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized关键字的用法？"><span class="toc-number">1.4.2.</span> <span class="toc-text">synchronized关键字的用法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的基本状态以及状态之间的关系？"><span class="toc-number">1.4.3.</span> <span class="toc-text">线程的基本状态以及状态之间的关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简述synchronized-和java-util-concurrent-locks-Lock的异同？"><span class="toc-number">1.4.4.</span> <span class="toc-text">简述synchronized 和java.util.concurrent.locks.Lock的异同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何控制线程的执行顺序？"><span class="toc-number">1.4.5.</span> <span class="toc-text">如何控制线程的执行顺序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java中的Volatile和synchronized的差异？"><span class="toc-number">1.4.6.</span> <span class="toc-text">java中的Volatile和synchronized的差异？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Callable和Future"><span class="toc-number">1.4.7.</span> <span class="toc-text">什么是Callable和Future?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么使用Executor框架比使用应用创建和管理线程好？"><span class="toc-number">1.4.8.</span> <span class="toc-text">为什么使用Executor框架比使用应用创建和管理线程好？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><span class="toc-number">1.4.9.</span> <span class="toc-text">乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java线程池中submit-和-execute-方法有什么区别？"><span class="toc-number">1.4.10.</span> <span class="toc-text">Java线程池中submit() 和 execute()方法有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池执行流程"><span class="toc-number">1.4.11.</span> <span class="toc-text">线程池执行流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM"><span class="toc-number">1.5.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM体系结构"><span class="toc-number">1.5.1.</span> <span class="toc-text">JVM体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何识别垃圾，判定对象是否可被回收？"><span class="toc-number">1.5.2.</span> <span class="toc-text">如何识别垃圾，判定对象是否可被回收？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-中的堆是-GC-收集垃圾的主要区域"><span class="toc-number">1.5.3.</span> <span class="toc-text">Java 中的堆是 GC 收集垃圾的主要区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC算法"><span class="toc-number">1.5.4.</span> <span class="toc-text">GC算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">按照回收策略划分为：标记-清除算法，标记-整理算法，复制算法。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#按分区对待可分为：增量收集算法，分代收集算法"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">按分区对待可分为：增量收集算法，分代收集算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#系统线程可分为：串行收集算法，并行收集算法，并发收集算法"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">系统线程可分为：串行收集算法，并行收集算法，并发收集算法**</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制"><span class="toc-number">1.5.5.</span> <span class="toc-text">Java代码编译和执行的整个过程包含了以下三个重要的机制：Java源码编译机制、类加载机制、类执行机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java与数据库"><span class="toc-number">1.6.</span> <span class="toc-text">Java与数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#阐述JDBC操作数据库的步骤"><span class="toc-number">1.6.1.</span> <span class="toc-text">阐述JDBC操作数据库的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在进行数据库编程时，连接池有什么作用？"><span class="toc-number">1.6.2.</span> <span class="toc-text">在进行数据库编程时，连接池有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDBC中如何进行事务处理？"><span class="toc-number">1.6.3.</span> <span class="toc-text">JDBC中如何进行事务处理？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#J2EE"><span class="toc-number">2.</span> <span class="toc-text">J2EE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#servlet"><span class="toc-number">2.1.</span> <span class="toc-text">servlet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet的优点"><span class="toc-number">2.1.1.</span> <span class="toc-text">Servlet的优点:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet接口中有哪些方法及Servlet生命周期探秘"><span class="toc-number">2.1.2.</span> <span class="toc-text">Servlet接口中有哪些方法及Servlet生命周期探秘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsp"><span class="toc-number">2.2.</span> <span class="toc-text">jsp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSP有哪些内置对象、作用分别是什么"><span class="toc-number">2.2.1.</span> <span class="toc-text">JSP有哪些内置对象、作用分别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Request对象的主要方法有哪些"><span class="toc-number">2.2.2.</span> <span class="toc-text">Request对象的主要方法有哪些</span></a></li></ol></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>






    
        <section id="comments">
<link rel="stylesheet" href="/css/gitment.min.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: '面试之---java基础相关', // 可选。默认为 location.href
  owner: 'ZhaoGitHub1',
  repo: 'ZhaoGitHub1.github.io',
  oauth: {
    client_id: '0959e9fdfc97cef82968',
    client_secret: '126454836d441306e61dfbf9bb3ddc6cef1bf93d',
  },
})
gitment.render('comments')
</script>
</section>
    



    <div class="scroll" id="post-nav-button">
        
            <a  href="/2018/09/16/interview-db/" title="上一篇: 面试之---数据库相关">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a  href="/2018/09/16/interview-others/" title="下一篇: 面试之---其他细小知识点汇总">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/tool-idea/">IDEA使用总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/12/tool-recommend/">工具推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/spring-data-jpa-summary/">spring-data-jpa使用总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/17/kafka-learn-and-summary/">Kafka学习和总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/10/list-books/">推荐书单整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/01/redis-file-lock/">redis实现分布式文件夹锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/16/read-note-readable-code/">读书笔记---《编写可读代码的艺术》</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/27/hashmap/">HashMap源码阅读</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/28/java-code-optimize/">java代码优化建议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/git-commands/">git常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-tools/">面试之---工具使用相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-db/">面试之---数据库相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-java-basic/">面试之---java基础相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-others/">面试之---其他细小知识点汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-optimize/">面试之---安全与性能优化相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-framework/">面试之---框架相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-algorithm/">面试之---算法相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/15/linux-commands/">linux常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/tree-projects/">项目树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/12/redis-summary/">Redis总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/about-Hexo/">Hexo博客搭建相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/10/pattern-singleton/">设计模式之---单例模式(Singleton Pattern)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/09/list-sites/">常用网站清单</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/my-pictures/">我的画集</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/nginx-config/">【转载】nginx配置文件nginx.conf超详细讲解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/springboot-app-deploy/">SpringBoot项目打包发布Linux环境完整流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/thread-realize/">创建线程的几种方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/pattern-all/">设计模式之---汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/concurrentHashMap-analyze/">【转载】ConcurrentHashMap原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/tree-skills/">技能树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/springApplication-analyze/">SpringBoot源码分析之---SpringBoot项目启动类SpringApplication浅析</a></li></ul>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2019 逸竹
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/ZhaoGitHub1" target="_blank">Blog</a> by 逸竹
            </div>
        </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 8;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?eb7d8cefd581790a3213e8feb93ae89f";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>