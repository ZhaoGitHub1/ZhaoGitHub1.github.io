<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="JF09eNDd2m" />
  
  
  
  
  <title>面试之---框架相关 | 逸竹小站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="包含Spring体系、Hibernate、Mybatis、Zookeeper、Netty等java相关框架面试知识">
<meta name="keywords" content="总结,框架">
<meta property="og:type" content="article">
<meta property="og:title" content="面试之---框架相关">
<meta property="og:url" content="http://yizhuxiaozhan.site/2018/09/16/interview-framework/index.html">
<meta property="og:site_name" content="逸竹小站">
<meta property="og:description" content="包含Spring体系、Hibernate、Mybatis、Zookeeper、Netty等java相关框架面试知识">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-framework/interview.png">
<meta property="og:updated_time" content="2019-07-15T14:01:47.490Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试之---框架相关">
<meta name="twitter:description" content="包含Spring体系、Hibernate、Mybatis、Zookeeper、Netty等java相关框架面试知识">
<meta name="twitter:image" content="http://yizhuxiaozhan.site/2018/09/16/interview-framework/interview.png">
  
    <link rel="alternative" href="/atom.xml" title="逸竹小站" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/logo.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">逸竹</a></h1>
        </hgroup>
        
        <p class="header-subtitle">未来不迎，当时不杂，过往不恋！</p>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/tags/">分类&amp;标签</a></li>
                        
                            <li><a  href="/books/">我的读书</a></li>
                        
                            <li><a  href="/movies/">我的电影</a></li>
                        
                            <li><a  href="/categories/tree/">树</a></li>
                        
                            <li><a  href="/categories/interview/">面试</a></li>
                        
                            <li><a  href="/categories/lists/">清单</a></li>
                        
                            <li><a  href="/aboutme/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="https://github.com/ZhaoGitHub1/" title="github">github</a>
                            
                                <a class="fl douban"  target="_blank" href="https://www.douban.com/people/174692469/" title="douban">douban</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/ConcurrentHashMap/" style="font-size: 10px;">ConcurrentHashMap</a> <a href="/tags/SpringData/" style="font-size: 10px;">SpringData</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hashmap/" style="font-size: 10px;">hashmap</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java基础/" style="font-size: 10px;">java基础</a> <a href="/tags/kafka/" style="font-size: 10px;">kafka</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/linux命令/" style="font-size: 10px;">linux命令</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/orm/" style="font-size: 10px;">orm</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/springboot/" style="font-size: 13.33px;">springboot</a> <a href="/tags/springboot源码分析/" style="font-size: 10px;">springboot源码分析</a> <a href="/tags/优化/" style="font-size: 10px;">优化</a> <a href="/tags/分布式锁/" style="font-size: 10px;">分布式锁</a> <a href="/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/tags/命令/" style="font-size: 10px;">命令</a> <a href="/tags/在线工具/" style="font-size: 10px;">在线工具</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/工具/" style="font-size: 16.67px;">工具</a> <a href="/tags/性能/" style="font-size: 10px;">性能</a> <a href="/tags/总结/" style="font-size: 20px;">总结</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/素描/" style="font-size: 10px;">素描</a> <a href="/tags/编码艺术/" style="font-size: 10px;">编码艺术</a> <a href="/tags/网站地址/" style="font-size: 10px;">网站地址</a> <a href="/tags/读书/" style="font-size: 13.33px;">读书</a> <a href="/tags/转载/" style="font-size: 13.33px;">转载</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://blog.csdn.net/qq_25885525">我的csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://github.com/ZhaoGitHub1">我的github</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://gitee.com/zhao-183479916">我的gitee</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://spring.io/">Spring官网</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.mybatis.org/mybatis-3/zh/index.html">Mybatis官网</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://hibernate.org/">Hibernate官网</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">一名普通的java 后台开发工程师~~  邮箱：183479916@qq.com</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">逸竹</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/logo.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">逸竹</a></h1>
            </hgroup>
            
            <p class="header-subtitle">未来不迎，当时不杂，过往不恋！</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">分类&amp;标签</a></li>
                
                    <li><a href="/books/">我的读书</a></li>
                
                    <li><a href="/movies/">我的电影</a></li>
                
                    <li><a href="/categories/tree/">树</a></li>
                
                    <li><a href="/categories/interview/">面试</a></li>
                
                    <li><a href="/categories/lists/">清单</a></li>
                
                    <li><a href="/aboutme/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/ZhaoGitHub1/" title="github">github</a>
                    
                        <a class="douban" target="_blank" href="https://www.douban.com/people/174692469/" title="douban">douban</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-interview-framework" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2018/09/16/interview-framework/" class="article-date">
      <time datetime="2018-09-16T13:06:51.000Z" itemprop="datePublished">2018-09-16</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面试之---框架相关
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/interview/">interview</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/框架/">框架</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong> 面试之---框架相关：</strong> <excerpt in="" index="" |="" 首页摘要=""></excerpt></p>
<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">

<p><img src="/2018/09/16/interview-framework/interview.png" alt=""></p>
<blockquote>
<p>持续维护java面试题系列博文，发现好的面试题会更新进来。总结的并不只是如何回答面试官，而是这道题涉及到的知识点，明白了相关知识点和面试官要问的点，回答起来就不是问题了。</p>
</blockquote>
<h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><h3 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h3><p>对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</p>
<h3 id="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？"><a href="#持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？" class="headerlink" title="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？"></a>持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？</h3><p>所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。</p>
<p>持久层设计的目标包括： </p>
<ul>
<li>数据存储逻辑的分离，提供抽象化的数据访问接口。 </li>
<li>数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。 </li>
<li>资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。 </li>
<li>数据抽象，提供更面向对象的数据操作。</li>
</ul>
<p>持久层框架有： <a href="http://hibernate.org" target="_blank" rel="noopener">Hibernate</a> 、<a href="http://blog.mybatis.org" target="_blank" rel="noopener">MyBatis</a> 、<a href="http://projects.spring.io/spring-data/" target="_blank" rel="noopener">Spring Data</a> 、<a href="http://www.oracle.com/technetwork/cn/middleware/toplink/overview/index.html" target="_blank" rel="noopener">TopLink</a> 、<a href="https://code.google.com/p/guzz/" target="_blank" rel="noopener">Guzz</a> 、<a href="http://www.jooq.org" target="_blank" rel="noopener">jOOQ</a> 、<a href="https://code.google.com/p/activejdbc/" target="_blank" rel="noopener">ActiveJDBC</a></p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h3><h4 id="Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="Spring Framework 中有多少个模块，它们分别是什么？"></a>Spring Framework 中有多少个模块，它们分别是什么？</h4><h4 id="什么是IoC和DI？DI是如何实现的？"><a href="#什么是IoC和DI？DI是如何实现的？" class="headerlink" title="什么是IoC和DI？DI是如何实现的？"></a>什么是IoC和DI？DI是如何实现的？</h4><p><code>IoC</code>叫控制反转，是Inversion of Control的缩写，<code>DI</code>（Dependency Injection）叫依赖注入，是对<code>IoC</code>更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。<code>IoC</code>体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。<code>DI</code>是对<code>IoC</code>更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p>
<p>举个例子：一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。</p>
<p>依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p>
<h4 id="Spring中Bean的作用域有哪些？"><a href="#Spring中Bean的作用域有哪些？" class="headerlink" title="Spring中Bean的作用域有哪些？"></a>Spring中Bean的作用域有哪些？</h4><p>在Spring的早期版本中，仅有两个作用域：<code>singleton</code>和<code>prototype</code>，前者表示Bean以单例的方式存在；后者表示每次从容器中调用Bean时，都会返回一个新的实例，<code>prototype</code>通常翻译为原型。</p>
<blockquote>
<p><strong>补充：</strong>设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。</p>
</blockquote>
<p>Spring 2.x中针对<code>WebApplicationContext</code>新增了3个作用域，分别是：<code>request</code>（每次HTTP请求都会创建一个新的Bean）、<code>session</code>（同一个<code>HttpSession</code>共享同一个Bean，不同的<code>HttpSession</code>使用不同的Bean）和<code>globalSession</code>（同一个全局Session共享一个Bean）。</p>
<blockquote>
<p><strong>说明：</strong>单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有<code>Connection</code>这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的<code>ThreadLocal</code>对非线程安全的对象进行了特殊处理。<br><code>ThreadLocal</code>为解决多线程程序的并发问题提供了一种新的思路。<code>ThreadLocal</code>，顾名思义是线程的一个本地化对象，当工作于多线程中的对象使用<code>ThreadLocal</code>维护变量时，<code>ThreadLocal</code>为每个使用该变量的线程分配一个独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不影响其他线程所对应的副本。从线程的角度看，这个变量就像是线程的本地变量。</p>
</blockquote>
<p><code>ThreadLocal</code>类非常简单好用，只有四个方法，能用上的也就是下面三个方法： </p>
<ul>
<li><code>void set(T value)</code>：设置当前线程的线程局部变量的值。 </li>
<li><code>T get()</code>：获得当前线程所对应的线程局部变量的值。 </li>
<li><code>void remove()</code>：删除当前线程中线程局部变量的值。</li>
</ul>
<p><code>ThreadLocal</code>是如何做到为每一个线程维护一份独立的变量副本的呢？在<code>ThreadLocal</code>类中有一个Map，键为线程对象，值是其线程对应的变量的副本，自己要模拟实现一个<code>ThreadLocal</code>类其实并不困难，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Thread, T&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Thread, T&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T newValue)</span> </span>&#123;</span><br><span class="line">        map.put(Thread.currentThread(), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.remove(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分析<code>ThreadLocal</code>源码的文章：<a href="https://www.jianshu.com/p/98b68c97df9b" target="_blank" rel="noopener">https://www.jianshu.com/p/98b68c97df9b</a></p>
</blockquote>
<h4 id="Spring中自动装配的方式有哪些？"><a href="#Spring中自动装配的方式有哪些？" class="headerlink" title="Spring中自动装配的方式有哪些？"></a>Spring中自动装配的方式有哪些？</h4><ol>
<li>no：不进行自动装配，手动设置Bean的依赖关系。 </li>
<li>byName：根据Bean的名字进行自动装配。 </li>
<li>byType：根据Bean的类型进行自动装配。 </li>
<li>constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。 </li>
<li>autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。</li>
</ol>
<blockquote>
<p><strong>说明：</strong>自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。</p>
</blockquote>
<p>基于注解的方式：</p>
<p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，。在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>
<p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p>
<p>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p>
<p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</p>
<p>@Autowired可用于：构造函数、成员变量、Setter方法</p>
<blockquote>
<p>注：@Autowired和@Resource之间的区别</p>
</blockquote>
<p>(1) @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p>
<p>(2) @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p>
<h4 id="构造器注入的好处"><a href="#构造器注入的好处" class="headerlink" title="构造器注入的好处"></a>构造器注入的好处</h4><ul>
<li>保证依赖不可变（final关键字）</li>
<li>保证依赖不为空（省去了我们对其检查）</li>
<li>保证返回客户端（调用）的代码的时候是完全初始化的状态</li>
<li>避免了循环依赖</li>
<li>提升了代码的可复用性</li>
</ul>
<p>当有一个依赖有多个实现的使用，推荐使用field注入或者setter注入的方式来指定注入的类型</p>
<h4 id="Spring中如何使用注解来配置Bean？有哪些相关的注解？"><a href="#Spring中如何使用注解来配置Bean？有哪些相关的注解？" class="headerlink" title="Spring中如何使用注解来配置Bean？有哪些相关的注解？"></a>Spring中如何使用注解来配置Bean？有哪些相关的注解？</h4><p>首先需要在Spring配置文件中增加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后可以用<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>注解来标注需要由Spring IoC容器进行对象托管的类。这几个注解没有本质区别，只不过<code>@Controller</code>通常用于控制器，<code>@Service</code>通常用于业务逻辑类，<code>@Repository</code>通常用于仓储类（例如我们的DAO实现类），普通的类用<code>@Component</code>来标注。</p>
<h4 id="选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？"><a href="#选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？" class="headerlink" title="选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？"></a>选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？</h4><p>可以从以下几个方面作答：  </p>
<ul>
<li>非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。</li>
<li><code>IoC</code>容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神”不要重复的发明轮子”。</li>
<li><code>AOP</code>（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。</li>
<li>MVC：Spring的MVC框架是非常优秀的，从各个方面都可以甩Struts 2几条街，为Web表示层提供了更好的解决方案。</li>
<li>事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。  - 其他：选择Spring框架的原因还远不止于此，Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，你甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。</li>
</ul>
<h4 id="阐述Spring框架中Bean的生命周期？"><a href="#阐述Spring框架中Bean的生命周期？" class="headerlink" title="阐述Spring框架中Bean的生命周期？"></a>阐述Spring框架中Bean的生命周期？</h4><ol>
<li>Spring IoC容器找到关于Bean的定义并实例化该Bean。</li>
<li>Spring IoC容器对Bean进行依赖注入。</li>
<li>如果Bean实现了<code>BeanNameAware</code>接口，则将该Bean的id传给<code>setBeanName</code>方法。</li>
<li>如果Bean实现了<code>BeanFactoryAware</code>接口，则将<code>BeanFactory</code>对象传给<code>setBeanFactory</code>方法。</li>
<li>如果Bean实现了<code>BeanPostProcessor</code>接口，则调用其<code>postProcessBeforeInitialization()</code>方法。</li>
<li>如果Bean实现了<code>InitializingBean</code>接口，则调用其<code>afterPropertySet</code>方法。</li>
<li>如果有和Bean关联的<code>BeanPostProcessors</code>对象，则这些对象的<code>postProcessAfterInitialization</code>方法被调用。</li>
<li>当销毁Bean实例时，如果Bean实现了<code>DisposableBean</code>接口，则调用其<code>destroy</code>方法。</li>
</ol>
<h4 id="BeanFactory和FactoryBean的区别？"><a href="#BeanFactory和FactoryBean的区别？" class="headerlink" title="BeanFactory和FactoryBean的区别？"></a>BeanFactory和FactoryBean的区别？</h4><h4 id="解释一下什么叫AOP（面向切面编程）？"><a href="#解释一下什么叫AOP（面向切面编程）？" class="headerlink" title="解释一下什么叫AOP（面向切面编程）？"></a>解释一下什么叫AOP（面向切面编程）？</h4><p><code>AOP</code>（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。</p>
<h4 id="你是如何理解”横切关注”这个概念的？"><a href="#你是如何理解”横切关注”这个概念的？" class="headerlink" title="你是如何理解”横切关注”这个概念的？"></a>你是如何理解”横切关注”这个概念的？</h4><p>“横切关注”是会影响到整个应用程序的关注功能，它跟正常的业务逻辑是正交的，没有必然的联系，但是几乎所有的业务逻辑都会涉及到这些关注功能。通常，事务、日志、安全性等关注就是应用中的横切关注功能。</p>
<h4 id="你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"><a href="#你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？" class="headerlink" title="你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"></a>你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？</h4><ul>
<li><p>连接点（<code>Joinpoint</code>）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。 </p>
</li>
<li><p>切点（<code>Pointcut</code>）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。 </p>
</li>
<li><p>增强（<code>Advice</code>）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：<code>BeforeAdvice</code>、<code>AfterReturningAdvice</code>、<code>ThrowsAdvice</code>等。很多资料上将增强译为“通知”，这明显是个词不达意的翻译，让很多程序员困惑了许久。</p>
<blockquote>
<p><strong>说明：</strong> <code>Advice</code>在国内的很多书面资料中都被翻译成”通知”，但是很显然这个翻译无法表达其本质，有少量的读物上将这个词翻译为”增强”，这个翻译是对<code>Advice</code>较为准确的诠释，我们通过<code>AOP</code>将横切关注功能加到原有的业务逻辑上，这就是对原有业务逻辑的一种增强，这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强。</p>
</blockquote>
</li>
<li><p>引介（<code>Introduction</code>）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的未该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。 </p>
</li>
<li><p>织入（<code>Weaving</code>）：织入是将增强添加到目标类具体连接点上的过程，<code>AOP</code>有三种织入方式：</p>
<ul>
<li>编译期织入：需要特殊的Java编译期（例如<code>AspectJ</code>的ajc）；</li>
<li>装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；</li>
<li>运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。 </li>
</ul>
</li>
<li><p>切面（<code>Aspect</code>）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。</p>
<blockquote>
<p><strong>补充：</strong>代理模式是GoF提出的23种设计模式中最为经典的模式之一，代理模式是对象的结构模式，它给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。简单的说，代理对象可以完成比原对象更多的职责，当需要为原对象添加横切关注功能时，就可以使用原对象的代理对象。我们在打开Office系列的Word文档时，如果文档中有插图，当文档刚加载时，文档中的插图都只是一个虚框占位符，等用户真正翻到某页要查看该图片时，才会真正加载这张图，这其实就是对代理模式的使用，代替真正图片的虚框就是一个虚拟代理；Hibernate的load方法也是返回一个虚拟代理对象，等用户真正需要访问对象的属性时，才向数据库发出SQL语句获得真实对象。</p>
</blockquote>
</li>
</ul>
<h4 id="Spring的AOP理解"><a href="#Spring的AOP理解" class="headerlink" title="Spring的AOP理解"></a>Spring的AOP理解</h4><p>OOP面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</p>
<p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>
<p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p>
<ul>
<li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象。</li>
<li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li>
</ul>
<p>（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<p>InvocationHandler 的 invoke(Object  proxy,Method  method,Object[] args)：proxy是最终生成的代理实例;  method 是被代理目标实例的某个具体方法;  args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p>
<h4 id="Spring事务的实现方式和实现原理"><a href="#Spring事务的实现方式和实现原理" class="headerlink" title="Spring事务的实现方式和实现原理"></a>Spring事务的实现方式和实现原理</h4><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p>
<ul>
<li>Spring事务的种类：spring支持编程式事务管理和声明式事务管理两种方式<ul>
<li>编程式事务管理使用TransactionTemplate。</li>
<li>声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式，使业务代码不受污染，只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</li>
</ul>
</li>
<li><p>spring的事务传播行为：spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p>
<ul>
<li><code>PROPAGATION_REQUIRED</code>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</li>
<li><code>PROPAGATION_SUPPORTS</code>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li>
<li><code>PROPAGATION_MANDATORY</code>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li>
<li><code>PROPAGATION_REQUIRES_NEW</code>：创建新事务，无论当前存不存在事务，都创建新事务。</li>
<li><code>PROPAGATION_NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li><code>PROPAGATION_NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li><code>PROPAGATION_NESTED</code>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</li>
</ul>
</li>
<li><p>Spring中的隔离级别：</p>
<ul>
<li><code>ISOLATION_DEFAULT</code>：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。</li>
<li><code>ISOLATION_READ_UNCOMMITTED</code>：读未提交，允许另外一个事务可以看到这个事务未提交的数据。</li>
<li><code>ISOLATION_READ_COMMITTED</code>：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。</li>
<li><code>ISOLATION_REPEATABLE_READ</code>：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。</li>
<li><code>ISOLATION_SERIALIZABLE</code>：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。</li>
</ul>
</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="Spring-MVC的工作原理是怎样的？"><a href="#Spring-MVC的工作原理是怎样的？" class="headerlink" title="Spring MVC的工作原理是怎样的？"></a>Spring MVC的工作原理是怎样的？</h4><ol>
<li>客户端的所有请求都交给前端控制器<code>DispatcherServlet</code>来处理，它会负责调用系统的其他模块来真正处理用户的请求。</li>
<li><code>DispatcherServlet</code>收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及<code>HandlerMapping</code>的配置找到处理该请求的<code>Handler</code>（任何一个对象都可以作为请求的Handler）。  </li>
<li>在这个地方Spring会通过<code>HandlerAdapter</code>对该处理器进行封装。</li>
<li><code>HandlerAdapter</code>是一个适配器，它用统一的接口对各种<code>Handler</code>中的方法进行调用。</li>
<li>Handler完成对用户请求的处理后，会返回一个<code>ModelAndView</code>对象给<code>DispatcherServlet</code>，<code>ModelAndView</code>顾名思义，包含了数据模型以及相应的视图的信息。`</li>
<li><code>ModelAndView</code>的视图是逻辑视图，<code>DispatcherServlet</code>还要借助<code>ViewResolver</code>完成从逻辑视图到真实视图对象的解析工作。`</li>
<li>当得到真正的视图对象后，<code>DispatcherServlet</code>会利用视图对象对模型数据进行渲染。</li>
<li>客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。</li>
</ol>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><h3 id="spring-boot-data-jpa"><a href="#spring-boot-data-jpa" class="headerlink" title="spring-boot-data-jpa"></a>spring-boot-data-jpa</h3><h4 id="Difference-between-save-and-saveAndFlush-in-Spring-data-jpa"><a href="#Difference-between-save-and-saveAndFlush-in-Spring-data-jpa" class="headerlink" title="Difference between save and saveAndFlush in Spring data jpa"></a>Difference between save and saveAndFlush in Spring data jpa</h4><p>On <code>saveAndFlush</code>, changes will be flushed to DB immediately in this command. With <code>save</code>, this is not necessarily true, and might stay just in memory, until <code>flush</code> or <code>commit</code> commands are issued.</p>
<p>But be aware, that even if you flush the changes in transaction and do not commit them, the changes still won’t be visible to the outside transactions until the commit in this transaction.</p>
<p>In your case, you probably use some sort of transactions mechanism, which issues <code>commit</code>command for you if everything works out fine.</p>
<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><h3 id="Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？"><a href="#Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？" class="headerlink" title="Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？"></a>Hibernate中<code>SessionFactory</code>是线程安全的吗？<code>Session</code>是线程安全的吗（两个线程能够共享同一个Session吗）？</h3><p><code>SessionFactory</code>对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。<code>SessionFactory</code>一般只会在启动的时候构建。对于应用程序，最好将<code>SessionFactory</code>通过单例模式进行封装以便于访问。<code>Session</code>是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。<code>Session</code>是由<code>SessionFactory</code>创建的，在任务完成之后它会被关闭。<code>Session</code>是持久层服务对外提供的主要接口。<code>Session</code>会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用<code>ThreadLocal</code>将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中<code>SessionFactory</code>的<code>getCurrentSession()</code>方法就可以做到。</p>
<h3 id="Hibernate中Session的load和get方法的区别是什么？"><a href="#Hibernate中Session的load和get方法的区别是什么？" class="headerlink" title="Hibernate中Session的load和get方法的区别是什么？"></a>Hibernate中Session的load和get方法的区别是什么？</h3><p>主要有以下三项区别： </p>
<ul>
<li>如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。 </li>
<li>get方法直接返回实体类对象，load方法返回实体类对象的代理。 </li>
<li>在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。</li>
</ul>
<blockquote>
<p><strong>说明：</strong>对于<code>load()</code>方法Hibernate认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过<code>get()</code>方法获取的数据可以不存在。</p>
</blockquote>
<h3 id="Session的save-、update-、merge-、lock-、saveOrUpdate-和persist-方法分别是做什么的？有什么区别？"><a href="#Session的save-、update-、merge-、lock-、saveOrUpdate-和persist-方法分别是做什么的？有什么区别？" class="headerlink" title="Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？"></a>Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？</h3><p>Hibernate的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态（detached），瞬时态的实例可以通过调用<code>save()</code>、<code>persist()</code>或者<code>saveOrUpdate()</code>方法变成持久态；游离态的实例可以通过调用 <code>update()</code>、<code>saveOrUpdate()</code>、<code>lock()</code>或者<code>replicate()</code>变成持久态。<code>save()</code>和<code>persist()</code>将会引发SQL的<code>INSERT</code>语句，而<code>update()</code>或<code>merge()</code>会引发<code>UPDATE</code>语句。<code>save()</code>和<code>update()</code>的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。<code>merge()</code>方法可以完成<code>save()</code>和<code>update()</code>方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于<code>persist()</code>方法，按照官方文档的说明：</p>
<ul>
<li><code>persist()</code>方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；</li>
<li><code>persist()</code>方法保证当它在一个事务外部被调用的时候并不触发一个<code>INSERT</code>语句，当需要封装一个长会话流程的时候，<code>persist()</code>方法是很有必要的；</li>
<li><code>save()</code>方法不保证第二条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。</li>
</ul>
<p>至于<code>lock()</code>方法和<code>update()</code>方法的区别，<code>update()</code>方法是把一个已经更改过的脱管状态的对象变成持久状态；<code>lock()</code>方法是把一个没有更改过的脱管状态的对象变成持久状态。</p>
<h3 id="阐述Session加载实体对象的过程"><a href="#阐述Session加载实体对象的过程" class="headerlink" title="阐述Session加载实体对象的过程"></a>阐述Session加载实体对象的过程</h3><p><code>Session</code>加载实体对象的步骤是： </p>
<ul>
<li><code>Session</code>在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回； </li>
<li>如果一级缓存没有命中，接下来<code>Session</code>会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null； </li>
<li>如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回；</li>
<li>如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null； </li>
<li>根据映射配置和SQL语句得到<code>ResultSet</code>，并创建对应的实体对象；</li>
<li>将对象纳入<code>Session</code>（一级缓存）的管理；</li>
<li>如果有对应的拦截器，则执行拦截器的onLoad方法；</li>
<li>如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存；</li>
<li>返回数据对象。</li>
</ul>
<h3 id="锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。"><a href="#锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。" class="headerlink" title="锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。"></a>锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。</h3><p>有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。<br>Hibernate支持悲观锁和乐观锁两种锁机制。</p>
<ul>
<li>悲观锁，顾名思义悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。<code>悲观锁</code>必须依赖数据库本身的锁机制才能真正保证数据访问的排他性。</li>
<li>乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加1，然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的当前版本号则更新数据，否则认为是过期数据无法更新。</li>
</ul>
<p>Hibernate中通过<code>Session</code>的<code>get()</code>和<code>load()</code>方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过XML或<code>@Version</code>注解进行配置。</p>
<blockquote>
<p><strong>提示：</strong>使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间换时间的策略。</p>
</blockquote>
<h3 id="如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？"><a href="#如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？" class="headerlink" title="如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？"></a>如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？</h3><p>延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用Session的<code>load()</code>方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。</p>
<p>延迟加载与session关闭的矛盾一般可以这样处理： </p>
<ul>
<li>关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现”no session or session was closed”通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。 </li>
<li>在session关闭之前先获取需要查询的数据，可以使用工具方法<code>Hibernate.isInitialized()</code>判断对象是否被加载，如果没有被加载则可以使用Hibernate.initialize()方法加载对象。 </li>
<li>使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的<code>OpenSessionInViewFilter</code>和<code>OpenSessionInViewInterceptor</code>就是这种做法。</li>
</ul>
<h3 id="简述Hibernate常见优化策略。"><a href="#简述Hibernate常见优化策略。" class="headerlink" title="简述Hibernate常见优化策略。"></a>简述Hibernate常见优化策略。</h3><p>这个问题应当挑自己使用过的优化策略回答，常用的有：  </p>
<ul>
<li>制定合理的缓存策略（二级缓存、查询缓存）。  </li>
<li>采用合理的Session管理机制。 </li>
<li>尽量使用延迟加载特性。</li>
<li>设定合理的批处理参数。</li>
<li>如果可以，选用UUID作为主键生成器。</li>
<li>如果可以，选用基于版本号的乐观锁替代悲观锁。</li>
<li>在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。</li>
<li>考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。</li>
</ul>
<h3 id="谈一谈Hibernate的一级缓存、二级缓存和查询缓存。"><a href="#谈一谈Hibernate的一级缓存、二级缓存和查询缓存。" class="headerlink" title="谈一谈Hibernate的一级缓存、二级缓存和查询缓存。"></a>谈一谈Hibernate的一级缓存、二级缓存和查询缓存。</h3><p>Hibernate的<code>Session</code>提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实体、修改持久化实体时，<code>Session</code>并不会立即把这种改变提交到数据库，而是缓存在当前的<code>Session</code>中，除非显示调用了<code>Session</code>的<code>flush()</code>方法或通过<code>close()</code>方法关闭<code>Session</code>。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。  <code>SessionFactory</code>级别的二级缓存是全局性的，所有的<code>Session</code>可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，<code>SessionFactory</code>就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。  一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将<code>HQL</code>或<code>SQL</code>语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。</p>
<h3 id="Hibernate中DetachedCriteria类是做什么的？"><a href="#Hibernate中DetachedCriteria类是做什么的？" class="headerlink" title="Hibernate中DetachedCriteria类是做什么的？"></a>Hibernate中DetachedCriteria类是做什么的？</h3><p><code>DetachedCriteria</code>和<code>Criteria</code>的用法基本上是一致的，但<code>Criteria</code>是由<code>Session</code>的<code>createCriteria()</code>方法创建的，也就意味着离开创建它的<code>Session</code>，<code>Criteria</code>就无法使用了。<code>DetachedCriteria</code>不需要<code>Session</code>就可以创建（使用<code>DetachedCriteria.forClass()</code>方法创建），所以通常也称其为离线的<code>Criteria</code>，在需要进行查询操作的时候再和<code>Session</code>绑定（调用其<code>getExecutableCriteria(Session)</code>方法），这也就意味着一个<code>DetachedCriteria</code>可以在需要的时候和不同的<code>Session</code>进行绑定。</p>
<h3 id="OneToMany注解的mappedBy属性有什么作用？"><a href="#OneToMany注解的mappedBy属性有什么作用？" class="headerlink" title="@OneToMany注解的mappedBy属性有什么作用？"></a>@OneToMany注解的mappedBy属性有什么作用？</h3><p><code>@OneToMany</code>用来配置一对多关联映射，但通常情况下，一对多关联映射都由多的一方来维护关联关系，例如学生和班级，应该在学生类中添加班级属性来维持学生和班级的关联关系（在数据库中是由学生表中的外键班级编号来维护学生表和班级表的多对一关系），如果要使用双向关联，在班级类中添加一个容器属性来存放学生，并使用<code>@OneToMany</code>注解进行映射，此时mappedBy属性就非常重要。如果使用XML进行配置，可以用<set>标签的<code>inverse=&quot;true&quot;</code>设置来达到同样的效果。</set></p>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="MyBatis中使用-和-书写占位符有什么区别？"><a href="#MyBatis中使用-和-书写占位符有什么区别？" class="headerlink" title="MyBatis中使用#和$书写占位符有什么区别？"></a>MyBatis中使用#和$书写占位符有什么区别？</h3><p><code>#</code>将传入的数据都当成一个字符串，会对传入的数据自动加上引号；<code>$</code>将传入的数据直接显示生成在SQL中。注意：使用<code>$</code>占位符可能会导致SQL注射攻击，能用<code>#</code>的地方就不要使用<code>$</code>，写<code>order by</code>子句的时候应该用<code>$</code>而不是<code>#</code>。</p>
<h3 id="解释一下MyBatis中命名空间（namespace）的作用。"><a href="#解释一下MyBatis中命名空间（namespace）的作用。" class="headerlink" title="解释一下MyBatis中命名空间（namespace）的作用。"></a>解释一下MyBatis中命名空间（namespace）的作用。</h3><p>在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。</p>
<h3 id="MyBatis中的动态SQL是什么意思？"><a href="#MyBatis中的动态SQL是什么意思？" class="headerlink" title="MyBatis中的动态SQL是什么意思？"></a>MyBatis中的动态SQL是什么意思？</h3><p>对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，例如在58同城上面找房子，我们可能会指定面积、楼层和所在位置来查找房源，也可能会指定面积、价格、户型和所在位置来查找房源，此时就需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句，还好MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有： </p>
<ul>
<li><code>if</code> </li>
<li><code>choose</code> / <code>when</code> / <code>otherwise</code> </li>
<li><code>trim</code> </li>
<li><code>where</code> </li>
<li><code>set</code> </li>
<li><code>foreach</code></li>
</ul>
<p>下面是映射文件的片段。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">parameterType</span>=<span class="string">"Blog"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">     select * from t_blog where 1 = 1</span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">         and title = #&#123;title&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"content != null"</span>&gt;</span></span><br><span class="line">         and content = #&#123;content&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"owner != null"</span>&gt;</span></span><br><span class="line">         and owner = #&#123;owner&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然也可以像下面这些书写。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">parameterType</span>=<span class="string">"Blog"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">    select * from t_blog where 1 = 1 </span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">            and title = #&#123;title&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"content != null"</span>&gt;</span></span><br><span class="line">            and content = #&#123;content&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            and owner = "owner1"</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再看看下面这个例子。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">    select * from t_blog where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"array"</span> <span class="attr">index</span>=<span class="string">"index"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="说一下-mybatis-的一级缓存和二级缓存？"><a href="#说一下-mybatis-的一级缓存和二级缓存？" class="headerlink" title="说一下 mybatis 的一级缓存和二级缓存？"></a>说一下 mybatis 的一级缓存和二级缓存？</h3><p>一级缓存: 基于 <code>PerpetualCache</code> 的 <code>HashMap</code> 本地缓存，其存储作用域为 <code>Session</code>，当 <code>Session</code> flush 或 close 之后，该 <code>Session</code> 中的所有 <code>Cache</code> 就将清空，默认打开一级缓存。</p>
<p>二级缓存与一级缓存其机制相同，默认也是采用 <code>PerpetualCache</code>，<code>HashMap</code> 存储，不同在于其存储作用域为 <code>Mapper(Namespace)</code>，并且可自定义存储源，如 <code>Ehcache</code>。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现<code>Serializable</code>序列化接口(可用来保存对象的状态),可在它的映射文件中配置<code>&lt;cache/&gt;</code> ；</p>
<p>对于缓存数据更新机制，当某一个作用域(一级缓存 <code>Session</code>/二级缓存<code>Namespaces</code>)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h3 id="mybatis和Hibernate的区别有哪些？"><a href="#mybatis和Hibernate的区别有哪些？" class="headerlink" title="mybatis和Hibernate的区别有哪些？"></a>mybatis和Hibernate的区别有哪些？</h3><p>（1）Mybatis和Hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>
<p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是Mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 </p>
<p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用Hibernate开发可以节省很多代码，提高效率。 </p>
<h3 id="Mybatis-有哪些执行器（Executor）？"><a href="#Mybatis-有哪些执行器（Executor）？" class="headerlink" title="Mybatis 有哪些执行器（Executor）？"></a>Mybatis 有哪些执行器（Executor）？</h3><p>Mybatis有三种基本的执行器（Executor）：</p>
<p><code>SimpleExecutor</code>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。<br><code>ReuseExecutor</code>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。<br><code>BatchExecutor</code>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="redis支持的五种结构"><a href="#redis支持的五种结构" class="headerlink" title="redis支持的五种结构"></a>redis支持的五种结构</h3><h3 id="redis通信协议是什么"><a href="#redis通信协议是什么" class="headerlink" title="redis通信协议是什么"></a>redis通信协议是什么</h3><h3 id="redis是如何持久化的"><a href="#redis是如何持久化的" class="headerlink" title="redis是如何持久化的"></a>redis是如何持久化的</h3><h3 id="redis的watch实现原理"><a href="#redis的watch实现原理" class="headerlink" title="redis的watch实现原理"></a>redis的watch实现原理</h3><h3 id="redis是否支持事务"><a href="#redis是否支持事务" class="headerlink" title="redis是否支持事务"></a>redis是否支持事务</h3><h3 id="redis如何实现主从复制"><a href="#redis如何实现主从复制" class="headerlink" title="redis如何实现主从复制"></a>redis如何实现主从复制</h3><h3 id="redis如何实现定制过期删除"><a href="#redis如何实现定制过期删除" class="headerlink" title="redis如何实现定制过期删除"></a>redis如何实现定制过期删除</h3><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h2 id="RibbitMQ"><a href="#RibbitMQ" class="headerlink" title="RibbitMQ"></a>RibbitMQ</h2><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><blockquote>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="noopener">https://blog.csdn.net/jackfrued/article/details/44921941</a></p>
</blockquote>
</the>
      
    </div>
    
  </div>
  
    















    <div class="copyright">
        <p><span>本文标题:</span><a  href="/2018/09/16/interview-framework/">面试之---框架相关</a></p>
        <p><span>文章作者:</span><a  href="/" title="访问 逸竹 的个人博客">逸竹</a></p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/09/16/interview-framework/" title="面试之---框架相关">http://yizhuxiaozhan.site/2018/09/16/interview-framework/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yizhuxiaozhan.site/2018/09/16/interview-framework/　　作者: 逸竹" title=""></span>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a  href="/2018/09/27/git-commands/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          git常用命令
        
      </div>
    </a>
  
  
    <a  href="/2018/09/16/interview-others/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">面试之---其他细小知识点汇总</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#综合"><span class="toc-number">1.</span> <span class="toc-text">综合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是ORM？"><span class="toc-number">1.1.</span> <span class="toc-text">什么是ORM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？"><span class="toc-number">1.2.</span> <span class="toc-text">持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-number">2.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Framework"><span class="toc-number">2.1.</span> <span class="toc-text">Spring Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Framework-中有多少个模块，它们分别是什么？"><span class="toc-number">2.1.1.</span> <span class="toc-text">Spring Framework 中有多少个模块，它们分别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是IoC和DI？DI是如何实现的？"><span class="toc-number">2.1.2.</span> <span class="toc-text">什么是IoC和DI？DI是如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring中Bean的作用域有哪些？"><span class="toc-number">2.1.3.</span> <span class="toc-text">Spring中Bean的作用域有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring中自动装配的方式有哪些？"><span class="toc-number">2.1.4.</span> <span class="toc-text">Spring中自动装配的方式有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造器注入的好处"><span class="toc-number">2.1.5.</span> <span class="toc-text">构造器注入的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring中如何使用注解来配置Bean？有哪些相关的注解？"><span class="toc-number">2.1.6.</span> <span class="toc-text">Spring中如何使用注解来配置Bean？有哪些相关的注解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？"><span class="toc-number">2.1.7.</span> <span class="toc-text">选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阐述Spring框架中Bean的生命周期？"><span class="toc-number">2.1.8.</span> <span class="toc-text">阐述Spring框架中Bean的生命周期？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactory和FactoryBean的区别？"><span class="toc-number">2.1.9.</span> <span class="toc-text">BeanFactory和FactoryBean的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解释一下什么叫AOP（面向切面编程）？"><span class="toc-number">2.1.10.</span> <span class="toc-text">解释一下什么叫AOP（面向切面编程）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#你是如何理解”横切关注”这个概念的？"><span class="toc-number">2.1.11.</span> <span class="toc-text">你是如何理解”横切关注”这个概念的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"><span class="toc-number">2.1.12.</span> <span class="toc-text">你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring的AOP理解"><span class="toc-number">2.1.13.</span> <span class="toc-text">Spring的AOP理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring事务的实现方式和实现原理"><span class="toc-number">2.1.14.</span> <span class="toc-text">Spring事务的实现方式和实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC"><span class="toc-number">2.2.</span> <span class="toc-text">SpringMVC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC的工作原理是怎样的？"><span class="toc-number">2.2.1.</span> <span class="toc-text">Spring MVC的工作原理是怎样的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot"><span class="toc-number">3.</span> <span class="toc-text">Spring Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-boot-data-jpa"><span class="toc-number">3.1.</span> <span class="toc-text">spring-boot-data-jpa</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Difference-between-save-and-saveAndFlush-in-Spring-data-jpa"><span class="toc-number">3.1.1.</span> <span class="toc-text">Difference between save and saveAndFlush in Spring data jpa</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Cloud"><span class="toc-number">4.</span> <span class="toc-text">Spring Cloud</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate"><span class="toc-number">5.</span> <span class="toc-text">Hibernate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？"><span class="toc-number">5.1.</span> <span class="toc-text">Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hibernate中Session的load和get方法的区别是什么？"><span class="toc-number">5.2.</span> <span class="toc-text">Hibernate中Session的load和get方法的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session的save-、update-、merge-、lock-、saveOrUpdate-和persist-方法分别是做什么的？有什么区别？"><span class="toc-number">5.3.</span> <span class="toc-text">Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阐述Session加载实体对象的过程"><span class="toc-number">5.4.</span> <span class="toc-text">阐述Session加载实体对象的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。"><span class="toc-number">5.5.</span> <span class="toc-text">锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？"><span class="toc-number">5.6.</span> <span class="toc-text">如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简述Hibernate常见优化策略。"><span class="toc-number">5.7.</span> <span class="toc-text">简述Hibernate常见优化策略。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈一谈Hibernate的一级缓存、二级缓存和查询缓存。"><span class="toc-number">5.8.</span> <span class="toc-text">谈一谈Hibernate的一级缓存、二级缓存和查询缓存。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hibernate中DetachedCriteria类是做什么的？"><span class="toc-number">5.9.</span> <span class="toc-text">Hibernate中DetachedCriteria类是做什么的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OneToMany注解的mappedBy属性有什么作用？"><span class="toc-number">5.10.</span> <span class="toc-text">@OneToMany注解的mappedBy属性有什么作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis"><span class="toc-number">6.</span> <span class="toc-text">Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis中使用-和-书写占位符有什么区别？"><span class="toc-number">6.1.</span> <span class="toc-text">MyBatis中使用#和$书写占位符有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释一下MyBatis中命名空间（namespace）的作用。"><span class="toc-number">6.2.</span> <span class="toc-text">解释一下MyBatis中命名空间（namespace）的作用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis中的动态SQL是什么意思？"><span class="toc-number">6.3.</span> <span class="toc-text">MyBatis中的动态SQL是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说一下-mybatis-的一级缓存和二级缓存？"><span class="toc-number">6.4.</span> <span class="toc-text">说一下 mybatis 的一级缓存和二级缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mybatis和Hibernate的区别有哪些？"><span class="toc-number">6.5.</span> <span class="toc-text">mybatis和Hibernate的区别有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis-有哪些执行器（Executor）？"><span class="toc-number">6.6.</span> <span class="toc-text">Mybatis 有哪些执行器（Executor）？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo"><span class="toc-number">7.</span> <span class="toc-text">Dubbo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper"><span class="toc-number">8.</span> <span class="toc-text">Zookeeper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MongoDB"><span class="toc-number">9.</span> <span class="toc-text">MongoDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">10.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis支持的五种结构"><span class="toc-number">10.1.</span> <span class="toc-text">redis支持的五种结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis通信协议是什么"><span class="toc-number">10.2.</span> <span class="toc-text">redis通信协议是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis是如何持久化的"><span class="toc-number">10.3.</span> <span class="toc-text">redis是如何持久化的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis的watch实现原理"><span class="toc-number">10.4.</span> <span class="toc-text">redis的watch实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis是否支持事务"><span class="toc-number">10.5.</span> <span class="toc-text">redis是否支持事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis如何实现主从复制"><span class="toc-number">10.6.</span> <span class="toc-text">redis如何实现主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis如何实现定制过期删除"><span class="toc-number">10.7.</span> <span class="toc-text">redis如何实现定制过期删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ElasticSearch"><span class="toc-number">11.</span> <span class="toc-text">ElasticSearch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka"><span class="toc-number">12.</span> <span class="toc-text">Kafka</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RibbitMQ"><span class="toc-number">13.</span> <span class="toc-text">RibbitMQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ"><span class="toc-number">14.</span> <span class="toc-text">RocketMQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ActiveMQ"><span class="toc-number">15.</span> <span class="toc-text">ActiveMQ</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>






    
        <section id="comments">
<link rel="stylesheet" href="/css/gitment.min.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: '面试之---框架相关', // 可选。默认为 location.href
  owner: 'ZhaoGitHub1',
  repo: 'ZhaoGitHub1.github.io',
  oauth: {
    client_id: '0959e9fdfc97cef82968',
    client_secret: '126454836d441306e61dfbf9bb3ddc6cef1bf93d',
  },
})
gitment.render('comments')
</script>
</section>
    



    <div class="scroll" id="post-nav-button">
        
            <a  href="/2018/09/27/git-commands/" title="上一篇: git常用命令">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a  href="/2018/09/16/interview-others/" title="下一篇: 面试之---其他细小知识点汇总">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/01/tool-idea/">IDEA使用总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/12/tool-recommend/">工具推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/06/spring-data-jpa-summary/">spring-data-jpa使用总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/17/kafka-learn-and-summary/">Kafka学习和总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/10/list-books/">推荐书单整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/01/redis-file-lock/">redis实现分布式文件夹锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/16/read-note-readable-code/">读书笔记---《编写可读代码的艺术》</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/27/hashmap/">HashMap源码阅读</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/28/java-code-optimize/">java代码优化建议</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/git-commands/">git常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-framework/">面试之---框架相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-others/">面试之---其他细小知识点汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-optimize/">面试之---安全与性能优化相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-algorithm/">面试之---算法相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-java-basic/">面试之---java基础相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-tools/">面试之---工具使用相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/interview-db/">面试之---数据库相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/15/linux-commands/">linux常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/tree-projects/">项目树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/12/redis-summary/">Redis总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/about-Hexo/">Hexo博客搭建相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/10/pattern-singleton/">设计模式之---单例模式(Singleton Pattern)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/09/list-sites/">常用网站清单</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/my-pictures/">我的画集</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/pattern-all/">设计模式之---汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/springboot-app-deploy/">SpringBoot项目打包发布Linux环境完整流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/nginx-config/">【转载】nginx配置文件nginx.conf超详细讲解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/thread-realize/">创建线程的几种方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/concurrentHashMap-analyze/">【转载】ConcurrentHashMap原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/tree-skills/">技能树</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/springApplication-analyze/">SpringBoot源码分析之---SpringBoot项目启动类SpringApplication浅析</a></li></ul>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2019 逸竹
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/ZhaoGitHub1" target="_blank">Blog</a> by 逸竹
            </div>
        </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 8;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?eb7d8cefd581790a3213e8feb93ae89f";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>